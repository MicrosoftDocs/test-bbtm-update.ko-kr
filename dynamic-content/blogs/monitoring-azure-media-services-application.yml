### YamlMime:Yaml
ms.openlocfilehash: 2c7c94193151f66d0d9a4392d85967595009d026
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911667"
Slug: monitoring-azure-media-services-application
Title: Azure Media Services 애플리케이션 모니터링
Summary: 이 게시물은 Media Services 기반으로 빌드된 애플리케이션에 대한 모니터링 시스템을 계획하기 위한 시작점으로 사용할 수 있는 샘플 코드를 제공합니다.
Content: "모니터링은 프로덕션 온라인 애플리케이션의 중요한 구성 요소입니다. 제대로 구현된 모니터링 시스템을 사용하면 주요 이벤트에 대한 경고를 수신하고 적절하게 대응할 수 있습니다. 이 게시물에서는 Media Services 계정을 모니터링하기 위해 작성한 몇 가지 샘플 코드를 살펴보겠습니다. 샘플 코드를 시작점으로 사용하여 Media Services 기반으로 빌드된 애플리케이션에 대한 사용자 지정 모니터링 시스템 계획을 시작할 수 있습니다.\n\n&nbsp;\n<h2>샘플 코드</h2>\n높은 수준에서 제공된 샘플 코드는 정기적으로 서비스에 대해 일부 코드를 실행하는 원칙에 따라 작동합니다. 그런 다음 작업 결과가 기록되고 다른 코드 조각이 로그에서 정기적으로 실패를 확인합니다. 프로그래밍된 실패 조건이 트리거되면 경고가 발생합니다. 이 경우 코드는 두 개의 Visual Studio 프로젝트로 나뉩니다. 첫 번째 프로젝트는 Media Services 자산 만들기 및 삭제 API를 정기적으로 호출하고 Azure 테이블에 결과를 기록합니다. 두 번째 프로젝트는 Azure 테이블의 상위 5개 항목을 정기적으로 검사하여 오류를 확인하고 5개 항목이 모두 실패로 기록된 경우 경고를 발생합니다.\n\n첫 번째 프로젝트의 App.config 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n&lt;MediaAccountName&gt; 및 &lt;MediaAccountKey&gt;를 모니터링하려는 Media Services 계정의 이름과 키로 바꿉 있습니다. 마찬가지로 StorageAccountName&gt; 및 &lt;StorageAccountKey&gt;를 모니터링 데이터를 기록할 스토리지 계정의 이름과 키로 바꿉&lt;니다.\n\n&nbsp;\n\n모니터링을 수행하는 코드는 다음과 같습니다. 앞에서 설명한 것처럼 코드는 무한 루프로 실행되고 매분마다 Media Services API를 호출하여 자산을 만든 다음 삭제합니다. API 호출이 실패하면 Azure 테이블에 실패 항목이 기록됩니다. 그렇지 않으면 성공 항목을 기록합니다. 사용되는 함수에 대한 설명은 코드 자체 아래에 있습니다.\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace Monitoring\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetLogEntity : TableEntity\n    {\n        public int Status { get; set; }        \n        public string FailureData { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _monitoringTable = null;\n\n        // Field for service context.\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(\n                                _mediaServicesAccountName,\n                                _mediaServicesAccountKey);\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _monitoringTable = _tableClient.GetTableReference(\"MonitoringData\");\n                _monitoringTable.CreateIfNotExists();\n\n                Monitor();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void Monitor()\n        {\n            try\n            {\n                while (true)\n                {\n                    try\n                    {\n                        Console.WriteLine(\"Starting Monitoring loop: \" + DateTime.Now.ToString());\n                        IAsset _asset = _context.Assets.Create(\"Monitoring Asset\", AssetCreationOptions.None);\n                        if (_asset == null)\n                        {\n                            LogMonitoringData(1, \"Create Asset returned null\");\n                        }\n                        else\n                        {\n                            _asset.Delete();\n                        }\n\n                        LogMonitoringData(0);\n                    }\n                    catch (Exception x)\n                    {\n                        Console.WriteLine(x.Message);\n                        LogMonitoringData(1, x.Message);\n                    }\n\n                    Console.WriteLine(\"Going to sleep for a minute\");\n                    Console.WriteLine(\"\");\n                    Thread.Sleep(1000 * 60);\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void LogMonitoringData(int status, string _failureData = \"\")\n        {\n            try\n            {\n                AssetLogEntity _assetLogEntity = new AssetLogEntity();\n                _assetLogEntity.PartitionKey = \"Asset\";\n                _assetLogEntity.RowKey = (DateTime.MaxValue.Ticks - DateTime.Now.Ticks).ToString(\"D12\");\n                _assetLogEntity.Status = status;\n                _assetLogEntity.FailureData = _failureData;\n\n                TableOperation op = TableOperation.Insert(_assetLogEntity);\n                _monitoringTable.Execute(op);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n    }\n}</pre>\n코드는 상당히 직선입니다. 다음은 간단한 설명입니다.\n<ul>\n <li><strong>AssetLogEntity </strong>– 이 클래스는 테이블 엔터티를 정의합니다. 위의 코드는 성공의 경우 상태 0, 실패의 경우 상태 1을 기록합니다. FailureData 문자열은 Status = 1일 때 실패 메시지를 작성하는 데 사용됩니다.</li>\n <li><strong>main</strong> – main 함수는 Media Services 계정 컨텍스트를 만듭니다. 그런 다음 <strong>MonitoringData</strong> Azure 테이블이 아직 없는 경우 만듭니다. 마지막으로 <strong>Monitor</strong> 함수를 호출합니다.</li>\n <li><strong>모니터 </strong>– 기본 모니터링 코드입니다. 함수는 무한 루프로 실행됩니다. 매분마다 Media Services 계정 컨텍스트를 사용하여 자산을 만든 다음 삭제합니다. API가 성공하면 성공한 경우 <strong>LogMonitoringData</strong> 함수를 호출하여 실패를 기록합니다.</li>\n <li><strong>LogMonitoringData</strong> – 이 함수는 <strong>MonitoringData</strong> 테이블에 데이터를 쓰는 실제 작업을 수행합니다. 최신 로그 항목이 맨 위에 있는지 확인하기 위해 현재 DataTime에서 최대 DateTime 값을 빼서 계산되는 rowkey를 사용합니다. Azure 테이블이 항목을 오름차순으로 열거하기 때문입니다.</li>\n</ul>\n&nbsp;\n\n두 번째 프로젝트의 App.config 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n구성 파일은 Media Services 계정 자격 증명이 없다는 점을 제외하고 첫 번째 프로젝트와 비슷합니다(이 프로젝트는 <strong>MonitoringData</strong> 테이블의 항목에만 집중하기 때문에). 높은 수준에서 이 코드는 무한 루프로 실행되며 1분마다 5개의 연속 실패 항목이 기록되었는지 확인합니다. 그렇다면 경고가 발생합니다. 코드는 아래에 있으며 코드의 함수에 대한 간략한 설명이 뒤따릅니다.\n<pre class=\"prettyprint\">using Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace Alerts\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetLogEntity : TableEntity\n    {\n        public int Status { get; set; }\n        public string FailureData { get; set; }\n    }\n\n    class Program\n    {\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _monitoringTable = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _monitoringTable = _tableClient.GetTableReference(\"MonitoringData\");\n                _monitoringTable.CreateIfNotExists();\n\n                CheckforFailures();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        static void CheckforFailures()\n        {\n            while (true)\n            {\n                try\n                {\n                    Console.WriteLine(\"Starting failure checking loop \" + DateTime.Now.ToString());\n                    TableQuery&lt;AssetLogEntity&gt; query = new TableQuery&lt;AssetLogEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, \"Asset\"));\n                    query.Take(5);\n\n                    TableQuerySegment&lt;AssetLogEntity&gt; tqs = _monitoringTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count == 5)\n                        {\n                            bool _fireAlert = true;\n                            for (int i = 0; i &lt; tqs.Results.Count; i++)\n                            {\n                                if (tqs.Results[i].Status == 0)\n                                {\n                                    _fireAlert = false;\n                                    break;\n                                }\n                            }\n\n                            if (_fireAlert)\n                            {\n                                Console.WriteLine(\"More than 5 consecutive failures detected\");\n                            }\n                        }\n                    }\n\n                    Console.WriteLine(\"Going to sleep for a minute\");\n                    Console.WriteLine(\"\");\n                    Thread.Sleep(1000 * 60);\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine(ex.Message);\n                }\n            }\n        }\n    }\n}</pre>\n코드에 대한 간략한 설명은 다음과 같습니다.\n<ul>\n <li><strong>AssetLogEntity </strong>– 첫 번째 프로젝트와 동일합니다.</li>\n <li><strong>main </strong>– main 함수는 <strong>MonitoringData</strong> 테이블에 대한 참조를 만들고 <strong>CheckforFailures</strong> 함수를 호출합니다.</li>\n <li><strong>CheckforFailures</strong> – 이 함수는 무한 루프를 반복합니다. 1분마다 <strong>MonitoringData</strong> 테이블에서 상위 5개 항목을 가져오고 5개 항목이 모두 실패했는지 확인합니다. 그렇다면 화면에 메시지를 인쇄하여 경고를 발생합니다.</li>\n</ul>\n&nbsp;\n\n오류를 시뮬레이션하기 위해 Azure 관리 포털로 이동하여 Media Services 계정과 연결된 Storage 계정의 키를 다시 생성했습니다. 이 작업을 수행하면 Media Services 계정이 자산에 대한 컨테이너를 만들기 위해 Storage 계정에 액세스할 수 없어 첫 번째 프로젝트에서 CreateAsset 호출이 실패했습니다. 5분 이상 기다린 후 Azure 관리 포털로 돌아가서 \"기본 키 동기화\" 단추를 클릭하여 스토리지 키를 동기화했습니다(아래 스크린샷 참조).\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-18_12h05_23.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-18_12h05_23\" alt=\"2014-07-18_12h05_23\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-18_12h05_23_thumb.png\" width=\"623\" height=\"484\" border=\"0\" /></a>\n\n이 작업을 수행하면 몇 분 후에 Media Services 계정이 다시 작동하게 됩니다. 다음은 <strong>MonitoringData</strong> 테이블 항목의 스크린샷입니다. 오류에 해당하는 항목을 강조 표시했습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h08_11-LogTable.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h08_11-LogTable\" alt=\"2014-07-17_16h08_11-LogTable\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h08_11-LogTable_thumb.png\" width=\"1028\" height=\"623\" border=\"0\" /></a>\n\n다음은 위의 두 샘플 코드 프로젝트와 연결된 콘솔 창의 스크린샷입니다. 두 스크린샷 모두 실패 기간이 요약되어 있습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h03_30-Monitoring.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h03_30 모니터링\" alt=\"2014-07-17_16h03_30-Monitoring\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h03_30-Monitoring_thumb.png\" width=\"696\" height=\"772\" border=\"0\" /></a>\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-17_16h04_16-Alerts.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-17_16h04_16-경고\" alt=\"2014-07-17_16h04_16-Alerts\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-17_16h04_16-Alerts_thumb.png\" width=\"744\" height=\"772\" border=\"0\" /></a>\n\n&nbsp;\n<h2>고려 사항</h2>\n이 항목에 대한 몇 가지 닫는 설명\n<ul>\n <li>Media Services 계정과 연결된 스토리지 계정을 사용하여 <strong>MonitoringData </strong>테이블을 만들지 않았습니다. 실제로 다른 데이터 센터에서 스토리지 계정을 사용했습니다. 위의 샘플은 Media Services 계정 자체와 관련된 하나의 실패 상황을 시뮬레이션했지만 미디어 애플리케이션이 호스트되는 데이터 센터에서 네트워킹 문제 또는 스토리지 서비스 문제와 관련된 오류를 catch하려는 경우 모니터링 데이터를 다른 위치에 작성하는 것이 가장 좋습니다. 모니터링 및 경고 코드를 실행하는 위치도 마찬가지입니다. Media Services 계정이 있는 데이터 센터 외부에서 위의 두 샘플 코드를 실행했습니다.</li>\n <li>모니터링 빈도 및 경고 조건을 신중하게 선택합니다. 매우 중요한 모니터링 시스템에서는 너무 많은 잘못된 경고가 발생합니다.</li>\n <li>잘 설계된 모니터링 시스템은 여러 Azure 데이터 센터에서 여러 인스턴스로 실행되는 <a href=\"https://en.wikipedia.org/wiki/High_availability\">고가용성</a> 애플리케이션을 빌드할 때 장애 조치(<a href=\"https://en.wikipedia.org/wiki/Failover\">failover</a>) 및 장애 복구(Failback)를 자동화하는 데 도움이 될 수 있습니다.</li>\n <li>위의 샘플에서는 Media Services 계정 자체를 모니터링합니다. 동일한 원칙을 사용하여 Media Services 기반으로 빌드된 애플리케이션을 모니터링하는 것이 좋습니다.</li>\n <li>또한 위의 샘플의 원칙을 사용하여 애플리케이션이 종속된 다른 Azure 서비스를 모니터링할 수 있습니다.</li>\n</ul>"
