### YamlMime:Yaml
ms.openlocfilehash: 84b2ece8da121b9484503d247fe9e15dbaba5f07
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901868"
Slug: writing-blobs-from-sql-azure-to-windows-azure-storage
Title: SQL Azure blob을 Windows Azure Storage 쓰기
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 이 블로그 게시물에 소개된 SqlStream 클래스를 사용하여 수행할 수 있는 더 흥미로운 작업 중 하나는 다음에서 Windows Azure Storage 쓰는 것입니다.'
Content: '<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>이 블로그 게시물에 소개된 <b>SqlStream</b> 클래스를 사용하여 수행할 수 있는 더 흥미로운 작업 중 하나는 SQL Azure Windows Azure Storage 쓰는 것입니다. Windows Azure Storage는 클라우드에서 지속형 영구 스토리지를 제공합니다. 스토리지 서비스에 액세스하려면 <a href="https://windows.azure.com/Cloud/Provisioning/Default.aspx">Azure Portal</a>을 통해 만든 스토리지 계정이 있어야 합니다.</p>  <p>Imagine 회사의 제품 이미지가 타이틀, 가격 및 설명과 같은 다른 제품 데이터와 함께 데이터베이스에 저장되도록 의무화합니다. 웹 페이지에서 해당 이미지를 제공하는 한 가지 방법은 데이터베이스에서 이미지를 검색하고 브라우저로 스트리밍하는 것입니다.</p>  <p>그러나 첫 번째 요청에서 데이터베이스에서 읽은 다음 모든 요청에 따라 제공되는 Windows Azure Storage 작성하는 것이 더 좋습니다. SQL Azure 다른 제품 데이터와 이미지를 유지하는 데이터 무결성과 Windows Azure Storage 정적 파일을 스트리밍하는 성능 이점을 얻을 수 있습니다. 이는 Azure Content Delivery Network Windows 활용할 수 있는 경우에 특히 유용합니다.</p>  <p>다음 코드 샘플에서는 제품 썸네일을 <b>varbinary(max)</b>로 저장하는 Adventure Works 데이터베이스를 사용하여 이 시나리오를 구현합니다. 코드는 다음과 같은 작업을 수행하도록 설계되었습니다.</p>  <ul>   <li>Windows Azure 플랫폼에서 실행합니다. </li>    <li>쿼리 문자열의 제품 ID를 사용하여 요청에서 ASP.NET 페이지로 이미지를 제공합니다. </li>    <li>Adventure Works 데이터베이스의 Products 테이블에서 이미지를 읽고 썸네일 이미지를 아직 없는 경우 Windows Azure Storage 씁니다. </li>    <li>브라우저를 Windows Azure Storage 리디렉션하여 이미지를 제공합니다. </li>    <li>전체 이미지가 메모리 공간에 로드되지 않도록 스트리밍을 사용합니다. </li> </ul>  <p>SQL Azure 데이터베이스, Windows Azure Web Role 및 Windows Azure Storage 컨테이너가 동일한 데이터 센터에 있는 경우 SQL Azure Windows Azure Storage 간에 데이터를 전송하는 데 비용이 들지 않습니다. 이는 SQL Azure Windows Azure Storage 직접 전송되지 않으며, 코드는 SQL Azure 이미지를 읽고 Azure Cloud Storage Windows 기록합니다. 코드를 실행하면 데이터가 Windows Azure 역할을 통해 전달됩니다.</p>  <h2>코드</h2>  <pre class="csharpcode"><span class="kwrd">protected</span> <span class="kwrd">void</span> Page_Load(<span class="kwrd">object</span> sender, EventArgs e)  {      Int32 id = Int32.Parse(Request.QueryString[<span class="str">&quot;ProductId&quot;</span>]);        CloudStorageAccount.SetConfigurationSettingPublisher(          (configName, configSetter) =&gt;      {           <span class="kwrd">if</span> (!configSetter(               RoleEnvironment.GetConfigurationSettingValue(configName)))               RoleEnvironment.RequestRecycle();      });        CloudStorageAccount cloudStorageAccount =                CloudStorageAccount.FromConfigurationSetting(                  <span class="str">&quot;DataConnectionString&quot;</span>);      CloudBlobClient cloudBlobClient =                cloudStorageAccount.CreateCloudBlobClient();      CloudBlobContainer cloudBlobContainer =               cloudBlobClient.GetContainerReference(<span class="str">&quot;images&quot;</span>);      cloudBlobContainer.CreateIfNotExist();        <span class="rem">// WWB: Set Up Public Access To the Container       //(So That We Can Redirect Anyone To the Image)      // Be careful of the putting confidential information on a public       // network, this example is for images.</span>      BlobContainerPermissions permissions = cloudBlobContainer.GetPermissions();      permissions.PublicAccess = BlobContainerPublicAccessType.Container;      cloudBlobContainer.SetPermissions(permissions);        <span class="rem">// WWB: Get Connection String from .cscfg</span>      String connectionString =          RoleEnvironment.GetConfigurationSettingValue(<span class="str">&quot;SqlConnectionString&quot;</span>);        <span class="kwrd">using</span> (SqlConnection sqlConnection =             <span class="kwrd">new</span> SqlConnection(connectionString))      {          sqlConnection.Open();            <span class="rem">// WWB: Get The File Name From SQL Azure For This Id</span>          <span class="rem">// The FileName is Stored In the Products Table</span>          String fileName = FetchFileName(sqlConnection, id);            <span class="kwrd">try</span>          {              CloudBlockBlob cloudBlockBlob =                  cloudBlobContainer.GetBlockBlobReference(fileName);                <span class="rem">// WWB: Set the Blob Options So That We Only Upload Once </span>              BlobRequestOptions blobRequestOptions = <span class="kwrd">new</span> BlobRequestOptions();              blobRequestOptions.AccessCondition =                   AccessCondition.IfNoneMatch(“*”);                <span class="rem">// WWB: Open a Stream to SQL Azure</span>              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(                  sqlConnection, <span class="str">&quot;SalesLT&quot;</span>,                  <span class="str">&quot;Product&quot;</span>,                  <span class="str">&quot;ThumbNailPhoto&quot;</span>,                  <span class="str">&quot;ProductID&quot;</span>, SqlDbType.Int, id))              {                  <span class="rem">// WWB: Upload To Azure Storage Using Our Stream</span>                  cloudBlockBlob.UploadFromStream(sqlStream);              }                <span class="rem">// WWB: Redirect This Request For An Image To Blob Storage URL</span>              Response.Redirect(cloudBlockBlob.Uri.AbsoluteUri);            }          <span class="kwrd">catch</span> (StorageClientException storageClientException)          {              <span class="kwrd">switch</span> (storageClientException.ErrorCode)              {                  <span class="kwrd">case</span> StorageErrorCode.ConditionFailed:                  <span class="kwrd">case</span> StorageErrorCode.BlobAlreadyExists:                      <span class="kwrd">break</span>;                  <span class="kwrd">default</span>:                      <span class="kwrd">throw</span>;              }          }      }  }    <span class="kwrd">private</span> String FetchFileName(SqlConnection sqlConnection, Int32 id)  {      String sql = <span class="str">&quot;SELECT [ThumbnailPhotoFileName] FROM&quot;</span> +          <span class="str">&quot;[SalesLT].[Product] WHERE [ProductID] = @Id&quot;</span>;      <span class="kwrd">using</span> (SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection))      {          sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@Id&quot;</span>, id);          <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              <span class="kwrd">if</span> (!sqlDataReader.HasRows)                  <span class="kwrd">throw</span> (<span class="kwrd">new</span>                    ArgumentException(<span class="str">&quot;Id Not Found&quot;</span>,                        <span class="str">&quot;id&quot;</span>));                sqlDataReader.Read();                <span class="kwrd">return</span>                ((String)sqlDataReader[<span class="str">&quot;ThumbnailPhotoFileName&quot;</span>]);          }      }  }</pre>    <p>    <h2>코드 사용</h2>    <p>이 코드는 매우 보편적이며 다른 시나리오에서 사용할 수 있습니다. 한 가지 흥미로운 아이디어는 로컬 SQL Server 데이터베이스를 사용하여 로컬로 호스트된 IIS 서버에서 실행하는 것입니다. 코드는 로컬 SQL Server 읽고 데이터베이스의 이미지를 Windows Azure CDN 처리할 수 있는 Windows Azure Storage 푸시합니다.</p>    <p>첫 번째 요청은 SQL Azure 읽고 Windows Azure Storage 써야 하므로 다른 모든 요청보다 오래 걸립니다. 또 다른 아이디어는 첫 번째 요청이 응답하는 데 오래 걸리지 않도록 Windows Azure Storage 미리 로드할 수 있다는 것입니다. Windows Azure Web Role에서 이미지를 업로드하는 경우 업로드 후 Windows Azure Storage 쓸 수 있습니다. 이렇게 하면 Windows Azure Storage 제품 데이터 및 이미지 컨테이너와 함께 SQL Azure 두 위치에 이미지 데이터가 채워집니다.</p>    <h2>요약</h2>    <p>질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>'
