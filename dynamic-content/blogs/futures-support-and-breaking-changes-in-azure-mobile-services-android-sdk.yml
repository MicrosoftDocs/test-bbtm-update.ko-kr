### YamlMime:Yaml
ms.openlocfilehash: 50ab6f76c16533d0e63a6479f6a4c9c34d1027c0
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911295"
Slug: futures-support-and-breaking-changes-in-azure-mobile-services-android-sdk
Title: Mobile Services Android SDK의 선물 지원 및 호환성이 손상되는 변경
Summary: Android에서 비동기 호출 사용에 대한 피드백을 해결하기 위해 향후 지원을 통해 Azure Mobile Services 대한 Android SDK의 주요 업데이트를 릴리스했습니다. 이제 중첩된 여러 콜백을 처리하지 않고도 여러 작업을 쉽게 수행할 수 있습니다. 대부분의 시나리오에서는 변경 내용이 추가되지만 일부 고급 시나리오에서는 미래를 비동기 작업을 처리하기 위해 Azure Mobile Services Android SDK에서 사용하는 기본 모델로 만들기 위해 호환성이 손상되는 변경을 수행했습니다.
Content: >-
  Azure용 Android SDK Mobile Services 주요 업데이트를 릴리스했습니다. Android에서 비동기 호출을 사용하는 방법에 대한 몇 가지 피드백을 해결하기 위해 여러 중첩된 콜백을 처리하지 않고도 백그라운드 스레드에서 여러 작업을 쉽게 수행할 수 있도록 모든 비동기 작업에서 <a href="https://developer.android.com/reference/java/util/concurrent/Future.html">Futures</a> 에 대한 지원을 추가했습니다. 변경 내용은 대부분의 시나리오에서 추가(콜백 매개 변수를 사용하는 메서드와 함께 미래를 반환하는 새로운 메서드)이지만, 고급 인터페이스(예: ServiceFilter)에서 사용되는 일부 기본 인터페이스에서는 현재 선물이 비동기 작업을 처리하기 위해 Mobile Services Android SDK에서 사용하는 기본 모델이 되도록 호환성이 손상되는 변경을 수행했습니다. 이 릴리스에서는 오프라인 지원도 추가했지만 주요 변경 내용에 집중하기 위해 향후 게시물에서 이에 대해 설명하겠습니다.


  <strong>TL;DR</strong>: 이 게시물의 나머지 는 새로운 선물 지원 및 주요 변경 사항 목록에 대해 설명합니다. 원하는 것이 새 SDK를 사용하여 재생하는 것이라면 .에서 <a title="https://aka.ms/Iajk6qhttps://aka.ms/Iajk6q" href="https://aka.ms/Iajk6q"></a>가져올 수 있습니다. 여전히 알파 버전이며 변경될 수 있습니다.

  <h2>미래</h2>

  다음은 새 선물 지원을 사용하여 더 간단하게 만드는 코드의 예입니다. 이전에는 여러 작업을 실행해야 하는 경우 콜백 중첩이 신속하게 부담이 될 수 있습니다. 예를 들어 쿼리 결과를 반복하고 항목을 업데이트해야 하는 경우 콜백 기반 코드는 간단하지 않은 코드가 될 수 있습니다.

  <pre class="prettyprint">final MobileServiceTable&lt;TodoItem&gt; table = mClient.getTable(TodoItem.class);

  table.where().field("complete").eq(false).execute(new TableQueryCallback&lt;TodoItem&gt;() {

      @Override
      public void onCompleted(final List&lt;TodoItem&gt; items, int unused,
              Exception error, ServiceFilterResponse response) {

          TableOperationCallback&lt;TodoItem&gt; updateCallback = new TableOperationCallback&lt;TodoItem&gt;() {

              private int mIndex;

              @Override
              public void onCompleted(TodoItem updated,
                      Exception error, ServiceFilterResponse response) {
                  mIndex++;
                  if (mIndex == items.size()) {
                      tv.setText("Marked all items as complete");
                  } else {
                      TodoItem item = items.get(mIndex);
                      item.setComplete(true);
                      table.update(item, this);
                  }

              }
          };

          if (items.size() &gt; 0) {
              TodoItem first = items.get(0);
              first.setComplete(true);
              table.update(first, updateCallback);
          }

      }
  });</pre>

  향후 지원을 통해 코드가 백그라운드 스레드를 실행하는 경우 호출이 훨씬 더 깨끗해집니다. 위의 코드와 동일한 작업을 수행하는 아래 코드를 사용합니다. 6줄의 코드로 요약됩니다(코드가 UI 스레드에 아직 없거나 UI 구성 요소를 수정할 필요가 없는 경우 필요하지 않은 일부 예외 처리 및 스레드 건너뛰기).

  <pre class="prettyprint">new AsyncTask&lt;Void, Void, Void&gt;() {

      @Override
      protected Void doInBackground(Void... params) {
          final MobileServiceTable&lt;TodoItem&gt; table = mClient.getTable(TodoItem.class);
          try {
              MobileServiceList&lt;TodoItem&gt; results = table.where().field("complete").eq(false).execute().get();
              for (TodoItem todoItem : results) {
                  todoItem.setComplete(true);
                  table.update(todoItem).get();
              }
              runOnUiThread(new Runnable() {

                  @Override
                  public void run() {
                      tv.setText("Marked all items as complete");
                  }
              });
          } catch (Exception e) {
              e.printStackTrace();
          }

          return null;
      }

  }.execute();</pre>

  위의 코드는 몇 가지 예외 처리 및 스레드 건너뛰기를 사용하므로 더 작습니다. 그러나 코드 논리는 다음 6줄의 코드로 요약됩니다.

  <pre class="prettyprint">final MobileServiceTable&lt;TodoItem&gt; table = mClient.getTable(TodoItem.class);

  MobileServiceList&lt;TodoItem&gt; results = table.where().field("complete").eq(false).execute().get();

  for (TodoItem todoItem : results) {
      todoItem.setComplete(true);
      table.update(todoItem).get();
  }</pre>

  이것이 선물 사용의 주요 이점입니다. 간단한 프로그래밍 모델(특히 선물 연결 관련). 또한 취소, 병합 용이성(조인) 여러 선물 등과 같은 다른 기능도 제공합니다.

  <h2>새로운 API</h2>

  좋아, 선물은 좋은, 나는 그것을 사용하는 방법? 테이블 및 사용자 지정 API와 같은 기본 작업의 경우 이전에 콜백 매개 변수를 사용한 각 메서드에는 콜백을 수행하지 않고 나중에 인터페이스를 반환하는 새 오버로드가 있습니다. 기존 앱에 필요한 변경 내용을 최소화하기 위해 현재 콜백 기반 메서드는 여전히 존재하지만, 이제 <code>@deprecated</code> 는 이후 릴리스에서 제거될 수 있도록 표시되어 있습니다(주 버전 업그레이드 포함). 이는 사용자 지정 API에 적용됩니다(예: MobileServiceClient 클래스의 invokeApi 메서드 오버로드가 9개 있기 전에는 18개), 푸시 등록/등록 취소, 형식화 및 형식화되지 않은 테이블(모든 CRUD 작업) 및 로그인(모든 오버로드). 예를 들어 invokeApi 메서드의 이전 오버로드입니다.

  <pre class="prettyprint">public &lt;E&gt; void invokeApi(String apiName, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback)

  public &lt;E&gt; void invokeApi(String apiName, Object body, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback)

  public &lt;E&gt; void invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, Class&lt;E&gt; clazz, ApiOperationCallback&lt;E&gt; callback)

  public &lt;E&gt; void invokeApi(String apiName, Object body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, final Class&lt;E&gt; clazz, final ApiOperationCallback&lt;E&gt; callback)

  public void invokeApi(String apiName, ApiJsonOperationCallback callback)

  public void invokeApi(String apiName, JsonElement body, ApiJsonOperationCallback callback)

  public void invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, ApiJsonOperationCallback callback)

  public void invokeApi(String apiName, JsonElement body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, final ApiJsonOperationCallback callback)

  public void invokeApi(String apiName, byte[] content, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; requestHeaders, List&lt;Pair&lt;String, String&gt;&gt; parameters, final ServiceFilterResponseCallback callback)</pre>

  그리고 이러한 버전은 기존 버전과 나란히 존재하는 새 버전입니다.

  <pre class="prettyprint">public &lt;E&gt; ListenableFuture&lt;E&gt; invokeApi(String apiName, Class&lt;E&gt; clazz)

  public &lt;E&gt; ListenableFuture&lt;E&gt; invokeApi(String apiName, Object body, Class&lt;E&gt; clazz)

  public &lt;E&gt; ListenableFuture&lt;E&gt; invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, Class&lt;E&gt; clazz)

  public &lt;E&gt; ListenableFuture&lt;E&gt; invokeApi(String apiName, Object body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters, final Class&lt;E&gt; clazz)

  public ListenableFuture&lt;JsonElement&gt; invokeApi(String apiName)

  public ListenableFuture&lt;JsonElement&gt; invokeApi(String apiName, JsonElement body)

  public ListenableFuture&lt;JsonElement&gt; invokeApi(String apiName, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters)

  public ListenableFuture&lt;JsonElement&gt; invokeApi(String apiName, JsonElement body, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; parameters)

  public ListenableFuture&lt;ServiceFilterResponse&gt; invokeApi(String apiName, byte[] content, String httpMethod, List&lt;Pair&lt;String, String&gt;&gt; requestHeaders, List&lt;Pair&lt;String, String&gt;&gt; parameters)</pre>

  <h2>주요 변경 내용</h2>

  선물 전용/콜백이 없는 모델로 전환할 때 기존 메서드를 더 이상 사용하지 않고 <a href="https://developer.android.com/reference/java/util/concurrent/Future.html">Futures</a> 결과와 함께 새 메서드를 추가하여 주요 클래스에서 이전 버전과의 호환성을 유지할 수 있습니다. 그러나 콜백 기반의 일부 인터페이스가 있으며 해당 인터페이스에 futures 메서드를 추가할 수 없습니다(구현된 클래스를 중단하기 때문에). 모든 인터페이스를 복제하고 클래스가 새 인터페이스와 이전 인터페이스를 모두 구현할 수 있었지만, 이로 인해 패키지에 불필요한 부풀림이 발생했습니다. 그리고 미래 기반 코드의 방향을 전환하고 있으므로 이러한 인터페이스에 대한 호환성이 손상되는 변경을 도입하기로 결정했습니다. 따라서 새 릴리스에 주 버전 증가가 포함됩니다. 또한 호환성이 손상되는 변경에 대한 높은 임계값을 초과했기 때문에 클래스가 더 잘 구성되도록 (오히려 큰) com.microsoft.windowsazure.mobileservices 패키지를 여러 "하위 패키지"로 분할하는 등 코드에서 정리를 수행할 수 있는 기회를 사용했습니다. 마지막으로 작성할 코드가 적도록 쿼리 결과도 변경했습니다. 모든 주요 변경 내용과 코드에서 해결할 수 있는 방법을 살펴보겠습니다.

  <h3>패키지 변경 내용</h3>

  com.microsoft.windowsazure.mobileservices 패키지에 속하고 이제 새 패키지에 속하는 공용 클래스의 목록입니다. (*)로 표시된 항목에는 아래에 추가 변경 내용이 나열되어 있습니다.

  <ul>
   <li>com.microsoft.windowsazure.mobileservices.authentication
  <ul>
   <li>LoginAsync</li>
   <li>MobileServiceUser</li>
  </ul>

  </li>
   <li>com.microsoft.windowsazure.mobileservices.http
  <ul>
   <li>AndroidHttpClientFactory</li>
   <li>AndroidHttpClientFactoryImpl</li>
   <li>NextServiceFilterCallback(*)</li>
   <li>ServiceFilter(*)</li>
   <li>ServiceFilterRequest</li>
   <li>ServiceFilterResponse</li>
  </ul>

  </li>
   <li>com.microsoft.windowsazure.mobileservices.notifications
  <ul>
   <li>GcmNativeRegistration</li>
   <li>GcmTemplateRegistration</li>
   <li>MobileServicePush</li>
   <li>등록</li>
   <li>RegistrationCallback</li>
   <li>RegistrationGoneException</li>
   <li>TemplateRegistration</li>
   <li>TemplateRegistrationCallback</li>
   <li>UnregisterCallback</li>
  </ul>

  </li>
   <li>com.microsoft.windowsazure.mobileservices.table
  <ul>
   <li>MobileServiceJsonTable</li>
   <li>MobileServicePreconditionFailedException</li>
   <li>MobileServicePreconditionFailedExceptionBase</li>
   <li>MobileServiceSystemProperty</li>
   <li>MobileServiceTable</li>
   <li>TableDeleteCallback</li>
   <li>TableJsonOperationCallback</li>
   <li>TableJsonQueryCallback</li>
   <li>TableOperationCallback</li>
   <li>TableQueryCallback</li>
  </ul>

  </li>
   <li>com.microsoft.windowsazure.mobileservices.table.query
  <ul>
   <li>MobileServiceQuery (*)
  <ul>
   <li>두 개의 새 서브클래스인 ExecutableQueryE&lt;&gt; 및 ExecutableJsonQuery를 사용하여 쿼리로 이름이 바뀌었습니다.</li>
  </ul>

  </li>
   <li>MobileServiceQueryOperations
  <ul>
   <li>형식화된 쿼리를 만드는 데 사용되는 정적 작업을 사용하는 클래스입니다. QueryOperations로 이름이 바뀌었습니다.</li>
  </ul>

  </li>
   <li>QueryOrder</li>
  </ul>

  </li>

  </ul>

  패키지 변경 내용이 많았지만 Eclipse에서 자동으로 해결할 수 있습니다. "원본" 메뉴에서 "가져오기 구성"(또는 Ctrl+Shift+O)을 선택합니다.

  <h3>MobileServiceQuery</h3>

  MobileServiceQuery 인터페이스는 테이블에 대한 쿼리를 나타내는 데 사용되었으며 매개 변수 'E'에 형식화된 제네릭 클래스였습니다. 그러나 형식화된(serialization) 및 형식화되지 않은(JSON) 시나리오 모두에 사용되었으며, 이는 SDK의 나머지 부분에 사용된 패턴과 반대입니다. 이제 쿼리 개체의 형식이 형식화된 사례의 ExecutableQueryE&lt;&gt;이고 형식화되지 않은 경우 ExecutableJsonQuery입니다. 쿼리 개체를 변수에 저장하지 않으면 코드를 업데이트할 필요가 없습니다. SDK의 기존(1.1.6) 버전에서 작동하는 아래 코드를 사용합니다.

  <pre class="prettyprint">public class QueryChangesDemo {
      private MobileServiceTable&lt;TodoItem&gt; typedTable;
      private TableQueryCallback&lt;TodoItem&gt; typedCallback;
      private MobileServiceJsonTable jsonTable;

      public QueryChangesDemo(MobileServiceClient client) {
          typedTable = client.getTable(TodoItem.class);
          jsonTable = client.getTable("TodoItem");
          typedCallback = typedCallback = new TableQueryCallback&lt;TodoItem&gt;() {
              @Override
              public void onCompleted(List&lt;TodoItem&gt; results, int count, Exception error, ServiceFilterResponse response) {
              }
          };
      }

      public void before() {
          // Not assigning to a query object - no changes needed
          typedTable.where().field("complete").eq(false).execute(typedCallback);

          // The type of 'query' will change
          MobileServiceQuery&lt;TableQueryCallback&lt;Todoitem&gt;&gt; query = typedTable.where().field("complete").eq(false);
          query.execute(typedCallback);

          // The TableJsonQueryCallback.onCompleted will lose the 'count' parameter
          TableJsonQueryCallback jsonCallback = new TableJsonQueryCallback() {
              @Override
              public void onCompleted(JsonElement result, int count, Exception error,
                      ServiceFilterResponse response) {
              }
          };

          // Not assigning to a query object - no changes needed
          jsonTable.where().field("complete").eq(false).execute(jsonCallback);

          // The type of the 'jsonQuery' variable will change
          MobileServiceQuery&lt;TableJsonQueryCallback&gt; jsonQuery = jsonTable.where().field("complete").eq(false);
          jsonQuery.execute(jsonCallback);
      }
  }</pre>

  새 SDK(2.x)에서 실행하기 전에 변수에 쿼리를 할당해야 하는 경우 변수 형식을 변경해야 합니다. 그렇지 않으면 변경이 필요하지 않습니다.

  <pre class="prettyprint">    public void after() {
          // Not assigning to a query object - no changes needed
          typedTable.where().field("complete").eq(false).execute(typedCallback);

          // The type of 'query' changes to ExecutableQuery&lt;TodoItem&gt;
          ExecutableQuery&lt;Todoitem&gt; query = typedTable.where().field("complete").eq(false);
          query.execute(typedCallback);

          // The TableJsonQueryCallback.onCompleted does not have the the 'count' parameter anymore
          TableJsonQueryCallback jsonCallback = new TableJsonQueryCallback() {
              @Override
              public void onCompleted(JsonElement result, Exception error,
                      ServiceFilterResponse response) {
              }
          };

          // Not assigning to a query object - no changes needed
          jsonTable.where().field("complete").eq(false).execute(jsonCallback);

          // The type of the 'jsonQuery' variable will change
          ExecutableJsonQuery jsonQuery = jsonTable.where().field("complete").eq(false);
          jsonQuery.execute(jsonCallback);
      }</pre>
  위의 한 가지 변경 사항: 'count' 매개 변수를 포함하는 데 사용되는 인터페이스의 <code>TableJsonQueryCallback</code> 메서드 <code>onCompleted</code> 이지만 해당 값이 채워지지 않았습니다(사용된 경우 올바르지 않음). 이제 Android API를 관리 코드와 더 잘 맞추기 위해 이 매개 변수를 제거했습니다.

  <h3>서비스 필터</h3>

  앞서 언급했듯이 서비스 필터는 내부 및 고급 시나리오에서 사용되며 콜백 기반에서 미래 기반 정의로 변경했습니다. 따라서 ServiceFilter.handleRequest 및 NextServiceFilterCallback.onNext 메서드는 이제 콜백 매개 변수를 사용하는 대신 ListableFuture를 반환합니다. 이 변경 외에도 해당 동작은 동일합니다. 예를 들어 파이프라인의 다음 필터를 통해 메시지를 전달하는 "ID" 서비스 필터는 다음과 같습니다.

  <pre class="prettyprint">ServiceFilter identityFilter = new ServiceFilter() {
      @Override
      public ListenableFuture&lt;ServiceFilterResponse&gt; handleRequest(
              ServiceFilterRequest request, NextServiceFilterCallback next) {
          return next.onNext(request);
      }
  };</pre>

  앞서 언급했듯이 고급 사용자만 필터를 사용해야 하므로 이 변경에 대해 걱정할 필요가 없습니다.

  <h2>요약</h2>

  SDK에서 받은 피드백을 해결하기 위해 Android SDK에 대한 미래 지원을 추가했습니다. 위에 나열된 몇 가지 주요 변경 내용이 있었기 때문에 광범위하게 릴리스하기 전에 추가 의견 / 제안 / 불만을 해결할 수 있도록 알파 버전에서 SDK를 릴리스하고 있습니다. 이번 주 후반에 추가한 오프라인 지원에 대해 작성하여 Android SDK가 이제 SDK의 관리 및 iOS 버전과 동등합니다. SDK<a title="https://aka.ms/Iajk6q</a>https://aka.ms/Iajk6q" href="https://aka.ms/Iajk6q">를 다운로드하여 사용해 보고 이 게시물이나 <a href="https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile">MSDN 포럼</a>에서 의견으로 보내주세요.
