### YamlMime:Yaml
ms.openlocfilehash: 0ddb60e0dda8d6b8f46265d0d0946c7aae776ae1
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139900078"
Slug: working-with-dates-in-azure-documentdb-4
Title: Azure DocumentDB의 날짜 사용
Summary: 이 게시물에서는 DateTime 속성을 효율적으로 처리하는 두 가지 방법을 소개하지만 날짜와 시간을 효율적으로 처리하는 구현이 많이 있습니다.
Content: "<div style=\"background:#eee;border:1px solid #ccc;padding:5px 10px;\"><strong>2016년 12월 27일 현재 업데이트:</strong> 이제 <a href=\"https://docs.microsoft.com/azure/documentdb/documentdb-working-with-dates\">날짜는 Azure DocumentDB 설명서 문서의 날짜 작업에서 </a>문서화되고 업데이트됩니다.</div>\n\n<p>JSON(<a href=\"www.json.org\" target=\"_blank\">www.json.org</a>)은 사람이 쉽게 읽고 쓸 수 있는 간단한 데이터 교환 형식이지만 머신을 구문 분석하고 생성하기도 쉽습니다. JSON은 <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\" target=\"_blank\">DocumentDB</a>의 핵심입니다. 유선으로 JSON을 전송하고 JSON을 JSON으로 저장하며 전체 JSON 문서에 대한 쿼리를 허용하는 JSON 트리를 인덱싱합니다. 그것은 우리가 제품에 볼트 뭔가, 그것은 서비스의 핵심이다. 따라서 DocumentDB가 기본적으로 JSON과 동일한 데이터 형식을 지원하는 것은 놀라운 일이 아닙니다. 문자열, 숫자, 부울, 배열, 개체 및 Null입니다. <a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/12/1.jpg\"><img alt=\"1\" border=\"0\" height=\"168\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1_thumb.jpg\" style=\"float: none; padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"1\" width=\"480\"></a> .NET 개발자는 익숙한 특정 형식이 누락된 것을 알 수 있습니다. 가장 주목할 만한 것은 아마도 .NET DateTime 형식일 것입니다. 그렇다면 데이터베이스가 이러한 형식을 기본적으로 지원하지 않는&rsquo; 경우 DateTime을 사용하여 어떻게 저장, 검색 및 쿼리할 수 있을까요? 이 게시물 &hellip; 의 목적이므로 계속 읽으십시오. 이 게시물의 목적을 위해 다음 샘플 POCO 개체로 작업한다고 가정&rsquo;해 보겠습니다.</p>\n\n<pre class=\"prettyprint\">\npublic class Order\n{\n    [JsonProperty(PropertyName=&quot;id&quot;)]\n    public string OrderNumber { get; set; }\n    public DateTime OrderDate { get; set; }      \n    public DateTime ShipDate { get; set; }                \n    public double Total { get; set; }\n}</pre>\n\n<p>이는 주문이 .NET에서 어떻게 표현될 수 있는지에 대한 간단한 데모입니다. 주문에는 OrderDate 및 ShipDate라는 두 개의 DateTime 속성이 있습니다. 이 게시물의 목적을 위해 우리는 주로이 두 가지 속성에 초점을 맞출 것입니다. DateTime 개체를 처리하기 위해 DocumentDB SDK에서 사용하는 기본 형식은 ISO 8601 문자열 형식으로 변환하는 것입니다. 따라서 아래 코드 조각과 같이 Order 개체를 DocumentDB에 전달하는 것만 수행하면</p>\n\n<pre class=\"prettyprint\">\nvar doc1 = client.CreateDocumentAsync(colLink, new Order { \n      OrderNumber = &quot;09152014101&quot;,\n      OrderDate = DateTime.UtcNow.AddDays(-30),\n      ShipDate = DateTime.UtcNow.AddDays(-14), \n      Total = 113.39\n});</pre>\n\n<p>두 .NET DateTime 속성은 다음과 유사한 문자열로 저장됩니다.</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: &quot;2014-09-15T23:14:25.7251173Z&quot;,\n    &quot;ShipDate&quot;: &quot;2014-09-30T23:14:25.7251173Z&quot;\n}</pre>\n\n<p>이 문자열은 멋지고 읽을 수 있는 것처럼 보이지만, 왜 이것이 문제인가요? DocumentDB는 범위 쿼리(예: 필드 10 및 &lt; 필드 20)를 수행할 수 있도록 숫자 필드에 &gt; 대한 범위 기반 인덱스를 지원합니다. 날짜에 대한 범위 쿼리(어제보다 오래된 레코드 또는 지난 주에 주문 또는 오늘 배송된 주문)를 수행할 때 비용이 많이 드는 검색을 수행하지 않도록 하려면 날짜의 문자열 표현을 숫자로 변환하여 이러한 필드에서 범위 인덱스를 사용할 수 있도록 해야 합니다. DocumentDB 및 JSON은 DateTimes를 나타내는 방법에 중립적이며 이 중립을 사용하여 애플리케이션&rsquo; 요구 사항에 가장 적합한 강력한 효과를 낼 수 있습니다. 이 게시물에서는 DateTime 속성을 효율적으로 처리하는 두 가지 방법을 소개하지만 날짜와 시간을 효율적으로 처리하는 구현이 많이 있습니다. &nbsp; 나머지 게시물의 경우 DateTimes를 Epoch 값 또는 특정 날짜 이후의 시간(초)으로 처리합니다. 이 게시물에서는 1970년 1월 1일 00:00을 사용하고 있으며, 데이터에 따라 원하는 경우 다른 시작점을 사용할 수 있습니다. 즉, 주문을 수행하고 시스템에서 오늘부터 주문을 처리해야 하는 경우 오늘을 시작점으로 선택합니다. 우리의 가상의 시스템은 역사적 질서를 많이 가지고, 그래서 우리는 시간을 조금 거슬러 올라가야합니다. 다음은 이 변환을 수행하는 DateTime에 대한 간단한 .NET 확장 메서드입니다.</p>\n\n<pre class=\"prettyprint\">\npublic static class Extensions\n{\n    public static int ToEpoch(this DateTime date)\n    {\n        if (date == null) return int.MinValue;\n        DateTime epoch = new DateTime(1970, 1, 1);\n        TimeSpan epochTimeSpan = date - epoch;\n        return (int)epochTimeSpan.TotalSeconds;\n    }\n}</pre>\n\n<p>이제 애플리케이션에서 어떻게 사용하나요? 계속 진행하는 방법에는 두 가지가 있으며 애플리케이션의 요구 사항에 가장 적합한 방법을 선택할 수 있습니다. 첫 번째 방법은 DateTime 자체가 <b>아닌</b> DateTime을 나타내는 숫자 필드를 저장하는 것입니다. 이 작업을 수행하는 가장 쉬운 방법은 JSON을 처리하기 위한 사용자 지정 직렬 변환기 &amp; 역직렬 변환기를 구현하는 것입니다. DateTime&rsquo; 속성의 기본 동작을 변경하는 고객 JsonConverter를 구현하여 JSON.NET 이 작업을 수행하는 방법을 보여 하겠습니다. 이를 위해 JsonConverter 추상 클래스를 확장하고 ReadJson 및 WriteJson 메서드를 재정의하는 클래스를 정의합니다.</p>\n\n<pre class=\"prettyprint\">\npublic class EpochDateTimeConverter : JsonConverter\n{\n    ...\n}</pre>\n\n<p>다음은 .NET DateTime을&nbsp; 사용하고&nbsp; 위에서 만든 동일한 ToEpoch() 확장 메서드를 사용하여 숫자를 출력하는 WriteJson 구현입니다.</p>\n\n<pre class=\"prettyprint\">\npublic override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)\n{\n    int seconds;\n    if (value is DateTime)\n    {\n        DateTime dt = (DateTime)value;\n        if (!dt.Equals(DateTime.MinValue))\n            seconds = dt.ToEpoch();\n        else\n            seconds = int.MinValue;\n    }\n    else\n    {\n        throw new Exception(&quot;Expected date object value.&quot;);\n    }\n\n    writer.WriteValue(seconds);\n}</pre>\n\n<p>JSON에서 .NET으로 다시 serialization하는 동안 사용되는 역방향 ReadJson 메서드도 있습니다. 이 메서드는 1970년 1월 1일 UTC 이후의 시간(초)을 나타내는 숫자를 사용하고 해당하는 .NET DateTime을 반환합니다.</p>\n\n<pre class=\"prettyprint\">\npublic override object ReadJson(JsonReader reader, Type type, object value, JsonSerializer serializer)\n{\n    if (reader.TokenType == JsonToken.None || reader.TokenType == JsonToken.Null) \n        return null;\n\n    if (reader.TokenType != JsonToken.Integer)\n    {\n        throw new Exception(\n            String.Format(&quot;Unexpected token parsing date. Expected Integer, got {0}.&quot;,\n            reader.TokenType));\n    }\n\n    int seconds = (int)reader.Value;\n    return new DateTime(1970, 1, 1).AddSeconds(seconds);\n}</pre>\n\n<p>애플리케이션에서 이를 사용하려면 DateTime 속성을 JsonConverter 특성으로 데코레이트해야 합니다. 이제 이러한 속성이 직렬화/역직렬화되면 Json.NET 기본값으로 작동하지 않고 사용자 지정 코드를 대신 사용하는 것을 알 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n    public class Order\n    {\n        [JsonProperty(PropertyName=&quot;id&quot;)]\n        public string OrderNumber { get; set; }\n\n        [JsonConverter(typeof(EpochDateTimeConverter))]\n        public DateTime OrderDate { get; set; }\n\n        [JsonConverter(typeof(EpochDateTimeConverter))]\n        public DateTime ShipDate { get; set; }\n\n        public double Total { get; set; }\n    }</pre>\n\n<p>serialization 후의 결과는 이제 JSON의 숫자이며 DocumentDB에 저장되는 숫자입니다.</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: 1408318702,\n    &quot;ShipDate&quot;: 1408318702 \n}</pre>\n\n<p>DocumentDB의 숫자 필드에서 효율적인 범위 쿼리를 수행하려면 DocumentCollection을 만들 때 숫자 필드가 포함된 경로에 범위 인덱스를 정의해야 합니다. 아래 예제에서는 사용자 지정 IndexPolicy를 사용하여 DocumentCollection을 만드는 방법을 보여줍니다. 이 범위 인덱스에는 7바이트의 숫자 정밀도를 사용합니다. 수십억 개의 숫자를 처리하고 있기 때문입니다. 더 작은 범위의 숫자의 경우 더 작은 정밀도 수준을 사용하기에 충분합니다.</p>\n\n<pre class=\"prettyprint\">\nvar collection = new DocumentCollection\n{\n    Id = id\n};\n\n//set the default IncludePath to set all properties in the document to have a Hash index\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Hash,\n    Path = &quot;/&quot;,\n});\n\n//now define two additional paths in Order that we know we want to do Range based queries on\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;OrderDate\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;ShipDate\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection = client.CreateDocumentCollectionAsync(dbLink, collection).Result;</pre>\n\n<p>이 설정이 완료되면 DateTime 속성에 대한 쿼리를 수행하는 것은 다음과 같이 쉽습니다.</p>\n\n<pre class=\"prettyprint\">\n//convert &quot;7 days ago&quot; to epoch number using our ToEpoch extension method for DateTime\nint epocDateTime DateTime.UtcNow.AddDays(-7).ToEpoch();\n\n//build up the query string\nstring sql = string.Format(&quot;SELECT * FROM Collection c WHERE c.OrderDate &gt; {0}&quot;, epocDateTime);\n\n//execute the query and get the results in a List\nvar orders = client.CreateDocumentQuery&lt;Order&gt;(col.SelfLink, sql).ToList();</pre>\n\n<p>즉&rsquo;, 하나의 접근 방식을, 그것은 매우 효율적으로 작동합니다. 그러나 단점은 사용자가 읽을 수 있는 날짜 문자열이 데이터베이스에서 손실된다는 것입니다. 다른 애플리케이션이 데이터베이스에 연결하면 사용자 지정 역직렬 변환기가 반드시 실행되지 않으며&rsquo; 반환된 값은 이제 처리하기가 어렵습니다. 많은 사람이 머리 속에서 Epoch 변환을 수행할 수 없기 때문입니다(확실히 가능&rsquo;). 이를 구현하는 두 번째 방법은 읽을 수 있는 DateTime 필드를 유지하지만 문자열 표현 외에도 DateTime의 숫자 표현을 저장하는 추가 필드를 문서에 추가하는 것입니다. 이렇게 하려면 다음과 같은 새 사용자 지정 형식을 만들 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\npublic class DateEpoch\n{\n   public DateTime Date { get; set; }\n   public int Epoch\n   {\n       get\n       {\n           return (this.Date.Equals(null) || this.Date.Equals(DateTime.MinValue))\n               ? int.MinValue\n               : this.Date.ToEpoch();\n        }\n    }\n}</pre>\n\n<p>이제 Order 개체의 두 DateTime 속성을 다음과 같이 새 형식으로 변경합니다.</p>\n\n<pre class=\"prettyprint\">\npublic class Order\n{\n    [JsonProperty(PropertyName = &quot;id&quot;)]\n    public string OrderNumber { get; set; }\n\n    public DateEpoch OrderDate { get; set; }\n\n    public DateEpoch ShipDate { get; set; }\n\n    public double Total { get; set; }\n}</pre>\n\n<p>이제 개체를 DocumentDB에 전달하면 다음과 같은 JSON이 발생합니다.</p>\n\n<pre class=\"prettyprint\">\n{\n    &quot;OrderDate&quot;: {\n        &quot;Date&quot;: &quot;2014-09-15T23: 14: 25.7251173Z&quot;,\n        &quot;Epoch&quot;: 1408318702\n    },\n    &quot;ShipDate&quot;: {\n        &quot;Date&quot;: &quot;2014-09-30T23: 14: 25.7251173Z&quot;,\n        &quot;Epoch&quot;: 1408318702\n    }\n}</pre>\n\n<p>첫 번째 기술에서 그랬던 것처럼 이번에는 Epoch 값에만 범위 경로를 추가하는 것을 제외하고 DocumentCollection에서 사용자 지정 IndexPolicy를 정의해야 합니다. 원하는 경우 인덱스에서 날짜 문자열 경로를 제외할 수 있지만 기본 해시 인덱스를 유지하면 같음 작업을 수행할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\nvar collection = new DocumentCollection\n{\n    Id = id\n};\n\n//set the default IncludePath to set all properties in the document to have a Hash index\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Hash,\n    Path = &quot;/&quot;,\n});\n\n//now define two additional paths in Order2 that we know we want to do Range based queries on\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;OrderDate\\&quot;/\\&quot;Epoch\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\ncollection.IndexingPolicy.IncludedPaths.Add(new IndexingPath\n{\n    IndexType = IndexType.Range,\n    Path = &quot;/\\&quot;ShipDate\\&quot;/\\&quot;Epoch\\&quot;/?&quot;,\n    NumericPrecision = 7\n});\n\n//could also exclude the Date portion of the dates in Order2 as we&#39;re never going to \n//index on these, but will leave these there because they&#39;re still indexed with a hash \n//so you could do equality operations on them.\n\ncollection = client.CreateDocumentCollectionAsync(dbLink, collection).Result;</pre>\n\n<p>이제 이 방법을 사용하여 쿼리하기 위해 다음 LINQ 쿼리를 실행할 수 있습니다. 이 방법의 또 다른 장점이므로 이전 예제와 같이 SQL 않고 여기에서 LINQ를 보여 주도록 선택했습니다.</p>\n\n<pre class=\"prettyprint\">\nvar orders = from o in client.CreateDocumentQuery&lt;Order2&gt;(col.SelfLink)\n    where o.OrderDate.Epoch &gt;= DateTime.Now.AddDays(-7).ToEpoch()\n    select o;</pre>\n\n<p>또는 선호하는 경우 다음 LINQ 람다 구문을 선택할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\nvar orders2 = client.CreateDocumentQuery&lt;Order2&gt;(col.SelfLink)\n    .Where(o =&gt; o.OrderDate.Epoch &gt;= DateTime.UtcNow.AddDays(-7).ToEpoch())\n    .ToList();</pre>\n\n<p>그리고 물론 앞에서 사용한 SQL 구문도 유효하고 동일한 결과를 제공하며 LINQ를 사용할 수 없을 때 사용하는 구문입니다.</p>\n\n<pre class=\"prettyprint\">\nstring sql = String.Format(&quot;SELECT * FROM c WHERE c.OrderDate.Epoch &gt;= {0}&quot;, \n                 DateTime.UtcNow.AddDays(-7).ToEpoch());</pre>\n\n<p>이 두 번째 방법은 첫 번째 방법보다 두 가지 주요 장점이 있습니다. 먼저 JSON.NET 같은 특정 도구에 대한 사용자 지정 serialization 기술을 사용하지 않으므로 다른 JSON 직렬 변환기 또는 .NET 옆에 있는 다른 언어와 함께 사용할 수 있습니다. 이 기술은 Node.JS 또는 Python에서 동일하게 잘 작동합니다. 둘째, 다른 애플리케이션이 데이터를 쿼리하는 경우 사람이 읽을 수 있는 DateTime 값을 문자열로 유지하기 때문에 사용자는 여전히 읽을 수 있는 날짜 버전을 갖게 됩니다. 이 방법을 사용하려면 더 많은 스토리지가 필요하고 결과적으로 문서가 약간 더 커지지만 스토리지 비용이나 문서의 크기가 너무 크지 않은 경우 위에 나열된 이점에 대해 첫 번째 방법보다 이 방법을 사용하는 것이 좋습니다. DocumentDB&rsquo;의 DateTime 속성입니다. 완료 이 블로그 게시물에 대한 샘플 코드를 원하는 경우 <a href=\"https://ryancrawcour.blob.core.windows.net/samples/DateTime%20and%20DocumentDB.zip\" target=\"_blank\">여기에서</a> 다운로드할 수 있습니다. Azure <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\" target=\"_blank\">DocumentDB</a>를 시작하려면 azure.com&nbsp;https://azure.microsoft.com/en-us/documentation/services/documentdb/&gt; =\">https://azure.microsoft.com/en-us/documentation/services/documentdb/<a href=\"https://azure.microsoft.com/en-us/documentation/services/documentdb/\" title=\"</a> 서비스 설명서 페이지로 이동하여 실행하기 위해 &amp; 필요한 모든 것을 찾을 수 있습니다.</p>"
