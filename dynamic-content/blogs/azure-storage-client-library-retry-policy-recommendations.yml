### YamlMime:Yaml
ms.openlocfilehash: a962ebaaf9fb12d2d5cc1fc35f17e9a38e1d932a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139899885"
Slug: azure-storage-client-library-retry-policy-recommendations
Title: Azure Storage 클라이언트 라이브러리 다시 시도 정책 권장 사항
Summary: Azure Storage 클라이언트 라이브러리 재시도 정책 설정을 선택하는 방법에 대한 지침입니다.
Content: >-
  Azure Storage 라이브러리 재시도 정책을 구성하는 <strong><em>방법에</em></strong> 대한 자세한 내용은 <a href="https://gauravmantri.com/2012/12/30/storage-client-library-2-0-implementing-retry-policies/">SCL 2.0 –</a> Gaurav Mantri에 의한 재시도 정책 구현이 우수합니다. 그러나 <strong><em>사용할 재시</em></strong> 도 정책 설정에 대한 실질적인 지침을 원한다면 찾기가 더 어렵습니다. 이 게시물은 부하가 높은 시나리오에서 SCL을 사용하는 한 Microsoft 팀의 실제 경험을 기반으로 몇 가지 권장 사항을 제공합니다(트래픽이 적은 시나리오의 경우 기본 재시도 정책은 괜찮습니다).

  <h2>ExponentialRetry와 LinearRetry 비교</h2>

  응답 시간을 짧게 유지하는 것에 대해 걱정하지 않는 일괄 처리 프로세스의 경우 ExponentialRetry 클래스는 처음에는 쉬운 호출처럼 들립니다. 일시적 오류를 최대한 빨리 지우려고 하지만 서버를 망치고 싶지 않아서 이미 아픈 서비스에 더 많은 문제가 발생하는지 확인하기 위해 신속하게 다시 시도하려고 합니다. 그리고 Azure Storage 팀은 더 지능적이고 최상의 전반적인 성능을 제공하기 위해 정책을 계속 조정하고 있습니다.


  그러나 Storage 서비스에 대한 연결의 품질을 추적하는 기능에 미치는 영향을 고려합니다. 시간이 오래 걸리고 재시도가 많은 ExponentialRetry를 사용하는 경우 대부분의 일시적인 오류에 대한 예외를 처리하지 않아도 되지만 자주 발생하는지 알 수 없습니다. 응답 시간을 추적할 수 있지만 원인이 일시적인 오류인지는 알 수 없습니다.


  한 가지 솔루션은 클라이언트 라이브러리에서 실행된 모든 작업에 대한 결과를 포함하는 OperationContext.RequestResults를 사용하는 것입니다. OperationContext는 분산 시스템의 문제를 진단하는 데 유용할 수 있는 엔드투엔드 추적도 제공합니다. 재시도에 대한 알림을 받고 싶다면 OperationContext.Retrying이라는 새 이벤트를 사용할 수 있습니다. 아쉽게도 OperationContext를 사용하는 방법의 예를 보여 주는 설명서는 없습니다.


  더 많은 진단 정보를 원하는 경우 또 다른 옵션은 비교적 짧은 재시도 간격과 몇 번의 재시도만으로 LinearRetry 클래스를 사용하여 상당히 빠르게 실패하도록 하는 것입니다. 그런 다음, 오류를 보고하는 동안 예외를 catch하고 고유한 백오프를 구현할 수 있습니다. 대부분의 요청이 결국 성공하려면 백오프가 정말 중요합니다.

  <h2>MaximumExecutionTime</h2>

  IRequestOptions 인터페이스에는 MaximumExecutionTime 속성도 포함됩니다. 이 값은 모든 재시도에 소요될 수 있는 총 시간을 제한합니다. 이 작업을 수행하는 작업의 유형에 따라 큰 작업이 실패하는 데 시간이 걸릴 수 있으므로 매우 커야 할 수 있습니다. 큰 작업에 대한 요청이 있는 높은 부하 조건에서 10초 미만의 값으로 인해 많은 오류가 발생한 것으로 나타났습니다. MaximumExecutionTime을 60초로 설정하면 예외가 발생하지 않습니다. 이는 백그라운드 프로세스에 적합합니다. 고객 관련 시나리오의 경우 다르게 조정해야 합니다.


  ServerTimeout과 최대 재시도 횟수가 덜 영향을 미치는 것으로 나타났습니다. 우리는 5 초와 10 번의 재시도로 설정했고 잘 작동했습니다. 다시 말하지만, 이는 빠른 응답 시간보다 최종 성공에 더 관심이 있는 백그라운드 프로세스를 위한 것입니다. 또한 애플리케이션이 1TB Blob을 다운로드하는 경우(예: 5초가 충분하지 않은 경우) 모든 시나리오에서 작동하지 않습니다. 시간 제한을 원하지 않는 또 다른 옵션은 ServerTimeout을 null로 설정하는 것입니다. StorageClient 라이브러리 4.0부터 null이 기본값이 됩니다.

  <h2>불필요한 작업 방지</h2>

  일부 작업의 경우 SCL API는 예외를 방지하는 데 사용할 수 있는 IfExists 메서드를 제공합니다. 예제:

  <pre class="prettyprint">foreach (IListBlobItem blobItem in this.BlobList())

  {
      CloudBlockBlob cloudBlob = (CloudBlockBlob)blobItem;
      cloudBlob.DeleteIfExists(options: this.requestOptions);
  }</pre>

  이것은 좋은 방어 프로그래밍처럼 보이지만 실패하고 트래픽을 추가 할 수있는 추가 기회이기도합니다.우리의 스트레스 테스트에서 그것은 자주 실패. 그리고 항목이 존재한다는 것을 알고 있다면 불필요합니다. <a href="https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.blob.cloudblockblob.deleteifexists(v=azure.10).aspx">DeleteIfExists</a> 대신 <a href="https://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.blob.cloudblockblob.delete(v=azure.10).aspx">Delete</a>를 호출하도록 코드를 변경하면 작업이 훨씬 더 잘 수행되고 실패 빈도가 줄어듭니다. 따라서 알려진 정보를 사용하여 트래픽을 줄이고 실패할 가능성을 줄이는 것이 가장 좋습니다.

  <h2>예외 처리</h2>

  관대한 재시도 정책을 사용하더라도 예외를 얻을 수 있을 만큼 오류가 오래 지속되는 경우가 있습니다. Azure Storage 클라이언트 프레임워크는 이러한 프레임워크가 StorageException 또는 시스템인지 확인하는 데 적합합니다.<a href="https://msdn.microsoft.com/en-us/library/system.aggregateexception(v=vs.110).aspx"> AggregateException</a>.


  또한 재시도 정책 클래스는 4xx 상태 코드에서 다시 시도하지 않습니다. 몇 가지 다른 항목도 있습니다(현재 306, 501 및 505). 이러한 코드는 일시적이지 않고 처리해야 하는 상황을 나타냅니다. 일반적인 예는 404(찾을 수 없음) 및 409(충돌)입니다. 사용자 지정 재시도 정책을 작성하는 경우 이러한 상황을 확인해야 합니다.

  <h2>래퍼 라이브러리 불필요</h2>

  Azure Storage 클라이언트에서 원하는 방식으로 다시 시도한 래퍼 라이브러리를 디자인하려는 경험을 시작했습니다. 결국 불필요한 것으로 밝혀졌습니다. 재시도 튜닝 및 오류 처리를 중앙 집중화하기 위해 비즈니스 논리용 라이브러리를 작성하려고 하지만 Azure Storage 클라이언트 코드를 기반으로 합니다.


  &nbsp;


  테스트를 수행하고이 게시물에 대한 콘텐츠를 제공 앨런 프레스콧 덕분에.
