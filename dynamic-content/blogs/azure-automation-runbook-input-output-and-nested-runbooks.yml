### YamlMime:Yaml
ms.openlocfilehash: fffc02c0e657387d4f531a2277b9a68b46d803b6
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911392"
Slug: azure-automation-runbook-input-output-and-nested-runbooks
Title: 'Azure Automation: Runbook 입력, 출력 및 중첩된 Runbook'
Summary: 이 게시물에서는 Azure Automation에서 고품질 Runbook을 만들기 위한 몇 가지 기본 개념을 다룹니다.  이 게시물에서 다루는 개념은 입력 매개 변수 정의, 출력 형식 정의 및 Runbook 내에서 자식 Runbook을 호출하는 방법입니다.
Content: "<a href=\"https://azure.microsoft.com/\" target=\"_blank\">Microsoft Azure</a>, Dev/Ops 및 IT 전문가의 새로운 기능인 <a href=\"https://azure.microsoft.com/en-us/services/automation/\" target=\"_blank\">Azure Automation</a>을 사용하면 Runbook을 만들고 실행하여 Azure 리소스에 대한 반복적이고 복잡한 작업을 자동화할 수 있습니다.Azure Automation은 PowerShell 워크플로 엔진을 사용하여 Runbook을 실행합니다. 즉, Runbook은 PowerShell 워크플로로 만들어집니다(소개는 <a href=\"https://technet.microsoft.com/en-us/library/dn469257.aspx\" target=\"_blank\">Runbook 개념</a> 문서 참조).\n\nAzure Automation Runbook을 만들 때 시스템을 최대한 활용하기 위해 모범 사례를 인식하고 따르는 것이 좋습니다.Runbook을 만들면 PowerShell, PowerShell 워크플로 및 Azure Automation에 대한 지식이 포함됩니다.하루가 끝나면 PowerShell에 익숙한 경우 Azure Automation Runbook을 만드는 것은 간단합니다.\n\n이 게시물에서는 고품질 Runbook을 만드는 데 도움이 되는 몇 가지 기본 개념을 다룹니다.이 시리즈의 다른 게시물은 Runbook 만들기 및 관리의 다른 유용한 측면을 다룹니다.이 게시물에서 다루는 개념은 다음과 같습니다.\n<ul>\n <li>입력 매개 변수 정의</li>\n <li>출력 형식 정의</li>\n <li>Runbook 내에서 자식 Runbook 호출</li>\n</ul>\n&nbsp;\n<h2>입력 매개 변수 정의</h2>\n대부분의 Runbook은 실행 전에 일부 입력 데이터를 제공해야 합니다.따라서 Runbook을 작성하는 동안 필요한 입력 매개 변수를 정의하는 것이 일반적입니다.입력 매개 변수를 정의하는 주요 특성은 다음과 같습니다.\n<ul>\n <li>Name</li>\n <li>형식(.Net 형식)</li>\n <li>필수(또는 아님)</li>\n <li>기본값(있는 경우)</li>\n</ul>\n&nbsp;\n\nAzure Automation은 Runbook에 대한 입력 매개 변수의 이러한 특성을 지원합니다.PowerShell은 유효성 검사, 별칭 및 매개 변수 집합과 같은 입력 매개 변수의 더 많은 특성을 지원합니다. 그러나 Azure Automation은 현재 위의 목록만 지원합니다.\n\n아래 코드 조각은 Runbook에 정의된 매개 변수를 보여줍니다.(자세한 내용은 <a href=\"https://gallery.technet.microsoft.com/scriptcenter/site/search?f%5b0%5d.Type=User&amp;f%5b0%5d.Value=SC%20Automation%20Product%20Team&amp;f%5b0%5d.Text=SC%20Automation%20Product%20Team&amp;f%5b1%5d.Type=RootCategory&amp;f%5b1%5d.Value=WindowsAzure&amp;f%5b1%5d.Text=Windows%20Azure\" target=\"_blank\">ScriptCenter의 Automation 갤러리</a>에서 사용할 수 있는 <a href=\"https://gallery.technet.microsoft.com/scriptcenter/How-to-use-runbook-8ddee029\" target=\"_blank\">Use-RunbookParameterSample Runbook</a>을 참조하세요.)\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Add-User\n{\n    param (\n        [Parameter(Mandatory=$true)]\n        [PSCredential] \n        $Credential,\n\n        [Parameter(Mandatory=$true)]\n        [object] \n        $FullName,\n\n        [Parameter(Mandatory=$true)]\n        [string] \n        $Alias,\n\n        [Parameter(Mandatory=$false)]\n        [string]\n        $Company=\"Contoso\",\n\n        [Parameter(Mandatory=$false)]\n        [boolean]\n        $HasAdminRights = $false            \n    )\n    # Do work to add the user to the system...\n}</pre>\n&nbsp;\n\nRunbook 내에서 Runbook 인라인을 호출하려는 경우 입력 매개 변수에 대해 다음 사항에 유의하세요.\n<ul>\n <li>입력 매개 변수가 단순 형식이거나 복합 개체(예: [PSCredential])인 경우 필요에 따라 단순 형식 값 또는 복합 개체를 입력 값으로 직접 전달할 수 있습니다.</li>\n <li>개체 속성에 대한 name=value 쌍을 사용하여 [object] 형식을 PowerShell 해시 테이블로 전달할 수 있습니다.아래 예제에서는 \"FullName\" 매개 변수가 해시 테이블로 전달됩니다.</li>\n</ul>\n&nbsp;\n<pre class=\"prettyprint\">    $name = @{\"FirstName\"=\"Joe\";\"MiddleName\"=\"Bob\";\"LastName\"=\"Smith\"}\n    Add-User -FullName $name -Alias \"jsmith\" -HasAdminRights $true -Credential $cred</pre>\n&nbsp;\n\n경우에 따라 [switch] 매개 변수 형식은 Azure Automation Runbook에서 유용할 수 있습니다. 그러나 일반적으로 [boolean] 형식을 사용하는 것이 더 예측 가능합니다.하나 또는 다른 하나를 사용하는 이유는 <a href=\"https://www.powershellmagazine.com/2013/12/20/using-powershell-switch-vs-boolean-parameters-in-sma-runbooks/\" target=\"_blank\">이 블로그 게시물에</a> 설명되어 있습니다.PowerShell 워크플로에서 사용하는 것이 덜 복잡하기 때문에 [switch]가 아닌 [boolean]을 사용하는 것이 <strong>좋습니다</strong> .\n\nPowerShell 워크플로에서 활동 또는 다른 워크플로(Runbook)를 호출할 때 모든 매개 변수는 위치가 아닌 이름으로 참조되어야 합니다.안전하려면 워크플로에서 다른 Runbook, 활동 또는 cmdlet을 호출할 때 항상 명명된 매개 변수를 사용하는 것이 좋습니다.\n\n<strong>모범 사례:</strong>  Runbook에 입력 매개 변수를 선언할 때는 매우 명시적이어야 합니다.위의 Add-User 예제를 가이드로 사용하고 항상 매개 변수 형식, 이름 및 필수인지 여부를 포함합니다.매개 변수의 기본값을 설정하는 경우 필수 특성을 설정하는 방법에 관계없이 PowerShell에서 선택적 매개 변수로 간주됩니다.필수 특성을 제외하면 기본적으로 매개 변수는 선택 사항입니다. 그러나 이를 명시적으로 선언하는 것이 항상 가장 좋습니다.매개 변수 이름을 지정할 때 문자, 숫자 및 밑줄 문자를 사용합니다(하이픈이 있는 매개 변수 이름은 피하려는 특수 처리가 필요하므로 하이픈 문자를 사용하지 마세요).\n\nRunbook 시작 마법사 UI를 사용하여 Azure Automation 포털에서 Runbook을 시작할 수 있게 하려면 입력 매개 변수에 대해 다음 사항을 염두에 두세요.\n<ul>\n <li>마법사 UI를 사용하면 숫자, 문자열, 날짜/시간, 스위치, 부울, Azure Automation 자격 증명 자산 이름, JSON 배열 또는 JSON 개체로 나타낼 수 있는 Runbook 매개 변수에 대한 값을 입력할 수 있습니다.</li>\n <li>Runbook에 기본값이 있는 매개 변수가 있는 경우 이 기본값은 UI에 표시됩니다. 이 값을 사용하거나 변경할 수 있습니다.</li>\n <li>Runbook 매개 변수가 [array] 또는 [object] 형식을 사용하는 경우 Runbook 시작 대화 상자에서 <a href=\"https://en.wikipedia.org/wiki/JSON\" target=\"_blank\">JSON 형식</a> 으로 전달되어야 합니다.예를 들면 다음과 같습니다.</li>\n</ul>\n<ul>\n <li>속성 모음을 예상하는 [object] 형식의 매개 변수는 다음과 같이 형식이 지정된 JSON 문자열을 사용하여 UI에 전달할 수 있습니다. {\"StringParam\":\"Joe\",\"IntParam\":42,\"BoolParam\":true}.</li>\n <li>[array] 형식의 매개 변수는 다음과 같이 형식이 지정된 JSON 문자열을 사용하여 입력할 수 있습니다. [\"Joe\",42,true].</li>\n</ul>\n<ul>\n <li>Runbook 매개 변수가 PSCredential 형식을 사용하는 경우 Azure Automation 자격 증명 자산의 문자열 이름을 전달해야 합니다.백그라운드에서 해당 이름의 Azure Automation 자격 증명 자산이 검색되어 Runbook에 전달됩니다.</li>\n</ul>\n&nbsp;\n\n&nbsp;\n\n<img style=\"float: none;margin-left: auto;margin-right: auto;border-width: 0px\" title=\"Runbook 시작용 UX\" alt=\"UX for Start Runbook\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/UXStartRunbook.png\" width=\"480\" height=\"415\" border=\"0\" />\n\n&nbsp;\n\nPowerShell 콘솔 또는 Runbook 내에서 비동기적으로 Runbook을 시작하려면 Start-AzureAutomationRunbook cmdlet을 사용합니다(이 게시물의 뒷부분에 있는 이 cmdlet에 대한 자세한 내용).입력 매개 변수에 대해 다음 사항에 유의하세요(아래 코드 예제 참조).\n<ul>\n <li>Start-AzureAutomationRunbook 작업에서 시작하는 Runbook에 대한 입력 매개 변수는 키/값 쌍으로 해시 테이블로 전달됩니다. 여기서 키는 매개 변수 이름이고 값은 매개 변수의 값입니다.</li>\n <li>Start-AzureAutomationRunbook 시작하는 Runbook에는 숫자, 문자열, 날짜/시간, 스위치, 부울, Azure Automation 자격 증명 자산 이름, JSON 배열 또는 JSON 개체로 나타낼 수 있는 입력 매개 변수가 있어야 합니다.</li>\n <li>입력 매개 변수가 PSCredential 형식인 경우 Azure Automation 자격 증명 자산의 문자열 이름을 전달해야 합니다.백그라운드에서 해당 이름의 자격 증명 자산이 검색되어 Runbook에 전달됩니다.</li>\n <li>입력 매개 변수가 스위치 형식인 경우 매개 변수를 해시 테이블에 부울 값($true 또는 $false)으로 선언해야 합니다.예를 들어 HasAdminRights가 [switch] 매개 변수인 경우 아래 예제와 같이 선언됩니다.부울 매개 변수인 경우에도 이와 동일한 방식으로 선언됩니다.</li>\n <li>입력 매개 변수가 속성 모음인 경우 호출된 Runbook에서 [object] 형식으로 정의하고 PowerShell 해시 테이블 개체를 입력 값으로 전달합니다.예를 들어 아래의 $name 매개 변수를 참조하세요.</li>\n <li>입력 매개 변수가 복합 개체(예: [System.Diagnostics.Process])인 경우 호출된 Runbook에서 [object] 형식으로 정의하고 복합 개체를 입력 값으로 전달합니다.</li>\n</ul>\n&nbsp;\n<pre class=\"prettyprint\">    $name = @{\"FirstName\"=\"Joe\";\"MiddleName\"=\"Bob\";\"LastName\"=\"Smith\"}\n    $params = @{\"Credential\"=\"MyCred\";\"Alias\"=\"jsmith\";\"FullName\"=$name;\"HasAdminRights\"=$true}\n    $job = Start-AzureAutomationRunbook `\n                -Name \"Add-User\" `\n                -Parameters $params `\n                -AutomationAccountName $account</pre>\n입력 매개 변수에 복합 형식을 할당하는 동안 유의해야 할 점은 Runbook을 다른 Runbook에서 호출할지 여부와 인라인으로 호출할지 아니면 Start-AzureAutomationRunbook을 사용하여 시작할지 여부입니다.인라인으로만 호출되는 경우 Runbook 인라인을 호출할 때 복합 형식을 직접 전달할 수 있으므로 복잡한 형식인 입력 매개 변수를 할당할 수 있습니다.그러나 Runbook이 UI를 통해 수동으로 시작되거나 Start-AzureAutomationRunbook을 사용하여 자식 Runbook으로 시작하는 경우 웹 서비스를 통해 JSON 배열 또는 JSON 해시 테이블만 전달할 수 있으므로 모든 복합 형식의 형식을 [object]로 설정해야 합니다.<strong>Runbook</strong>을 시작하는 방법을 잘 모르는 경우 복합 입력 매개 변수를 [object] 형식으로 정의하는 것이 좋습니다.\n\n&nbsp;\n<h2>출력 형식 정의</h2>\nPowerShell은 <a href=\"https://technet.microsoft.com/en-us/library/hh847785.aspx\" target=\"_blank\">OutputType 특성을</a> 사용하여 함수 및 cmdlet의 출력 형식 정의를 오랫동안 지원해 왔습니다.이 특성은 런타임 중에 영향을 주지 않으며, 대신 도구가 디자인 타임에 cmdlet을 실행하지 않고 출력하는 개체 형식을 학습할 수 있는 방법으로 제공되었습니다.\n\nOutputType은 PowerShell 워크플로에서 사용할 수 있으며 출력이 있는 Runbook에 OutputType을 포함해야 합니다.매개 변수 선언 바로 앞의 Runbook 위쪽에 OutputType 특성을 배치합니다.다음은 Runbook에서 OutputType을 사용하는 예제입니다.\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Get-UserNames\n{\n    [OutputType([string])]\n\n    $names = @()\n    # Do work here to get the names...\n\n    Write-Output $names\n}</pre>\nAzure Automation이 발전하고 Runbook을 만들기 위한 도구 집합이 확장되고 향상됨에 따라 cmdlet 및 Runbook에 OutputType 정의가 포함된 다음 해당 계약을 준수하는 것이 중요합니다.\n\n<strong>모범 사례:</strong>  출력이 있는 cmdlet 및 Runbook에 항상 OutputType을 포함합니다.\n\n&nbsp;\n<h2>Runbook에서 다른 Runbook 호출</h2>\n모든 종류의 코드를 만들 때 가장 좋은 방법 중 하나는 모듈화입니다. 즉, 불연속적인 재사용 가능한 코드 단위를 만드는 것입니다.Azure Automation의 경우 이는 cmdlet 및 Runbook 내에 자체 포함된 작업을 배치한 다음 기능이 필요한 Runbook에서 해당 cmdlet 및 Runbook을 호출하는 것을 의미합니다.따라서 부모 Runbook이 실행 중인 프로세스의 일부로 하나 이상의 자식 Runbook을 호출하는 것이 일반적일 수 있습니다.\n\nAzure Automation에서 자식 Runbook을 호출하는 방법에는 두 가지가 있습니다.\n<ul>\n <li>인라인 호출</li>\n <li>Start-AzureAutomationRunbook cmdlet으로 시작</li>\n</ul>\n&nbsp;\n\n참고로 부모 Runbook에서 호출되는 모든 자식 Runbook에 일반 용어 \"중첩됨\" 또는 \"자식\"을 사용합니다.PowerShell은 동기적으로 시작 및 실행되는 작업에 \"invoke\"라는 용어와 비동기적으로 시작되고 실행되는 작업에 대해 \"start\"라는 용어를 사용합니다. 이 전례를 따르고 동기 및 비동기 자식 Runbook에 대해 각각 \"invoke\" 및 \"start\"라는 용어를 사용합니다.\n\n&nbsp;\n<h3>Runbook 인라인 호출</h3>\n인라인으로 호출되는 Runbook은 부모 Runbook과 동일한 작업에서 실행됩니다.즉, 부모 워크플로는 프로세스의 다음 부분을 계속하기 전에 자식 Runbook이 완료될 때까지 기다립니다(동기식).즉, 자식 Runbook에서 throw된 모든 예외와 자식 Runbook에서 생성된 모든 스트림 출력이 부모 작업과 연결됩니다. 따라서 자식 Runbook 실행 및 출력의 모든 추적은 부모 Runbook과 연결된 작업을 통해 수행됩니다.\n\n인라인으로 호출된 자식 Runbook이 있는 Runbook을 시작하면 실행이 시작되기 전에 자식 Runbook(및 모든 하위 항목)이 부모 Runbook으로 컴파일됩니다.이 컴파일 단계에서 부모 Runbook은 자식 Runbook의 이름에 대해 구문 분석됩니다. 이 구문 분석은 모든 하위 Runbook을 통해 재귀적으로 발생합니다.Runbook의 전체 목록을 가져올 때 이러한 Runbook에 대한 스크립트는 스토리지에서 검색되고 PowerShell 워크플로 엔진에 전달되는 단일 파일로 어셈블됩니다.이러한 이유로 Runbook 작업이 제출될 때 부모 및 하위 Runbook을 이미 게시해야 합니다. 그렇지 않으면 컴파일 중에 예외가 발생합니다.   <strong>현재 게시 순서도 중요합니다. 먼저 자식 Runbook을 게시한 다음 부모를 게시해야 합니다.</strong>  마찬가지로 Azure Automation 작성 페이지에서 부모 Runbook을 테스트할 때 먼저 자식 Runbook을 게시한 다음, 부모를 테스트할 수 있습니다.또 다른 결과는 변수를 사용하여 인라인으로 호출된 자식 Runbook의 이름을 전달할 수 없다는 것입니다. 부모 Runbook 내에서 항상 자식 Runbook의 이름을 명시적으로 지정해야 합니다.\n\n다음은 두 개의 자식 Runbook을 인라인으로 호출하는 Runbook의 예입니다. 한 자식 Runbook은 출력을 반환하고 다른 자식 Runbook은 출력을 반환하지 않습니다.\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Process-VMs\n{\n    param (\n        [Parameter(Mandatory=$true)]\n        [string]\n        $ScaleUnit\n    )\n\n    # Invoke a child runbook that has a return object\n    $vms = Get-VMs -scaleunit $ScaleUnit\n\n    # Invoke a child runbook that has no return object\n    Do-StuffToVMs -vm $vms\n}</pre>\n&nbsp;\n<h3>Start-AzureAutomationRunbook Cmdlet을 사용하여 Runbook 시작</h3>\nStart-AzureAutomationRunbook cmdlet(azure Automation으로 미리 가져온 Azure PowerShell 모듈의 Azure Automation cmdlet 중 하나)을 사용하여 별도의 작업에서 Runbook을 시작할 수 있습니다.Start-AzureAutomationRunbook 사용하여 자식 Runbook을 시작하면 Runbook에 대한 새 작업이 만들어집니다.\n\n자식 Runbook이 이런 식으로 시작되면 부모 Runbook은 계속하기 전에 자식 Runbook이 완료될 때까지 기다리지 않습니다(비동기).이 방법은 부모 Runbook이 프로세스를 스핀오프한 다음 잊어버리려는 경우에 유용합니다.그러나 시스템에서 더 많은 작업을 만드는 데 드는 비용이 들기 때문에 문제 해결이 다소 복잡할 수 있습니다. 자식 Runbook에서 출력을 다시 가져와야 하는 경우에도 더 많이 관련됩니다.\n\n다음은 Start-AzureAutomationRunbook 사용하여 자식 Runbook을 시작하고 작업이 완료되고 출력을 가져올 때까지 기다리는 옵션을 제공하는 <a href=\"https://gallery.technet.microsoft.com/scriptcenter/Start-Azure-Automation-1ac858a9\" target=\"_blank\">Runbook Start-AutomationChildRunbook</a>의 코드입니다. 이 Runbook은 Get-AzureAutomationJob 및 Get-AzureAutomationJobOutput과 같은 다른 Azure Automation cmdlet도 사용합니다.이 유틸리티 Runbook은 자식 Runbook을 시작하려는 경우 Runbook에서 매우 유용할 수 있습니다.자식 Runbook을 시작하고 출력을 다시 가져오는 모든 작업을 캡슐화합니다. <a href=\"https://gallery.technet.microsoft.com/scriptcenter/Start-Azure-Automation-1ac858a9\" target=\"_blank\">스크립트 센터에서 이 도우미 Runbook을 다운로드</a>하고 일반적인 용도로 Azure Automation 계정으로 가져올 수 있습니다.\n\n&nbsp;\n<pre class=\"prettyprint\">workflow Start-AutomationChildRunbook\n{\n    [OutputType([object])]\n\n    param (\n        [Parameter(Mandatory=$true)]\n        [string] \n        $ChildRunbookName,\n\n        [Parameter(Mandatory=$false)]\n        [hashtable] \n        $ChildRunbookInputParams,\n\n        [Parameter(Mandatory=$true)]\n        [PSCredential] \n        $AzureOrgIdCredential,\n\n [Parameter(Mandatory=$true)]\n [string]\n $AzureSubscriptionName\n\n        [Parameter(Mandatory=$true)]\n        [string] \n        $AutomationAccountName,\n\n        [Parameter(Mandatory=$false)]\n        [boolean] \n        $WaitForJobCompletion = $false,\n\n        [Parameter(Mandatory=$false)]\n        [boolean] \n        $ReturnJobOutput = $false,\n\n        [Parameter(Mandatory=$false)]\n        [int] \n        $JobPollingIntervalInSeconds = 10,\n\n        [Parameter(Mandatory=$false)]\n        [int] \n        $JobPollingTimeoutInSeconds = 600\n    )\n\n   # Determine if parameter values are incompatible\n   if(!$WaitForJobCompletion -and $ReturnJobOutput) {\n       $msg = \"The parameters WaitForJobCompletion and ReturnJobOutput must both \"\n       $msg += \"be true if you want job output returned.\"\n       throw ($msg)\n   }\n\n    # Connect to Azure so that this runbook can call the Azure cmdlets\n    Add-AzureAccount -Credential $AzureOrgIdCredential | Write-Verbose\n\n    # Select the Azure subscription we will be working against\n    Select-AzureSubscription -SubscriptionName $AzureSubscriptionName | Write-Verbose\n\n    # Assure not null for this param\n    if ($ChildRunbookInputParams -eq $null) { $ChildRunbookInputParams = @{} }\n\n    # Start the child runbook and get the job returned\n    $job = Start-AzureAutomationRunbook `\n                -Name $ChildRunbookName `\n                -Parameters $ChildRunbookInputParams `\n                -AutomationAccountName $AutomationAccountName `\n                -ErrorAction \"Stop\"\n    \n    # Determine if there is a job and if the job output is wanted or not\n    if ($job -eq $null) {\n        # No job was created, so throw an exception\n        throw (\"No job was created for runbook: $ChildRunbookName.\")\n    }\n    else {\n        # There is a job\n        \n        # Log the started runbook’s job id for tracking\n        Write-Verbose \"Started runbook: $ChildRunbookName. Job Id: $job.Id\"\n        \n        if (-not $WaitForJobCompletion) {\n            # Don't wait for the job to finish, just return the job id\n            Write-Output $job.Id\n        }\n        else {\n            # Monitor the job until finish or timeout limit has been reached\n            $maxDateTimeout = InlineScript{(Get-Date).AddSeconds($using:JobPollingTimeoutInSeconds)}\n            \n            $doLoop = $true\n            \n            while($doLoop) {\n                Start-Sleep -s $JobPollingIntervalInSeconds\n                \n                $job = Get-AzureAutomationJob `\n                    -Id $job.Id `\n                    -AutomationAccountName $AutomationAccountName\n                \n                if ($maxDateTimeout -lt (Get-Date)) {\n                    # timeout limit reached so exception\n                    $msg = \"The job for runbook $ChildRunbookName did not \"\n                    $msg += \"complete within the timeout limit of \"\n                    $msg += \"$JobPollingTimeoutInSeconds seconds, so polling \"\n                    $msg += \"for job completion was halted. The job will \"\n                    $msg += \"continue running, but no job output will be returned.\"\n                    throw ($msg)\n                }\n                \n                $doLoop = (($job.Status -notmatch \"Completed\") `\n                          -and ($job.Status -notmatch \"Failed\") `\n                          -and ($job.Status -notmatch \"Suspended\") `\n                          -and ($job.Status -notmatch \"Stopped\"))\n            }\n            \n            if ($job.Status -match \"Completed\") {\n                if ($ReturnJobOutput) {\n                    # Output\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Output\n                    if ($jobout) {Write-Output $jobout.Text}\n                    \n                    # Error\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Error\n                    if ($jobout) {Write-Error $jobout.Text}\n                    \n                    # Warning\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Warning\n                    if ($jobout) {Write-Warning $jobout.Text}\n                    \n                    # Verbose\n                    $jobout = Get-AzureAutomationJobOutput `\n                                    -Id $job.Id `\n                                    -AutomationAccountName $AutomationAccountName `\n                                    -Stream Verbose\n                    if ($jobout) {Write-Verbose $jobout.Text}\n                }\n                else {\n                    # Return the job id\n                    Write-Output $job.Id\n                }\n            }\n            else {\n                # The job did not complete successfully, so throw an exception\n                $msg = \"The child runbook job did not complete successfully.\"\n                $msg += \"  Job Status: \" + $job.Status + \".\"\n                $msg += \"  Runbook: \" + $ChildRunbookName + \".\"\n                $msg += \"  Job Id: \" + $job.Id + \".\"\n                $msg += \"  Job Exception: \" + $job.Exception\n                throw ($msg)\n            }\n        }\n    }\n}</pre>\n&nbsp;\n\nStart-AzureAutomationRunbook 사용하여 자식 Runbook을 시작할 때 반환 값은 Job 개체입니다.자식 Runbook에서 데이터를 반환하려면 작업을 모니터링하여 작업이 완료되는 시기를 학습한 다음 출력을 추출해야 합니다.위의 Runbook 예제에서는 Get-AzureAutomationJob 및 Get-AzureAutomationJobOutput cmdlet을 사용하여 작업을 모니터링하고 자식 Runbook 작업에서 출력을 검색하는 방법을 확인할 수 있습니다.작업이 예상 시간 내에 완료되지 않는 경우 루프에서 종료를 보장하기 위해 시간 제한 요소가 포함되었습니다.또한 여러 자식 작업을 시작하면 시스템에서 작업이 시작되는 순서를 보장하지 않습니다.\n\n&nbsp;\n<h2>인라인으로 호출된 자식 Runbook과 Start-AzureAutomationRunbook 시작 항목 비교</h2>\n<h3></h3>\n<h3>호출된 인라인</h3>\n<ul>\n <li>Pro\n<ul>\n <li>부모 및 자식 Runbook은 동일한 작업에서 실행되므로 시스템에서 더 적은 수의 작업을 통해 작업을 쉽게 추적할 수 있습니다.</li>\n <li>부모 Runbook은 계속하기 전에 자식 Runbook이 완료되기를 기다리며 부모 Runbook은 자식에서 반환 데이터를 직접 가져올 수 있습니다.</li>\n <li>자식 Runbook 및 자식에서 생성한 스트림 출력에 의해 throw된 예외는 부모 작업과 연결되므로 조사할 작업이 하나뿐이므로 문제 해결을 더 쉽게 수행할 수 있습니다.</li>\n <li>Runbook 입력 매개 변수는 모든 형식일 수 있으며 기본 형식은 복합 형식일 수 있습니다.</li>\n <li>자식 Runbook이 부모와 동일한 작업에서 실행 중이므로 한 작업의 런타임에 대한 요금이 청구됩니다.</li>\n</ul>\n</li>\n <li>Con\n<ul>\n <li>부모 Runbook은 자식 Runbook이 완료되기를 기다려야 하므로 부모 Runbook이 완료되는 전체 시간이 늘어나게 됩니다.</li>\n <li>부모 Runbook에서 변수 또는 매개 변수를 사용하여 인라인 자식 Runbook의 이름을 전달할 수 없습니다.</li>\n <li>부모 Runbook을 게시하기 전에 자식 Runbook을 게시해야 합니다.</li>\n <li>부모 및 자식 Runbook은 동일한 Automation 계정에 있어야 합니다.</li>\n</ul>\n</li>\n</ul>\n&nbsp;\n<h3>Start-AzureAutomationRunbook 시작</h3>\n<ul>\n <li>Pro\n<ul>\n <li>부모 및 자식 Runbook은 서로 다른 작업에서 실행되므로 부모가 병렬로 실행할 수 있는 여러 작업을 스핀오프할 수 있습니다.</li>\n <li>부모 Runbook은 자식 Runbook을 기다리지 않으므로 자식 Runbook이 실행되는 동안 처리를 계속할 수 있습니다.</li>\n <li>부모 Runbook에서 매개 변수 또는 변수를 사용하여 호출할 Runbook의 이름을 전달할 수 있습니다.</li>\n <li>해당 Azure 구독에 대한 Automation 연결 자산이 있는 한 동일한 구독 및 다른 Azure 구독의 다른 Automation 계정에 저장된 Runbook을 시작할 수 있습니다.</li>\n</ul>\n</li>\n <li>Con\n<ul>\n <li>부모 및 자식 Runbook은 다른 작업에서 실행되므로 예외 및 스트림 출력은 별도로 저장되고 별도로 추적되어야 하므로 문제 해결이 더 어려워질 수 있습니다.</li>\n <li>시스템에서 더 많은 작업이 생성되어 작업을 시작하기 전에 큐에서 더 오래 대기할 수 있습니다.</li>\n <li>자식 Runbook 작업에서 반환 데이터를 가져오는 것은 간단하지 않습니다.</li>\n <li>Start-AzureAutomationRunbook Runbook을 시작하고 출력이 완료되기를 기다리는 경우 두 Runbook의 런타임에 대한 요금이 청구됩니다.Start를 사용하는 경우에는 그렇지 않습니다.</li>\n <li>AzureAutomationRunbook을 사용하여 Runbook을 시작한 다음 작업 ID를 즉시 반환합니다.</li>\n <li>Runbook 입력 매개 변수는 웹 서비스를 통해 호출을 통해 발생하는 개체의 JSON 직렬화에서 유지되어야 하므로 기본 형식, 배열 및 개체로 제한됩니다.</li>\n</ul>\n</li>\n</ul>\n&nbsp;\n<h2>요약</h2>\nAzure Automation은 PowerShell 워크플로 엔진의 다양한 유용한 기능을 활용하는 Runbook을 만들 수 있는 유용한 도구입니다.Azure Automation 및 PowerShell 워크플로의 일부 내부 작업과 몇 가지 모범 사례를 이해하면 고품질의 안정적이고 유지 관리 가능한 Runbook을 만들 수 있습니다.\n\n이 게시물에서는 입력 매개 변수 정의, Runbook 출력 정의 및 자식 Runbook 호출에 대한 몇 가지 모범 사례를 설명했습니다.이제 정보를 읽었으므로 예제를 사용하여 Azure Automation에서 몇 가지 간단한 Runbook을 실험하여 Runbook 및 자동화의 기능을 직접 확인할 수 있습니다.Azure 리소스를 더 간단하고 예측 가능하며 안정적으로 관리할 수 있도록 이 새로운 지식을 연습해 주셔서 감사합니다.\n\n아직 Azure Automation 사용자가 아닌가요? <a href=\"https://account.windowsazure.com/PreviewFeatures?fid=automation\" target=\"_blank\">미리 보기에 등록한</a> 다음 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/automation-create-runbook-from-samples/\" target=\"_blank\">시작 가이드</a>를 확인하세요."
