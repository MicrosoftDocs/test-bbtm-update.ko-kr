### YamlMime:Yaml
ms.openlocfilehash: 41cf877a711fcd1070bf6150429765b115a7d702
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139902956"
Slug: managing-on-premises-systems-with-azure-automation
Title: Azure Automation을 사용하여 온-프레미스 시스템 관리
Summary: 'Windows PowerShell 원격 기능 덕분에 Azure Automation은 인프라 수준에서 Azure 리소스를 관리할 뿐만 아니라 VM 내부에 도달하고 명령을 실행할 수 있습니다. '
Content: >-
  <em>[업데이트: 이 블로그는 <a href="https://azure.microsoft.com/en-us/documentation/articles/automation-hybrid-runbook-worker/" target="_blank">Hybrid Runbook Worker </a>기능의 릴리스에 의해 "사용되지 않습니다". 이 기능은 여기에 설명된 기능을 구현하는 일류 방법을 제공합니다. 체크 아웃!]</em>


  Windows PowerShell 원격 기능 덕분에 Azure Automation은 인프라 수준에서 Azure 리소스를 관리할 뿐만 아니라 <a href="https://gallery.technet.microsoft.com/scriptcenter/How-to-Use-a-PowerShell-59b2e28c" target="_blank">VM 내부에 도달하고 명령을 실행할 수 있습니다</a>. 그러나 PowerShell 원격은 항상 실행 가능한 옵션이 아닙니다. 보안상의 이유로 Azure VM의 공용 WinRM 포트를 열 수 없거나 VM이 엄격하게 온-프레미스이므로 Azure Automation에서 연결할 수 없을 수 있습니다. 이러한 상황 중 하나에서 자신을 발견하는 경우, 모든 희망은 손실되지 않습니다!


  Azure 호스팅 VM이 있지만 공용 WinRM 포트를 열 수 없는 첫 번째 경우 솔루션은 간단합니다. <a href="https://azure.microsoft.com/blog/2014/12/18/azure-automation-run-tasks-on-azure-virtual-machines-without-opening-ports/" target="_blank">최근 Microsoft 블로그 게시물</a>은 Azure VM 에이전트의 <a href="https://azure.microsoft.com/blog/2014/04/24/automating-vm-customization-tasks-using-custom-script-extension/" target="_blank">사용자 지정 스크립트 확장을</a> 활용하여 이러한 VM에서 PowerShell 명령을 실행하기 위한 Runbook을 제공합니다.


  이 게시물에서는 VM이 온-프레미스인 두 번째 사례를 처리하는 이 솔루션에 대한 확장을 제공합니다. <a href="https://technet.microsoft.com/en-us/library/dn786406.aspx" target="_blank">Azure 가상 네트워크에 연결된 온-프레미스 네트워크가</a> 있는 경우 솔루션을 통해 Azure Automation에서 온-프레미스 VM을 관리할 수 있습니다. 그리고 그것은 단지 하나의 Runbook으로 그렇게. 하지만 먼저 약간의 설정이 필요합니다...

  <h2>환경 구성</h2>

  Runbook은 Azure 환경에 있는 몇 가지 리소스인 "프록시 VM", Azure Storage 계정 및 Azure Automation 및 프록시 VM에 설치된 인증서(아래 설명된 보안상의 이유로)에 따라 달라집니다.

  <h3>"프록시 VM"</h3>

  "프록시 VM"은 네트워크의 다른 컴퓨터에서 명령을 호출하는 데 사용되는 Azure VM입니다. Azure Automation이 이러한 컴퓨터와 상호 작용하는 메커니즘이므로 "프록시"입니다. 프록시 VM에는 Azure VM 에이전트가 설치되어 있어야 합니다. 이 에이전트는 Azure VM을 만들 때 기본적으로 설치되므로 이러한 컴퓨터가 이미 있을 가능성이 큽니다. 기존 VM에 에이전트를 설치해야 하는 경우 <a href="https://azure.microsoft.com/blog/2014/04/15/vm-agent-and-extensions-part-2/" target="_blank">이</a> 블로그 게시물에서 에이전트를 설치하는 방법을 알아볼 수 있습니다.


  Runbook을 실행하면 지정한 프록시 VM에서 VM 에이전트의 사용자 지정 스크립트 확장을 사용하도록 설정되므로 VM에서 Azure Storage 계정에 저장된 스크립트를 다운로드하고 실행할 수 있습니다. 프록시 VM은 PowerShell 원격을 사용하여 네트워크의 다른 VM과 통신하므로 해당 VM에는 WinRM 포트가 네트워크에 열려 있어야 합니다.


  <strong>프록시 VM을 사용하면 Azure Virtual Network를 온-프레미스 네트워크에 연결할 수 있으므로 온-프레미스 머신을 관리할</strong> 수 있습니다( <a href="https://technet.microsoft.com/en-us/library/dn786406.aspx" target="_blank">자세한 내용은 여기</a>). 이러한 네트워크가 있고 해당 네트워크에 속한 Azure VM을 프록시 VM으로 사용하는 경우 해당 VM은 온-프레미스 머신에서 명령을 실행할 수 있습니다.

  <h3>Azure Storage 계정</h3>

  사용자 지정 스크립트 확장(프록시 VM에서 실행)은 지정된 Azure Storage 계정에서 스크립트를 다운로드하므로 Azure 환경에 스크립트가 있어야 합니다. 확장에서 사용할 특정 컨테이너를 만들거나 Runbook이 기본 컨테이너를 만들고 사용하도록 허용할 수 있습니다.

  <h3>인증서</h3>

  Runbook은 프록시 VM을 등록하여 다른 컴퓨터에서 PowerShell을 실행하므로 이를 위해 사용할 자격 증명을 알아야 합니다. 그러나 이러한 자격 증명이 일반 텍스트로 배치되는 것을 원하지 않으므로 Runbook은 스크립트로 구워지고 Azure Storage(그리고 궁극적으로 프록시 VM에) 전달되기 전에 이를 암호화하는 방법이 필요합니다. 그런 다음 프록시 VM은 런타임에 자격 증명의 암호를 해독해야 합니다. 따라서 Runbook을 사용하려면 Azure Automation 및 프록시 VM에 인증서를 설치해야 합니다.

  <h3></h3>

  <ol>
   <li><strong>인증서를 만듭니다.</strong> 프록시 VM에 설치하려면 .pfx 인증서를 만들어야 합니다. 해당 인증서 또는 해당 .cer 인증서도 Azure Automation에 업로드해야 합니다. 인증서를 만드는 방법에 대한 지침은 <a href="https://msdn.microsoft.com/en-us/library/ff699202.aspx" target="_blank">이</a> 페이지를 참조하세요.</li>
   <li><strong>Azure Automation에 인증서 업로드:</strong> Azure Portal에서 Automation 서비스로 이동하여 Automation 계정을 선택하고 자산 탭을 클릭합니다. 페이지 아래쪽에서 "설정 추가"를 클릭하면 이 마법사가 표시됩니다.
  <img class=" aligncenter" style="float: none;padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px" title="설정 추가 마법사" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/AddSettingWizard.png" alt="Add Setting Wizard" width="480" height="199" border="0" />

  "자격 증명 추가"를 클릭하고 다음과 같이 구성합니다.<img class=" aligncenter" style="float: none;padding-top: 0px;padding-left: 0px;margin-left: auto;padding-right: 0px;margin-right: auto;border-width: 0px" title="입력한 자격 증명 추가 마법사" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/DefineCredentialFilledOut.png" alt="Add Credential Wizard, filled out" width="480" height="304" border="0" />


  마법사의 마지막 페이지에서 인증서 파일을 업로드합니다. 보안상의 이유로 .cer 인증서를 Azure Automation에 업로드해야 합니다(Azure Automation에 필요하지 않은 프라이빗 키가 없기 때문). .cer 또는 .pfx 파일이 작동하지만 .pfx를 업로드하는 경우 Azure Automation에서 내보낼 수 있는 것으로 표시되지 <strong>않아야</strong> 합니다.</li>
   <li><strong>프록시 VM의 인증서 저장소에 인증서를 설치합니다</strong> . .pfx 인증서를 프록시 VM에 복사하고 파일을 두 번 클릭하여 가져오기 프로세스를 시작합니다. 스토어 위치에 대해 "로컬 컴퓨터"를 선택하고 인증서를 개인 저장소(Cert:\LocalMachine\My)에 배치해야 합니다. 여기서 사용자 지정 스크립트 확장에서 실행하는 코드는 필요한 자격 증명의 암호를 해독합니다. 이 위치를 사용하면 중요한 보안 경계가 만들어집니다. 관리자 및 시스템만 이 저장소에 있는 인증서의 프라이빗 키에 액세스할 수 있습니다. 이렇게 하면 권한 없는 사용자가 프록시 VM으로 전송된 후 Runbook에서 사용하는 자격 증명의 암호를 해독할 수 없습니다.</li>
  </ol>

  Congratulations, you are now ready to…

  <h2>Runbook을 실행합니다.</h2>

  이제 필요한 리소스를 사용할 수 있으므로 코드를 실행할 차례입니다. <a href="https://gallery.technet.microsoft.com/scriptcenter/Use-an-Azure-VM-to-manage-f48e5145" target="_blank">스크립트 센터</a> 또는 <a href="https://azure.microsoft.com/blog/2014/10/07/introducing-the-azure-automation-runbook-gallery/" target="_blank">Azure Automation Runbook 갤러리에서 Runbook</a>을 가져옵니다.


  다음은 이 Runbook에 대한 호출 예제입니다.

  <pre class="prettyprint">$Results = Invoke-CommandViaProxy `
          -ProxyVmName VM01 `
          -ProxyServiceName VM01 `
          -ScriptBlock "{ 'Hello, my name is '; `$env:COMPUTERNAME}" `
          -TargetComputers VM02,VM03 `
          -RunAsCredential $NetworkCred `
          -CertificateAssetName "MyProxyVmCert" `
          -AzureOrgIdCredential $OrgCred `
          -AzureSubscriptionName $SubscriptionName `
          -StorageAccountName $StorageAccountName</pre>
  관련 매개 변수에 대한 설명은 다음과 같습니다.

  <ul>
   <li>ProxyVmName, ProxyServiceName 이러한 매개 변수는 Azure VM 에이전트를 설치하고 명령을 실행하려는 컴퓨터와 동일한 네트워크에 있어야 하는 프록시 VM을 식별합니다.</li>
   <li>ScriptBlock 문자열로 지정된 프록시 VM 네트워크의 컴퓨터에서 실행하려는 명령입니다. 이 스크립트 블록을 작성할 때 특수 문자를 제대로 이스케이프해야 합니다(예: "{'$a = Get-Date }"). 이는 Runbook 실행 엔진이 스크립트의 변수 값을 대체하려고 하지 않도록 하는 데 필요합니다.</li>
   <li>TargetComputers 스크립트 블록을 실행해야 하는 컴퓨터의 호스트 이름 목록입니다. 프록시 VM은 PowerShell 원격을 사용하여 지정된 스크립트 블록을 실행하므로 이러한 머신에는 WinRM 포트가 열려 있어야 합니다.</li>
   <li>RunAsCredential PowerShell 자격 증명 개체입니다. 스크립트 블록은 이 자격 증명을 사용하여 대상 컴퓨터에서 실행됩니다.</li>
   <li>CertificateAssetName Runbook은 이 인증서 자산을 사용하여 RunAsCredential의 암호를 암호화합니다. 프록시 VM에서 동일한 인증서의 프라이빗 키를 사용하여 해당 암호를 해독합니다.</li>
   <li>AzureOrgIdCredential A PowerShell 자격 증명 개체는 Runbook에서 Azure에 인증하는 데 사용됩니다.</li>
   <li>AzureSubscriptionName 프록시 VM 및 Azure Storage 계정을 포함하는 Azure 구독의 이름입니다.</li>
   <li>StorageAccountName Runbook에서 생성하는 스크립트 파일을 저장할 Azure Storage 계정의 이름입니다. 이 파일은 Runbook이 완료되면 제거됩니다.</li>
  </ul>

  Runbook의 동작을 추가로 사용자 지정하기 위한 몇 가지 선택적 매개 변수도 있으며, 모두 Runbook 자체에 설명된 기본값이 있습니다.


  Runbook은 기본적으로 스크립트 블록의 출력을 PowerShell 개체로 반환합니다. 스크립트가 여러 컴퓨터에서 실행되는 경우 스크립트가 실행된 각 컴퓨터에 대해 하나씩 개체 배열을 다시 가져옵니다. 여기에는 하나의 작은 "gotcha"가 있습니다. 출력이 사용자 지정 스크립트 확장의 다소 작은 출력 필드를 통해 반환되기 때문에 "큰" 개체가 잘리게 될 수 있습니다(출력 필드는 4096자를 저장할 수 있음). 직렬화된 출력이 해당 길이를 초과할 것으로 예상하는 경우 스크립트 쪽 필터링을 수행하거나 Runbook의 SerializeOutput 매개 변수를 $False 설정하고 원시 텍스트를 다시 가져올 수 있습니다.


  마지막으로 사용자 지정 스크립트 확장은 한 번에 하나의 스크립트만 실행할 수 있습니다. 완료를 기다리지 않고 동일한 프록시 VM에 대해 이 Runbook을 여러 번 호출하는 경우 가장 최근 요청만 실행하거나 가장 먼저 실행 중이던 모든 요청만 실행합니다.

  <h2>결론</h2>

  정말 간단하죠. 이제 Azure Automation을 사용하여 프라이빗 네트워크 또는 온-프레미스에 있는 VM에서 스크립트를 안전하게 실행하는 방법을 알아봅니다. Azure Automation을 사용하는 더 멋진 방법은 <a href="https://azure.microsoft.com/blog/topics/it-pro-devops/">Azure IT Pro/DevOps 범주</a>에서 다른 게시물을 확인하세요.


  Azure Automation을 시작하기만 하면 되었나요? <a href="https://aka.ms/Q2p1ap" target="_blank">여기서</a> 서비스에 대해 알아보고 <a href="https://twitter.com/AzureAutomation" target="_blank">Twitter</a>에서 Azure Automation을 따르세요.


  행복한 자동화!
