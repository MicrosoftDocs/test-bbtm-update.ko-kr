### YamlMime:Yaml
ms.openlocfilehash: f8e073ed5427e45c82fb58cbc94b4252bfd1ff81
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139899794"
Slug: ingesting-a-data-stream-from-nist-manufacturing-lab-data-part-2
Title: NIST 제조 랩 데이터에서 데이터 스트림 수집 - 2부
Summary: 산업 환경 팀은 최근 기존 IoT 데이터에서 인사이트를 추출하기 위한 솔루션 가이드를 게시했습니다. 솔루션은 다음 구성 요소로 구성됩니다.
Content: >-
  <p>산업 환경 팀은 최근 기존 IoT 데이터에서 인사이트를 추출하기 위한 <a href="https://docs.microsoft.com/azure/industry/manufacturing/extracting-insights-from-iot-data?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">솔루션 가이드</a> 를 게시했습니다. 솔루션은 다음 구성 요소로 구성됩니다.</p>


  <ul>
   <li>데이터 수집</li>
   <li>핫 경로 처리</li>
   <li>콜드 경로 처리</li>
   <li>분석 클라이언트</li>
  </ul>


  <p>이러한 구성 요소를 자세히 설명하는 일련의 블로그에 대한 두 번째 부분입니다. 데이터 수집은 두 부분으로 나뉩니다. 2부에서는 원시 데이터를 변환한 다음, 데이터 레코드를 Azure Event Hubs에 게시하는 구성 요소를 다룹니다. 자세한 내용은 <a href="https://azure.microsoft.com/en-us/blog/creating-a-data-stream-from-nist-manufacturing-lab-data-part-1/" target="_blank">NIST 제조 랩 데이터 1부에서 데이터 &ndash; 스트림 만들기를</a> 참조하세요.</p>


  <h2>두 마이크로 서비스 간의 통신</h2>


  <p>문제는 논리 앱 구성 요소와 원시 데이터를 변환하고 결과 데이터 레코드를 Event Hubs에 게시하는 사용자 지정 코드 간의 통신을 만드는 방법입니다. 이벤트 및 샘플과 같은 각 데이터 레코드 형식은 서로 다른 Event Hubs에서 수신됩니다.</p>


  <p>통신 메커니즘부터 시작합니다&rsquo;. 마이크로 서비스 간 통신, 직접 메시징 또는 네트워킹 통신 및 메시지 전달을 위한 두 가지 일반적인 방법에 대해 이야기할 수 있습니다.</p>


  <p><br>

  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ee2f0ba2-47ce-4494-8e69-5722083efbde.png"><img alt="image" border="0" height="135" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/e3937665-3957-4d64-ba25-fd3944460846.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="이미지" width="624"></a></p>


  <p>가장 좋은 방법은 메시지 전달을 사용하여 마이크로 서비스를 분리하는 것입니다. 메시지의 수신 끝에 있는 마이크로 서비스는 메시지가 도착하여 처리되기를 기다립니다. 또한 이 방법을 사용하면 여러 서버가 하나의 큐를 처리하여 쉽게 확장할 수 있습니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b4a9d704-22d4-4629-a460-f54f484d205a.png"><img alt="image" border="0" height="90" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/20e4dee2-76ef-4774-8656-d2fd0883a52b.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="이미지" width="322"></a></p>


  <p>이 프로젝트의 경우 <a href="https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction?WT.mc_id=%20iotinsightsblog3-blog-ercenk%20" target="_blank">Azure Queue Storage</a> 서비스(Storage 큐)를 사용합니다. Storage 큐를 사용하므로 원시 메시지를 변환하는 구성 요소는 큐 서비스에서 새 메시지를 폴링하고 처리해야 합니다.</p>


  <h2>변환 및 게시 구성 요소</h2>


  <p>사용자 지정 코드는 들어오는 원시 결과를 XML의 데이터 레코드에 대한 플랫 구조로 변환합니다. 레코드는 타임스탬프가 있는 이름-값 쌍 집합입니다.</p>


  <p>타임스탬프를 추출하려면 <a href="https://github.com/Ercenk/MTConnect.Client" target="_blank">GitHub</a> 있는 이 MTConnect 클라이언트를 사용합니다. 라이브러리를 <a href="https://www.nuget.org/packages/MTConnect.Client/" target="_blank">NuGet 패키지</a>로 설치할 수도 있습니다. 라이브러리는 표준 2.0을 targets.NET.</p>


  <p>구성 요소는 큐 서비스를 폴링하여 메시지를 검색합니다. <a href="https://github.com/Azure/azure-webjobs-sdk/wiki" target="_blank">Azure WebJobs SDK</a> 는 스토리지 Blob, 큐 및 테이블과 함께 작동하는 선언적 바인딩 및 트리거 시스템을 제공하여 이 작업을 간소화합니다. 또한 SDK는 큐 폴링을 제어합니다.</p>


  <p><a href="https://github.com/Azure/azure-functions-host" target="_blank">Azure Functions 호스트</a> 를 사용하면 Azure WebJobs SDK를 대상으로 하는 사용자 지정 코드를 호스팅할 수 있습니다. 코드는 다른 환경에서 실행할 수 있습니다. 이 경우 Docker 컨테이너를 사용하여 함수 코드를 호스트하고 Docker 컨테이너는 <a href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">Azure Container Instances</a>에서 호스팅됩니다.</p>


  <p><a href="https://docs.microsoft.com/azure/azure-functions/functions-run-local?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">Azure Functions 핵심 도구</a> 는 구현의 나머지 부분을 계속 진행하는 데 사용됩니다. 버전 2.x를 사용합니다. 도구가 설치되면 언어, 이름 및 함수에 대한 원하는 옵션을 사용하여 func new 명령을 실행하여 스텁 메서드를 생성합니다. func 템플릿 목록 명령을 실행하여 지원되는 템플릿을 확인하고 큐 트리거를 선택합니다.</p>


  <h2>WebJob 예제 코드</h2>


  <p>다음은 기본 항목 메서드입니다. 특성에서 FunctionName은 호스트에 WebJobs 함수임을 알려줍니다. 다음으로 트리거 및 바인딩이 제공됩니다. smssamples 큐에 메시지가 있을 때 코드가 트리거됩니다. 그 다음에는 다양한 대상에 대한 데이터를 읽고 쓰는 바인딩이 뒤따릅니다. Event Hubs에 대한 세 가지 바인딩이 대상으로 있습니다. Azure Blob에 대한 입력 바인딩과 세 개의 <a href="https://azure.microsoft.com/services/storage/tables?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">Azure Storage</a> 테이블에 대한 출력 바인딩이 있습니다. Blob의 이름은 메시지의 내용에서 검색됩니다. C# 특성 인수 스트림/{queueTrigger}는 Blob의 이름이 메시지 내용에 있음을 지정합니다. 자세한 내용은 <a href="https://docs.microsoft.com/azure/azure-functions/functions-bindings-storage-blob?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">Azure Functions에 대한 Azure Blob Storage 바인딩을 참조하세요</a>.</p>


  <pre>

  [FunctionName(&quot;FlattenAndPost&quot;)]

  public static async Task Run(
       [QueueTrigger(&quot;smssamples&quot;, Connection = &quot;queueConnectionString&quot;)]
       string myQueueItem,
       TraceWriter log,
       ExecutionContext context,
       [EventHub(&quot;samplesEventHub&quot;, Connection = &quot;smssamplesEventHub&quot;)]
       IAsyncCollector&lt;string&gt; asyncSampleCollector,
       [EventHub(&quot;eventsEventhub&quot;, Connection = &quot;smsEventsEventHub&quot;)]
       IAsyncCollector&lt;string&gt; asyncEventCollector,
       [EventHub(&quot;conditionsEventhub&quot;, Connection = &quot;smsConditionsEventHub&quot;)]
       IAsyncCollector&lt;string&gt; asyncConditionCollector,
       [Table(&quot;eventsfromfunction&quot;, Connection = &quot;queueConnectionString&quot;)]
       IAsyncCollector&lt;EventTableRecord&gt; asyncEventTableCollector,
       [Table(&quot;samplesfromfunction&quot;, Connection = &quot;queueConnectionString&quot;)]
       IAsyncCollector&lt;SampleTableRecord&gt; asyncSampleTableCollector,
       [Table(&quot;conditionsfromfunction&quot;, Connection = &quot;queueConnectionString&quot;)]
       IAsyncCollector&lt;ConditionsTableRecord&gt; asyncConditionTableCollector,
       [Blob(&quot;streams/{queueTrigger}&quot;, FileAccess.Read)]
       Stream blobStream)</pre>

  <p>Blob을 읽은 후에는 <a href="https://github.com/Ercenk/MTConnect.Client" target="_blank">MTConnect 클라이언트</a> 라이브러리&rsquo; 개체 모델을 사용할 수 있습니다. DeserializeResults 메서드는 <a href="https://docs.microsoft.com/dotnet/api/system.xml.serialization.xmlserializer?view=netframework-4.7.2" target="_blank">XMLSerializer</a> 를 사용하여 XML을 개체로 역직렬화합니다. 자세한 내용은 <a href="https://docs.microsoft.com/dotnet/framework/wcf/feature-details/using-the-xmlserializer-class?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">XMLSerializer 사용을</a> 참조하세요.</p>


  <pre>

  var sampleResult = DeserializeResults&lt;MTConnectStreamsType&gt;(blobContents);</pre>


  <p>그런 다음 코드는 기본적으로 동일한 작업을 수행하는 별도의 함수를 통해 이벤트, 샘플 및 조건을 처리합니다. 즉, LINQ를 사용하여 계층 구조를 플랫 구조로 프로젝팅하고 바인딩에 씁니다.</p>


  <pre>

  var nonEmptyEvents = sampleResult.Streams.Where(
           s =&gt; s.ComponentStream != null
                &amp;&amp; s.ComponentStream.All(cs =&gt; cs.Events != null &amp;&amp; cs.Events.Any()))
       .ToList();

  events = nonEmptyEvents.SelectMany(
       s =&gt; s.ComponentStream.SelectMany(
           cs =&gt; cs.Events.Select(
               e =&gt; new EventRecord()
               {
                   HourWindow =
                       new DateTime(
                           e.timestamp.Year,
                           e.timestamp.Month,
                           e.timestamp.Day,
                           e.timestamp.Hour,
                           0,
                           0),
                   Id = Guid.NewGuid().ToString(),
                   DeviceName = s?.name,
                   DeviceId = s?.uuid,
                   Component = cs?.component,
                   ComponentName = cs?.name,
                   ComponentId = cs?.componentId,
                   EventDataItemId = e?.dataItemId,
                   EventTimestamp = e?.timestamp,
                   EventName = e?.name,
                   EventType = e.GetType().Name,
                   EventSequence = e?.sequence,
                   EventSubtype = e?.subType,
                   EventValue = e?.Value
               }))).OrderBy(r =&gt; r.EventSequence).ToList();</pre>

  <p>또한 Event Hubs 바인딩은 기본적으로 설치되지 않으며 NuGet 필요한 라이브러리(Microsoft.Azure.WebJobs.Extensions.EventHubs)를 참조해야 합니다.</p>


  <p>이 설정을 사용하면 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-run-local?WT.mc_id=iotinsightsblog3-blog-ercenk" target="_blank">Azure Functions Core Tools</a>에 설명된 대로 함수를 로컬로 실행할 수 있어야 합니다.</p>


  <h2>Docker 컨테이너에서 실행</h2>


  <p>이 코드를 Docker 컨테이너로 가져오는 방법을 살펴보겠습니다&rsquo;. Dockerfile은 몇 가지 참고 사항을 제외하고 간단합니다.</p>


  <ul>
   <li>microsoft/azure-functions-dotnet-core2.0 컨테이너 이미지에 대한 종속성을 사용합니다.</li>
   <li><strong>workdir</strong>이 /app인지 확인합니다.</li>
   <li>ASPNETCORE_ENVIRONMENT <strong>개발</strong> 로 설정하면 솔루션을 빌드하는 동안 테스트하고 디버그할 수 있습니다. 구성 요소가 배포되면 제거하거나 <strong>프로덕션</strong> 으로 전환해야 합니다.</li>
   <li><strong> AzureWebJobsScriptRoot</strong> 환경 변수를 /app/bin/Debug/netstandard2.0/로 설정합니다.</li>
   <li>local.settings.json 파일의 값을 환경 변수로 <strong>복사</strong>합니다.</li>
   <li>환경 변수를 설정할 때 주위에 &ldquo;=&rdquo; 공간이 없는지 확인합니다.</li>
  </ul>


  <pre>

  FROM microsoft/azure-functions-dotnet-core2.0

  WORKDIR /app

  ENV ASPNETCORE_ENVIRONMENT=&quot;Development&quot;

  ENV AzureWebJobsScriptRoot=/app/bin/Debug/netstandard2.0/

  ENV AzureWebJobsStorage=&quot;&hellip;&quot;

  ENV AzureWebJobsDashboard=&quot;&hellip;&quot;

  ENV queueConnectionString=&quot;&hellip;&quot;

  ENV smssamplesEventHub=&quot;&hellip;&quot;

  ENV smsEventsEventHub=&quot;&hellip;&quot;

  ENV smsConditionsEventHub=&quot;&hellip;&quot;

  ENV consoleLoggingMode=always

  COPY . .</pre>


  <p>평소와 같이 새 Docker 컨테이너를 빌드하고, 새 컨테이너 이미지를 Azure Container Registry에 등록한 다음, 자습서에 설명된 대로 실행합니다.</p>


  <h2>다음 단계</h2>


  <ul>
   <li><a href="https://github.com/MSIndustryExperiences/IoTInsights" target="_blank">샘플 리포지토리</a>를 복제합니다.</li>
   <li>Azure <a href="https://docs.microsoft.com/azure/azure-functions/functions-run-local?WT.mc_id=iotinsightsblog3-acomblog-ercenk" target="_blank">Functions Core Tools를 사용하여 Azure 함수</a>를 사용하여 멋진 솔루션을 빌드합니다.<br>
  &nbsp;</li>

  </ul>
