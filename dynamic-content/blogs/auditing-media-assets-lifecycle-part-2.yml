### YamlMime:Yaml
ms.openlocfilehash: 801292d426d23847fd1d299b612d80ddf0955788
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139912170"
Slug: auditing-media-assets-lifecycle-part-2
Title: 미디어 자산 감사 수명 주기 - 2부
Summary: 미디어 자산의 수명 주기를 감사하는 데 도움이 되는 일련의 게시물의 2부(샘플 코드 포함). 2부에서는 특히 미디어 처리를 위해 Storage VM으로 복사되는 자산을 추적하는 데 집중했습니다.
Content: "이 블로그의 <a href=\"https://azure.microsoft.com/blog/2014/07/23/auditing-media-assets-lifecycle-part-1-2\">1부</a>에서는 미디어 자산이 만들어지고 삭제된 시기를 보여 주는 자산 감사 보고서를 만들 수 있도록 하는 데 중점을 두었습니다. 2부에서는 미디어 처리를 위해 Storage 계정에서 VM으로 복사되는 자산을 추적하는 방법을 다룹니다. 1부에서 제공한 샘플 코드를 기반으로 빌드합니다.\n\n&nbsp;\n<h2>추적 자산</h2>\n작업을 제출하면 작업의 태스크가 큐에 예약되고 Media Services 스케줄러가 작업을 실행할 VM을 할당할 때까지 큐에 배치됩니다. 작업에 입력 자산으로 지정된 자산은 VM이 작업에 할당될 때까지 VM에 복사되지 않습니다. 이 경우 작업 처리 시간을 <strong>AssetAudit </strong>테이블에 항목을 만들기 위한 값으로 사용할 수 있습니다.\n\n&nbsp;\n<h2>코드 변경</h2>\nAssetAuditEntity 클래스에 문자열 멤버를 추가하여 Storage 자산을 복사하는 작업의 ID를 캡처합니다.\n<pre class=\"prettyprint\">    public class AssetAuditEntity : TableEntity\n    {\n        public string OperationType { get; set; }\n        <strong>public string OperationData { get; set; }\n</strong>    }</pre>\nProcessJobs 및 ProcessTasks라는 두 가지 새로운 함수가 있습니다. ProcessJobs 함수는 모든 작업을 반복하고 ProcessTasks 함수는 지정된 작업에 대한 모든 태스크를 반복합니다. 각 태스크에 대해 태스크와 연결된 모든 기록 이벤트를 확인하고 \"처리\"에 대한 이벤트를 찾으면 이벤트 타임스탬프를 rowkey로 사용하여 AssetAudit 테이블(OperationType=\"InputToTask\" 및 OperationData=TaskId)에 항목을 만듭니다.\n<pre class=\"prettyprint\">        static void ProcessJobs()\n        {\n            try\n            {\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentSkipSize = 0;\n\n                while (true)\n                {\n                    foreach (IJob job in _context.Jobs.Skip(skipSize).Take(batchSize))\n                    {\n                        currentSkipSize++;\n                        Console.WriteLine(\"Processing Job \" + job.Id);\n\n                        ProcessTasks(job);                        \n                    }\n\n                    if (currentSkipSize == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentSkipSize = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }\n\n                }\n\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"job\"&gt;&lt;/param&gt;\n        static void ProcessTasks(IJob job)\n        {\n            try\n            {\n                foreach (ITask task in job.Tasks)\n                {\n                    Console.WriteLine(\"Processing Task Id:\" + task.Id);\n                    for (int i = 0; i &lt; task.HistoricalEvents.Count; i++)\n                    {\n                        if (task.HistoricalEvents[i].Code == \"Processing\")\n                        {\n                            for (int j = 0; j &lt; task.InputAssets.Count; j++)\n                            {\n                                InsertAssetData(task.InputAssets[j].Id, task.HistoricalEvents[i].TimeStamp.ToString(\"o\"), \"InputToTask\", task.Id);\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }</pre>\nOperationData에 대한 선택적 매개 변수를 허용하도록 InsertAssetData 함수가 업데이트되었습니다.\n<pre class=\"prettyprint\">        static void InsertAssetData(string _assetId, string _timeStamp, string _operationType<strong>, string _operationData = null</strong>)\n        {\n            try\n            {\n                bool _insert = true;\n                if (_operationType == \"Create\")\n                {\n                    // If operationtype is Create, then check if an entry already exists for the given asset id\n\n                    TableQuery&lt;AssetAuditEntity&gt; query = new TableQuery&lt;AssetAuditEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, _assetId));\n                    query.Take(1);\n\n                    TableQuerySegment&lt;AssetAuditEntity&gt; tqs = _assetAuditTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count &gt; 0)\n                        {\n                            if (tqs.Results[0].OperationType == \"Create\")\n                            {\n                                _insert = false;\n                            }\n                        }\n                    }\n                }\n\n                if (_insert)\n                {\n                    AssetAuditEntity _asset = new AssetAuditEntity();\n                    _asset.PartitionKey = _assetId;\n                    _asset.RowKey = _timeStamp;\n                    _asset.OperationType = _operationType;\n                    <strong>_asset.OperationData = _operationData;\n</strong>\n                    TableOperation op = TableOperation.Insert(_asset);\n                    _assetAuditTable.Execute(op);\n                }\n            }\n            catch (Exception ex)\n            {                \n                Console.WriteLine(ex.Message);                \n            }\n        }</pre>\n마지막으로 주 함수가 ProcessJobs 함수를 호출하도록 업데이트됩니다.\n<pre class=\"prettyprint\">        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _assetAuditTable = _tableClient.GetTableReference(\"AssetAudit\");\n                _assetAuditTable.CreateIfNotExists();\n\n                ProcessAssetData();\n                ParseStorageLogs();\n\n                <strong>ProcessJobs();</strong>\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }</pre>\n<h2>자산 감사 데이터</h2>\n이 블로그의 1부에 제공된 코드와 위의 코드를 병합하고 실행하면 자산이 Storage 미디어 처리 VM으로 복사된 시기와 관련된 항목으로 AssetAudit 테이블이 업데이트됩니다. 다음은 사용한 테스트 계정에 대해 업데이트된 테이블의 내용 스크린샷입니다. 위의 코드에서 만든 최신 항목의 예를 강조 표시했습니다. 강조 표시된 항목은 자산이 만들어진 시간과 자산을 입력으로 사용한 작업(RowKey를 타임스탬프로 사용)을 보여 줍니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-08_14h10_26.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-08_14h10_26\" alt=\"2014-07-08_14h10_26\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-08_14h10_26_thumb.png\" width=\"1028\" height=\"324\" border=\"0\" /></a>\n\n또한 Excel 파워 쿼리를 사용하여(이 블로그의 1부에서 설명한 대로) 추가 분석을 위해 위의 데이터를 Excel 로드할 수 있습니다.\n\n&nbsp;\n<h2>고려 사항</h2>\n마지막으로 애플리케이션에 이 샘플 코드를 사용하는 것이 좋습니다.\n<ul>\n <li>코드는 Jobs 컬렉션을 사용하여 자산이 Storage 미디어 처리 VM으로 복사된 시기와 관련된 이벤트를 캡처합니다. 위의 코드를 실행하기 전에 삭제된 작업이 있는 경우 해당 이벤트는 캡처되지 않습니다. 애플리케이션이 작업을 실행한 후 삭제하는 경우 작업 알림 처리의 일부로 ProcessTasks 함수 <a href=\"https://msdn.microsoft.com/en-us/library/dn261241.aspx\">를 호출하는 것이</a> 좋습니다.</li>\n <li>이 게시물에 제공된 샘플 코드는 단일 스토리지 계정에 모든 자산이 있는 Media Services 계정으로 작동하도록 설계되었지만 여러 스토리지 계정으로 작업하도록 쉽게 조정할 수 있습니다.</li>\n</ul>"
