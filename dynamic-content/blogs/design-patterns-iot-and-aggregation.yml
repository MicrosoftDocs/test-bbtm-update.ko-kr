### YamlMime:Yaml
ms.openlocfilehash: 78118dc4d31dca0cea263d791a849736ee55b7d2
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139906014"
Slug: design-patterns-iot-and-aggregation
Title: 디자인 패턴 - IoT 및 집계
Summary: 이 디자인 패턴에서는 처리량이 높은 IoT 데이터를 삽입한 다음 다른 필드에 집계를 사용하는 방법을 알아봅니다.
Content: "<p>이 문서에서는 처리량이 높은 IoT 데이터를 삽입한 다음, 보고를 위해 다른 필드에 집계를 사용하는 방법을 알아봅니다. 이 디자인 패턴을 이해하려면 <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/\">Azure Cosmos DB</a>에 익숙하고 <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed\">변경 피드</a>, RU(<a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">요청 단위</a>) 및 <a href=\"https://azure.microsoft.com/en-us/services/functions/\">Azure Functions</a>에 대해 잘 알고 있어야 합니다. 이러한 개념이 새로운 개념인 경우 위의 링크를 따라 자세히 알아보세요.</p>\n\n<p>많은 데이터베이스는 데이터를 분할하므로 처리량이 매우 높고 대기 시간이 짧습니다. MongoDB, HBase, Cassandra 또는 Azure Cosmos DB와 같은 모든 NoSQL 데이터베이스 엔진에 해당합니다. 이러한 모든 데이터베이스는 분할 또는 분할로 인해 무제한으로 확장할 수 있습니다.</p>\n\n<p>Azure Cosmos DB를 좀 더 자세히 살펴보겠습니다. 최상위 수준에서 컨테이너가 정의됩니다. 컨테이너를 테이블, 컬렉션 또는 그래프로 생각할 수 있지만 모든 정보를 보유하는 주 엔터티입니다. Azure Cosmos DB는 컨테이너&rdquo;라는 단어를 &ldquo;사용하여 이 최상위 엔터티를 정의하고, Azure Cosmos DB는 다중 모델 데이터베이스이므로 이 컨테이너는 SQL, MongoDB 및 Graph API 및 Cassandra 또는 Table API용 테이블 컬렉션과 동의어입니다.</p>\n\n<p>컬렉션에는 컬렉션의 처리량 요구 사항에 따라 할당되는 많은 실제 파티션이 있습니다. 현재 10000RU의 경우 10개의 파티션을 가져올 수 있지만 이 숫자는 내일 변경 될 수 있습니다. 원하는 처리량에 항상 집중해야 하며 할당된 파티션 수에 대해 걱정하지 말아야 합니다. 말했듯이 이 파티션 수는 데이터 사용량에 따라 변경됩니다.</p>\n\n<p>높은 확장 처리량과 짧은 대기 시간을 달성하려면 데이터를 삽입하는 동안 파티션 키와 행 키를 지정하고 데이터를 읽는 동안 동일한 파티션 키와 행 키를 사용해야 합니다. 올바른 파티션 키를 선택하면 데이터가 모든 파티션에 균등하게 분산되고 읽기 및 쓰기 작업은 한 자리 밀리초 단위일 수 있습니다.</p>\n\n<p>내부적으로 Azure Cosmos DB는 해시 기반 분할을 사용합니다. 항목을 작성하는 경우 Azure Cosmos DB는 파티션 키 값을 해시하고 해시된 결과를 사용하여 항목을 저장할 파티션을 결정합니다. 좋은 파티션 키는 아래 그림과 같이 사용 가능한 모든 파티션 간에 데이터를 동일하게 분산합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4085ed78-4f92-4ab6-b760-afb5976e3ed8.png\"><img alt=\"GoodPartition\" border=\"0\" height=\"282\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/83d636ea-ff05-4fdd-bdae-542e720900ee.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"GoodPartition\" width=\"319\"></a></p>\n\n<p align=\"center\"><em>좋은 파티션 키, 데이터가 동일하게 분산됨</em></p>\n\n<p>파티션 키와 실제 파티션 간의 일대일 매핑이 존재하지 않습니다&rsquo;. 즉, 단일 물리적 파티션이 많은 키를 저장할 수 있습니다. 이는 온이 논리적 개념(파티션 키)이고 다른 하나는 물리적 개념이기 때문입니다. 종종 초보 사용자는 파티션 키가 실제 파티션과 같다고 생각합니다. 하나는 논리적 개념이고 다른 하나는 물리적 개념이며, 하나씩 매핑되지 않습니다. 각 키는 해시된 다음 모듈로 연산자를 사용하여 파티션에 매핑됩니다. 각 논리 파티션은 10GB의 데이터를 저장할 수 있으며, 이 제한은 나중에 변경될 수 있으며 데이터가 10GB 이상으로 증가할 때 자동으로 분할됩니다. 파티션을 직접 분할하는 것에 대해 걱정할 필요는 없지만 Azure Cosmos DB는 백그라운드에서 파티션을 분할합니다. 그러나 10GB 이상의 데이터를 가질 수 있는 파티션 키는 없어야 합니다.&nbsp;</p>\n\n<div style=\"background: rgb(238, 238, 238); padding: 5px 10px; border: 1px solid rgb(204, 204, 204); border-image: none; text-align: center;\"><em>백만 개의 파티션 키는 백만 개의 실제 파티션을 만들지 않습니다.</em></div>\n\n<p>이제 예제를 살펴보겠습니다&rsquo;. 온도를 유지하기 위해 건물에 IoT 디바이스가 설치된 IoT 회사에서 일하고 있으며 전 세계 수십만 명의 고객이 있습니다. 각 고객에게는 1분마다 온도를 업데이트하는 수천 개의 IoT 디바이스가 있습니다. 데이터가 어떻게 표시되는지 정의해 보겠습니다&rsquo;.</p>\n\n<pre>\n{\n     CustomerId: Microsoft,\n     DeviceId: XYZ-23443,\n     Temperature: 68\n     DateTime: 32423512\n}</pre>\n\n<p>Imagine 모든 국가에 지사가 있고 100,000개의 IoT 디바이스가 분산된 글로벌 회사 고객이 있습니다. 이러한 디바이스는 매일 총 2GB에 대해 1분마다 2KB의 데이터를 전송합니다. 이 속도로 5일 이내에 파티션을 채울 수 있습니다. TTL(Time to Live) 메커니즘을 사용하여 데이터를 자동으로 삭제할 수 있지만, 이 예제&rsquo;에서는 이 데이터를 30일 동안 유지해야 하는 것으로 가정합니다.</p>\n\n<p>CustomerId&rdquo;를 파티션 키로 선택하면 &ldquo;대규모 고객에 대한 데이터가 왜곡되고 파티션이 아래와 같이 표시됩니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/97f84165-5f51-4c68-bd3a-0526e3611106.png\"><img alt=\"BadPartition\" border=\"0\" height=\"284\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6a8bbc4a-8676-430c-9740-2f6b0bed4ed8.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"BadPartition\" width=\"324\"></a></p>\n\n<p>이러한 종류의 분할은 수천 개의 IoT 디바이스가 있고 CustomerId&rdquo;에 분할된 컬렉션에 데이터를 삽입하는 대규모 고객에 대한 &ldquo;제한을 만듭니다. 왜 제한될지 궁금할 것입니다. 이를 이해하려면 컬렉션이 5000RU/초로 정의되고 5개의 파티션이 있다고 상상해 보십시오. 즉, 각 파티션 처리량에는 1000RU가 있을 수 있습니다.</p>\n\n<p>여기서는 5개의 파티션이 있다고 설명했지만, 이 숫자는&#39;논의를 위해 다시 여기에 있습니다. 이 숫자는 처리량에 대해 나중에 변경될 수 있습니다. 하드웨어가 변경되면 내일 3개의 파티션 또는 5000RU에 대한 파티션 하나만 가져올 수 있습니다. 이러한 실제 파티션은 일정하지 않으며 데이터가 계속 커짐에 따라 자동으로 분할됩니다.</p>\n\n<p>사용자는 종종 이 실수를 한 다음 5000RU에 대한 컬렉션을 프로비전한 경우에도 2000RU로 제한되고 있다고 불평합니다. 이 시나리오에서 주요 문제는 데이터가 제대로 분할되지 않고 하나의 파티션에 2000RU를 삽입하려고 한다는 것입니다. 따라서 모든 파티션에 데이터를 균등하게 분산할 수 있는 적절한 파티션 키가 있어야 합니다.</p>\n\n<p>CustomerId&rdquo;가 좋은 파티션 키가 아닌 경우 &ldquo;사용할 수 있는 다른 키는 무엇인가요? 또한 핫 파티션이 생성되므로 DateTime&rdquo;에서 &ldquo;데이터를 분할하는 것을 좋아하지 않습니다. 데이터를 정시에 분할한 Imagine 지정된 1분 동안 모든 호출이 하나의 파티션에 도달합니다. 고객의 데이터를 검색해야 하는 경우 데이터가 모든 파티션에 배포될 수 있으므로 팬아웃 쿼리가 됩니다.</p>\n\n<p>올바른 파티션 키를 선택하려면 읽기 또는 쓰기 시나리오에 대해 생각하고 최적화해야 합니다. 더 간단한 시나리오의 경우 읽기 및 쓰기 시나리오 모두에 대한 파티션 키를 가져올 수 있습니다. 그러나 그렇지 않은 경우 시나리오 중 하나에 대해 타협하고 최적화해야 합니다.</p>\n\n<p>이 문서에서는 읽기 및 쓰기 모두에 적합한 파티션 키가 하나도 없는 시나리오를 살펴보겠습니다. 읽기 및 쓰기 요구 사항을 모두 충족하기 위해 수행할 수 있는 작업을 살펴보겠습니다&rsquo;.</p>\n\n<p>이 시나리오에서는 데이터를 전송하는 디바이스 수가 많기 때문에 쓰기를 최적화해야 합니다. 빠른 수집을 위한 파티션 키로 DeviceId&rdquo;를 사용하여 컬렉션을 &ldquo;정의하는 것이 가장 좋습니다. &ldquo;DeviceId&rdquo;는 고유할 뿐만 아니라 CustomerId&rdquo;보다 &ldquo;세분화됩니다. 데이터가 모든 파티션에 분산되도록 항상 카디널리티 또는 고유성이 더 큰 키를 찾습니다. 그러나 보고의 경우 CustomerId&rdquo;를 통해 &ldquo;집계를 수행하려는 경우 어떻게 해야 할까요?</p>\n\n<p>이 블로그의 핵심입니다. 삽입 시나리오에 대한 데이터를 분할하고 보고 시나리오에 대해 다른 파티션 키의 데이터를 그룹화하려고 합니다. 아쉽게도 이러한 요구 사항은 일치하지 않습니다.</p>\n\n<p>Imagine 데이터를 삽입했습니다.&ldquo; DeviceId&rdquo;를 파티션 키로 사용하지만 온도 및 &ldquo;CustomerId&rdquo;별로 그룹화하려는 경우 쿼리는 파티션 간 쿼리가 됩니다. 파티션 간 쿼리는 가끔 시나리오에 대해 정상입니다. 모든 데이터는 기본적으로 Azure Cosmos DB에서 인덱싱되므로 파티션 간 쿼리는 반드시 나쁜 것은 아니지만 비용이 많이 들 수 있습니다. 파티션 간 쿼리는 지점 조회보다 훨씬 더 많은 RU/s 비용이 듭니다.</p>\n\n<p>이 문제를 해결하는 두 가지 옵션이 있습니다. 첫 번째 옵션은 Azure Cosmos DB&rsquo; 변경 피드 및 Azure Function을 사용하여 시간당 데이터를 집계한 다음 CustomerId&rdquo;가 파티션 키인 &ldquo;다른 컬렉션에 집계된 데이터를 저장하는 것입니다.</p>\n\n<p align=\"center\"><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9cc6fc70-8168-48b8-8fcb-15d07f348a0d.png\"><img alt=\"ChangefeedReporting\" border=\"0\" height=\"485\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4f2cbe68-b86c-4f65-9740-3a2a165f4fa5.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"ChangefeedReportingChange\" width=\"533\"></a> <em>피드</em></p>\n\n<p>시간당 보고서의 변경 피드를 다시 수신 대기하여 하루에 대한 데이터를 집계하고 집계를 다른 Azure Cosmos DB 보고서에 저장할 수 있습니다. IoT 디바이스는 Cosmos DB에 직접 데이터를 보냅니다. 이 패턴은 변경 피드로 인해 가능합니다. 변경 피드는 Cosmos DB의 로그를 노출합니다. 변경 피드에는 컬렉션 내의 문서에 대한 삽입 및 업데이트 작업이 포함됩니다. <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed\">변경 피드</a>에 대해 자세히 알아보세요. 그러나 변경 피드는 모든 계정 및 모든 컬렉션에 대해 기본적으로 사용하도록 설정되어 있습니다.</p>\n\n<p>변경 피드 및 Azure 함수를 사용하는 방법에 대해 자세히 알아보려면 이 <a href=\"https://www.youtube.com/watch?v=iprndNsUeeg&amp;t=459s\">화면 캐스트</a>를 확인하세요.</p>\n\n<p>두 번째 옵션은 Spark를 사용하여 집계를 수행하고 집계된 값을 SQL 데이터 웨어하우스 또는 파티션 키가 CustomerId인 두 번째 컬렉션에 유지하는 것입니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/89cf5def-0143-49de-910b-1b7201e61e2e.png\"><img alt=\"ChangefeedSpark\" border=\"0\" height=\"291\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f72b720a-08ef-4cb5-8fe7-66b8ba87ae5e.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"ChangefeedSparkThis\" width=\"427\"></a> 옵션도 변경 피드를 사용합니다. Spark에서 직접 연결하여 피드를 변경하고 Spark의 모든 변경 내용을 실시간으로 가져올 수 있습니다. 데이터가 Spark에 있으면 집계를 수행하고 해당 데이터를 Azure Cosmos DB 또는 SQL Data Warehouse에 다시 쓸 수 있습니다.</p>\n\n<p>Azure Cosmos DB에서 데이터를 읽고, 집계를 수행하고, 데이터를 다시 쓰기 위해 Spark에 대한 코드 조각은 다음과 같습니다.</p>\n\n<pre>\n# Base Configuration\niotConfig = {\n&quot;Endpoint&quot; : &quot;https://xx.documents.azure.com:443/&quot;,\n&quot;Masterkey&quot; : &quot;E0wCMaBIz==&quot;,\n&quot;Database&quot; : &quot;IoT&quot;,\n&quot;preferredRegions&quot; : &quot;Central US;East US2&quot;,\n&quot;Collection&quot; : &quot;IoT&quot;,\n&quot;checkpointLocation&quot; : &quot;dbfs://checkpointPath&quot;\n}\n# Connect via Spark connector to create Spark DataFrame\niot_df = spark.read.format(&quot;com.microsoft.azure.cosmosdb.spark&quot;).options(**iotConfig).load()\niot_df.createOrReplaceTempView(&quot;c&quot;)\npsql = spark.sql (&quot;select DeviceId, CustomerId, Temp from c&quot;)\n \nwriteConfig = {\n&quot;Endpoint&quot; : &quot;https://xx.documents.azure.com:443/&quot;,  \n&quot;Masterkey&quot; : &quot;E0wCMaBKdlALwwMhg==&quot;,\n&quot;Database&quot; : &quot;IoT&quot;,\n&quot;preferredRegions&quot; : &quot;Central US;East US2&quot;,\n&quot;Collection&quot; : &quot;MV&quot;,\n&quot;Upsert&quot; : &quot;true&quot;\n     }\niot_df.createOrReplaceTempView(&quot;c&quot;)\npsql = spark.sql (&quot;select CustomerId, avg(temp) as Temp_Avg from c group by c.CustomerId &quot;)\npsql.write.format(&quot;com.microsoft.azure.cosmosdb.spark&quot;).mode(&#39;append&#39;).options(**writeConfig).save()</pre>\n\n<p><a href=\"https://www.youtube.com/watch?v=P9Qz4pwKm_0&amp;t=1559s\">화면 캐스트</a>를 확인하여 Azure Cosmos DB에서 Spark를 사용하는 방법을 알아봅니다.</p>\n\n<p>두 옵션 모두 라이브 변경 피드를 수신 대기하여 분당 집계를 제공할 수 있습니다. 보고 요구 사항에 따라 다른 컬렉션 또는 동일한 컬렉션에서 서로 다른 수준에서 다른 집계를 유지할 수 있습니다. 데이터 웨어하우스를 SQL 위해 이러한 집계된 값을 유지해야 하는 또 다른 옵션입니다.</p>"
