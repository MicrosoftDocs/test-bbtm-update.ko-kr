### YamlMime:Yaml
ms.openlocfilehash: 8663323b4dfa672b175dc8de25c2a8fe141b8422
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139912115"
Slug: azure-cosmos-db-partitioning-design-patterns-part-1
Title: Azure Cosmos DB 분할 디자인 패턴 - 1부
Summary: 이 문서에서는 파티션 키를 사용하여 데이터를 효율적으로 배포하고, 애플리케이션 성능을 개선하고, 더 빠른 조회를 사용하도록 설정하는 방법을 알아봅니다. 이 문서의 필수 구성 요소는 Azure Cosmos DB에 대한 일반적인 지식과 변경 피드, RU(요청 단위) 및 Azure Functions에 대한 이해입니다.
Content: >-
  <p>이 문서에서는 파티션 키를 사용하여 데이터를 효율적으로 배포하고, 애플리케이션 성능을 개선하고, 더 빠른 조회를 사용하도록 설정하는 방법을 알아봅니다. 이 문서의 필수 구성 요소는 Azure Cosmos DB에 대한 일반적인 지식과 <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed">변경 피드</a>, RU(<a href="https://docs.microsoft.com/en-us/azure/cosmos-db/request-units">요청 단위</a>) 및 <a href="https://azure.microsoft.com/en-us/services/functions/">Azure Functions</a>에 대한 이해입니다.</p>


  <p>Imagine 높은 처리량으로 삽입하고 두 개 이상의 다른 키에 쿼리하려는 데이터가 있습니다. 이 시나리오에서는 항공사에서 근무하며 사용자 예약 정보를 컬렉션에 저장해야 한다고 가정합니다. 사용자 데이터는 다음과 같이 정의됩니다.</p>


  <pre>

  {
       UserId: user@email.com,
       FirstName: John,
       LastName: Doe,
       PNR: 2345423,
       CityOfOrigin: Seattle,
       CityOfDestination: London,
       DOB: 12.2.76,
       other details &hellip;.
  }</pre>


  <p>가능한 많은 값 중에서 UserId&rdquo;(사용자 전자 메일 주소)를 파티션 키로 선택합니다&ldquo;. UserId&rdquo;는 모든 사용자에 대해 고유하므로 데이터가 잘 분산되도록 하므로 파티션 키&ldquo;에 적합합니다. 데이터는 그림 1과 같이 모든 파티션 간에 균등하게 분산됩니다. 그러나 데이터를 쿼리할 때 항상 UserId&rdquo;가 &ldquo;있는 것은 아닙니다. 경우에 따라 사용자 성 또는 PNR(사용자 승객 이름 레코드) 번호로 데이터를 쿼리하려고 합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/59bc2d78-5964-4bd1-ad72-a58dd800c68e.png"><img alt="GoodPartition" border="0" height="278" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3a5b75b8-9abd-4224-bc1e-c4f67a50b24a.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="GoodPartition" width="321"></a></p>


  <p align="center"><em>그림 1: 파티션 간에 균등하게 분산된 데이터</em></p>


  <p>Azure Cosmos DB는 기본적으로 모든 데이터를 인덱싱합니다. LastName&quot;으로 &quot;데이터를 쿼리하려고 하면 결과를 얻을 수 있지만 파티션 키가 없는 쿼리는 팬아웃 쿼리가 되기 때문에 RU/s(<a href="https://docs.microsoft.com/en-us/azure/cosmos-db/request-units">요청 단위</a>)가 더 많이 발생합니다. 팬아웃 쿼리는 모든 파티션을 확인하므로 추가 RU/s 비용이 들며 애플리케이션의 성능에 영향을 줄 수 있습니다. 적은 수의 데이터가 있는 파티션이 적은 경우 팬아웃 쿼리의 중요한 부작용을 인식하지 못할 수 있지만 많은 수의 파티션과 많은 양의 데이터를 가져오기 시작하면 팬아웃 쿼리가 애플리케이션에 해로울 수 있습니다. 자주 사용되지 않는 파티션 간 쿼리는 괜찮지만, 자주 쿼리하는 경우 솔루션은 무엇인가요?</p>


  <p>한 가지 옵션은 PNR을 UserId로 매핑하기 위해 PNR 및 &ldquo;LastName&rdquo;을 두 개 더 조회하고 LastName&rdquo;을 UserId&rdquo;&rdquo;&ldquo;에 매핑하는 것입니다.&ldquo;&ldquo; PNR 컬렉션에는 PNR을 파티션 키 및 행 키로, &ldquo;UserId&rdquo; 를 값으로 사용합니다.&nbsp;</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9d2f02b1-e0d0-447f-a4cb-58eb5ec6e98b.png"><img alt="clip_image002" border="0" height="215" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/35380b34-d223-42b5-92c9-b0c9de91ea62.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="clip_image002" width="659"></a></p>


  <p>이러한 다양한 조회 컬렉션을 사용하면 애플리케이션의 효율성을 높일 수 있습니다. PNR별로 세부 정보를 조회하려면 먼저 PNR 컬렉션을 쿼리하여 UserId&rdquo;를 &ldquo;가져옵니다. 그런 다음 UserId&rdquo;를 사용하여 &ldquo;모든 세부 정보에 대한 사용자 컬렉션을 쿼리합니다. 이러한 두 호출은 몇 밀리초 내에 완료할 수 있으며 단일 팬아웃 쿼리보다 더 적은 RU/s를 사용합니다. 대부분의 지점 조회는 1~2밀리초 내에 완료할 수 있습니다. 두 번의 조회 후에도 대부분의 쿼리에 대해 10밀리초 이내에 수행할 수 있습니다.</p>


  <p>호출에 몇 밀리초의 추가를 원하지 않을 수 있으며 대신 PNR 및 &ldquo;LastName&rdquo; 컬렉션의 데이터를 복제하도록 결정할 수 있습니다. 이렇게 하면 빠른 조회가 가능하지만 데이터가 업데이트될 때 복잡성과 비용이 추가될 수 있으므로 권장되지 않습니다&rsquo;. 궁극적으로 요구 사항, 성능 및 복잡성의 균형을 유지해야 합니다. 간단한 솔루션으로 시작하는 것이 가장 좋은 방법인 경우가 많습니다.</p>


  <p>&rsquo;이제 다양한 컬렉션의 데이터 배포를 살펴보겠습니다. 예를 들어 LastName&rdquo; 컬렉션을 보면 &ldquo;Zubrkee&rdquo;보다 &ldquo;성 Smith&rdquo;를 가진 &ldquo;사람이 더 많기 때문에 데이터가 동일하게 분산되지 않는 것을 확인할 수 있습니다. 이 경우 데이터는 그림 2와 매우 유사합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/02535643-5f76-4e7a-9483-9b3d70a7de97.png"><img alt="BadPartition" border="0" height="278" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ce4f0c82-4f2b-4e0c-8e2f-fd1ec96f8945.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="BadPartition" width="320"></a></p>


  <p align="center"><em>그림 2: 파티션에 고르지 않게 분산된 데이터</em></p>


  <p>이 시나리오의 데이터는 일부 전체 파티션 및 다른 파티션이 크게 과소 사용되어 고르지 않게 분산됩니다. 이러한 유형의 데이터 배포는 많은 문제를 만듭니다.</p>


  <ul>
   <li>컬렉션의 총 RU/s는 모든 파티션으로 나뉩니다. 즉, 5개의 파티션에 1000RU/s가 각 파티션에 대해 200RU/s로 분산됩니다. 이러한 파티션에 200RU/s 이상을 쓰려고 하면 임계값을 초과하면 호출이 실패하기 시작합니다. 개발자가 컬렉션 수준에서 1,000RU/s를 할당했음에도 불구하고 300RU/s에 제한을 받는 것을 발견&rsquo;하면 잘못된 파티션 키가 하나의 파티션에만 도달하는 경우가 많습니다.</li>
   <li>파티션 키는 현재 최대 10GB의 데이터를 포함할 수 있으므로(향후 변경될 수 있음) 모든 파티션을 효율적으로 채우는 파티션 키를 사용하는 것이 중요합니다. LastName&rdquo; 예제&ldquo;에서는 데이터를 균등하게 분산하기 위해 보다 세분화된 파티션 키가 필요합니다. 데이터에 Origin City도 포함&ldquo;되므로 LastName&rdquo; 및 &ldquo;Origin City&rdquo;&rdquo;에서 &ldquo;새 파티션 키를 만들 수 있으며 결과는 아래 그림 3과 같습니다.</li>
  </ul>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/68082817-1ab1-4a3c-9d23-b6b4fb6bf7cd.png"><img alt="NotBadPartition" border="0" height="285" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/cde41df7-c3b8-45bd-97f8-661be847d04b.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="NotBadPartition" width="323"></a></p>


  <p align="center"><em>그림 3: 세분화된 파티션 키를 적용한 후 데이터 배포</em></p>


  <p>이것은 훨씬 더 보인다. 데이터는 더 균등하게 배포되며, 여행자는 성 및 원산지 도시를 입력하기만 하면 예약을 쉽고 빠르게 조회할 수 있습니다.</p>


  <p>&rsquo;데이터를 균등하게 분산했으므로 다른 컬렉션을 어떻게 채웁니까? 이를 위해 변경 피드를 이해해야 합니다. <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed">변경 피드</a> 는 컬렉션 내에서 발생하는 모든 내부 변경 내용을 노출합니다. Azure Cosmos DB의 변경 피드 지원은 모든 변경 사항에 대해 Azure Cosmos DB 컬렉션을 수신하여 작동합니다. 그런 다음 변경된 문서가 수정된 순서로 정렬된 목록이 출력됩니다. 변경 사항은 지속적이며, 비동기적 및 증분적으로 처리할 수 있고 출력을 하나 이상의 소비자 사이에 분산하여 병렬 처리가 가능합니다.</p>


  <p>변경 피드는 문서 컬렉션 내의 각 파티션 키 범위에 사용할 수 있으므로 병렬 처리를 위해 하나 이상의 소비자에게 배포할 수 있습니다. 레코드가 사용자 컬렉션에 삽입될 때마다 변경 피드에 표시됩니다. 변경 피드를 사용하는 가장 쉬운 방법은 Azure Function입니다. Azure Functions는 인프라를 명시적으로 프로비전하거나 관리할 필요 없이 주문형 코드를 실행할 수 있는 <a href="https://azure.microsoft.com/solutions/serverless/">서버리스</a> 컴퓨팅 서비스입니다. Azure Functions를 사용하여 다양한 이벤트에 대한 응답으로 스크립트 또는 코드 조각을 실행합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c05eafc5-3823-4fdb-93de-8f4ab499fe4b.png"><img alt="PNRAF" border="0" height="385" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2604e7e9-8ed9-4946-8a33-c97d0d710045.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="PNRAF" width="564"></a></p>


  <p>Azure 함수를 통해 변경 피드를 사용하는 경우 삽입/변경된 모든 문서가 함수의 매개 변수로 함수에 제공됩니다.</p>


  <pre>

  public static async Task Run(IReadOnlyList&lt;Document&gt; input, TraceWriter log)</pre>


  <p>함수에 전체 문서가 있으면 그에 따라 PNR 및 &ldquo;LastName&rdquo; 컬렉션을 업데이트할 수 있습니다.&nbsp;</p>


  <p>이 <a href="https://www.youtube.com/watch?v=iprndNsUeeg&amp;t=454s">스크린캐스트</a>를 시청하여 Azure Cosmos DB, Azure Function 및 변경 피드를 사용하는 방법에 대해 자세히 알아보거나 변경 피드에 대해 읽어보세요.</p>


  <ul>
   <li><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed#azure-functions">Azure Functions 사용</a></li>
   <li><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed#sql-sdk">Azure Cosmos DB SDK 사용</a></li>
   <li><a href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed#change-feed-processor">Azure Cosmos DB 변경 피드 프로세서 라이브러리 사용</a></li>
  </ul>
