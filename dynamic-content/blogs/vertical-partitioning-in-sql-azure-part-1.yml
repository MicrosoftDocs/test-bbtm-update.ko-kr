### YamlMime:Yaml
ms.openlocfilehash: b8f6167144a9e26ffd4cb4007453c1e5501c718b
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139898828"
Slug: vertical-partitioning-in-sql-azure-part-1
Title: 'SQL Azure 수직 분할: 1부'
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] SQL Azure 현재 1GB 및 10GB 데이터베이스를 지원합니다. 더 많은 양의 데이터를 SQL Azure 저장하려는 경우 테이블을 나눌 수 있습니다.'
Content: <p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>SQL Azure 현재 1GB 및 10GB 데이터베이스를 지원합니다. 더 많은 양의 데이터를 SQL Azure 저장하려는 경우 테이블을 여러 SQL Azure 데이터베이스로 나눌 수 있습니다. 이 문서에서는 중간 계층을 사용하여 LINQ를 사용하여 서로 다른 SQL Azure 데이터베이스에서 두 테이블을 조인하는 방법을 설명합니다. 이 기술은 데이터를 SQL Azure 수직으로 분할합니다. </p>  <p>SQL Azure 대한 수직 분할의 이 버전에서는 스키마의 모든 테이블을 둘 이상의 SQL Azure 데이터베이스에 분할합니다. 단일 데이터베이스에서 함께 그룹화할 테이블을 선택할 때 각 테이블의 크기 및 잠재적인 향후 성장을 &ndash; 이해해야 합니다. 목표는 각 데이터베이스의 크기가 같도록 테이블을 균등하게 분산하는 것입니다.</p>  <p>데이터베이스 분할을 통해 얻을 수 있는 성능 향상도 있습니다. SQL Azure 여러 물리적 컴퓨터에 데이터베이스를 분산하므로 워크로드를 분할하여 더 많은 CPU 및 RAM 리소스를 얻을 수 있습니다. 예를 들어 데이터베이스를 10~1GB SQL Azure 데이터베이스에 분할하면 CPU 및 메모리 리소스의 10배가 됩니다. TicketDirect의 사례 연구(여기에서 찾을 수 <a href="https://www.microsoft.com/casestudies/Case_Study_Detail.aspx?CaseStudyID=4000005890">있음</a>)는 최대 부하가 발생하는 동안 수백 개의 SQL Azure 데이터베이스에서 워크로드를 분할합니다. </p>  <p>SQL Azure 데이터베이스 간에 워크로드를 분할하는 경우 단일 데이터베이스에 모든 테이블을 포함하는 일부 기능이 손실됩니다. 이 기술을 사용할 때 고려해야 할 몇 가지 사항은 다음과 같습니다.</p>  <ul>  <li>데이터베이스 전체의 외신 키는 지원되지 않습니다. 즉, 한 데이터베이스의 조회 테이블의 기본 키는 다른 데이터베이스의 테이블에 있는 외래 키에서 참조할 수 없습니다. 이는 외래 키에 대한 SQL Server&rsquo; 데이터베이스 간 지원과 유사한 제한 사항입니다. </li>  <li>클라이언트 쪽에서 Microsoft Distributed Transaction Manager를 사용하는 경우에도 데이터베이스를 포괄하는 트랜잭션을 가질 수 없습니다. 즉, 다른 데이터베이스에 대한 삽입이 실패하는 경우 한 데이터베이스에서 삽입을 롤백할 수 없습니다. 이 제한은 예외를 catch하고 성공적으로 완료된 문에 대해 실행 취소&rdquo; 스크립트를 실행하는 &ldquo;데 필요한 클라이언트 쪽 코딩 &ndash; 을 통해 부정될 수 있습니다. </li>  </ul>  <h4>SQLAzureHelper 클래스</h4>  <p>수직 분할을 수행하기 위해 <b>다음과 같은 SQLAzureHelper </b>클래스를 소개합니다.</p>  <ul>  <li>성능을 위해 앞으로 읽기 전용 커서를 구현합니다. </li>  <li><b>IEnumerable</b> 및 LINQ 지원 </li>  <li>결과 집합이 더 이상 필요하지 않은 경우 연결 및 데이터 판독기를 삭제합니다. </li>  </ul>  <p>이 코드는 앞으로 읽기 전용 커서를 사용하는 성능 이점이 있습니다. 즉, 조인에 필요할 때까지 SQL Azure 데이터를 가져오지 않습니다. </p>  <p><b>SQLAzureHelper</b> 클래스<b></b>에서 결과 집합을 가져오는 코드는 다음과 같습니다.</p>  <pre class="csharpcode">var colorDataReader = SQLAzureHelper.ExecuteReader(      ConfigurationManager.ConnectionStrings[<span class="str">"ColorDatabase"</span>].ConnectionString,      sqlConnection =&gt;      {          SqlCommand sqlCommand =              <span class="kwrd">new</span> SqlCommand(<span class="str">"SELECT ColorName, CompanyId FROM Colors"</span>,                  sqlConnection);          <span class="kwrd">return</span> (sqlCommand.ExecuteReader());      });    var companyDataReader = SQLAzureHelper.ExecuteReader(      ConfigurationManager.ConnectionStrings[<span class="str">"CompanyDatabase"</span>].ConnectionString,      sqlConnection =&gt;      {          SqlCommand sqlCommand =              <span class="kwrd">new</span> SqlCommand(<span class="str">"SELECT CompanyId, CompanyName FROM Companies"</span>,                  sqlConnection);          <span class="kwrd">return</span> (sqlCommand.ExecuteReader());      });</pre>  <p>      </p>  <p>결과 집합은 LINQ에 의해 조인된 두 SQL Server 데이터베이스에서 반환됩니다.</p>  <h4>LINQ</h4>  <p>LINQ는 언어 통합 쿼리, 설정 및 변환 작업을 포함하는 .NET Framework 대한 확장 집합입니다. 쿼리에 대한 네이티브 언어 구문을 사용하여 C# 및 Visual Basic 확장하고 이러한 기능을 활용할 클래스 라이브러리를 제공합니다. <a href="https://msdn.microsoft.com/en-us/netframework/aa904594.aspx">LINQ</a>에 대한 자세한 내용은 여기를 참조하세요. 이 코드는 LINQ를 클라이언트 쪽 쿼리 프로세서로 사용하여 두 결과 집합의 조인 및 쿼리를 수행합니다.</p>  <pre class="csharpcode">var query =      from color <span class="kwrd">in</span> colorDataReader      join company <span class="kwrd">in</span> companyDataReader on          (Int32)color[<span class="str">"CompanyId"</span>] equals (Int32)company[<span class="str">"CompanyId"</span>]      select <span class="kwrd">new</span>      {          ColorName = (<span class="kwrd">string</span>)color[<span class="str">"ColorName"</span>],          CompanyName = (<span class="kwrd">string</span>)company[<span class="str">"CompanyName"</span>]      };    <span class="kwrd">foreach</span> (var combo <span class="kwrd">in</span> query)  {      Console.WriteLine(String.Format(<span class="str">"{0} - {1}"</span>, combo.CompanyName, combo.ColorName));  }</pre>  <p>    </p>  <p>이 코드는 결과 집합을 가져와 <b>CompanyId</b>에 따라 조인한 다음 <b>CompanyName</b> 및 <b>ColorName</b>으로 구성된 새 클래스를 선택합니다.</p>  <h4>연결 및 SQL Azure </h4>  <p>한 가지 주의할 점은 위의 코드가 이전 블로그 게시물에서 언급한 재시도 시나리오를 고려하지 않는다는&rsquo; 것입니다. 이 작업은 예제를 간소화하기 위해 수행되었습니다. LINQ 쿼리를 완전히 다시 실행하려면 재시도 코드가 <b>SQLAzureHelper</b> 클래스 외부로 이동해야 합니다.</p>  <p>다음 블로그 게시물에서는 <b>SQLAzureHelper</b> 클래스를 사용하여 수평 분할을 보여 줍니다. 질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>
