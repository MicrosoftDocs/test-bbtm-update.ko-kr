### YamlMime:Yaml
ms.openlocfilehash: f1e5f4b859a115ddea9c7dc2c5292bf895d9818a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139908463"
Slug: data-driven-styling-and-more-in-the-latest-azure-maps-web-sdk-update
Title: 최신 Azure 지도 웹 SDK 업데이트의 데이터 기반 스타일 지정 등
Summary: Azure 지도 웹 SDK에 대한 최신 업데이트를 발표하게 되어 매우 기쁩습니다. 팀은 여름 내내 많은 강력한 기능을 추가하고 웹 지도 SDK의 전반적인 성능을 개선하기 위해 열심히 노력해 왔습니다.
Content: "<p>Azure 지도 웹 SDK에 대한 최신 업데이트를 발표하게 되어 매우 기쁩습니다. 팀은 여름 내내 많은 강력한 기능을 추가하고 웹 지도 SDK의 전반적인 성능을 개선하기 위해 열심히 노력해 왔습니다. 이 업데이트에 추가된 주요 개선 사항 중 일부는 다음과 같습니다.</p>\n\n<ul>\n <li>개발자 중심 API 개선 사항</li>\n <li>새 데이터 원본 및 계층화 모델</li>\n <li>여러 계층을 데이터 원본에 커넥트</li>\n <li>셰이프 클래스를 관리하기 쉬운 새로운 기능</li>\n <li>계층의 데이터 기반 스타일 지정</li>\n <li>공간 수학 라이브러리</li>\n <li>지리적으로 정확한 원 지원</li>\n</ul>\n\n<h2>개발자 중심 API 개선 사항</h2>\n\n<p>API 인터페이스가 보다 직관적이고 성능을 향상하도록 향상되었습니다. 이전에는 SDK의 대부분의 기능이 Map 클래스의 함수로 노출되었습니다. 관련 함수를 함께 그룹화하지 않으면 개발자는 필요한 함수를 찾기 위해 SDK의 거의 모든 함수와 속성을 검색해야 하는 경우가 많았습니다. 이 릴리스에서는 여러 관련 기능을 함께 그룹화하고 지도 클래스의 관리자 속성을 통해 공개했습니다. 마지막 버전에서는 Map 클래스에 30개 이상의 함수가 있었으며, 그 중 7개는 데이터 계층과 관련이 있었습니다. 이 업데이트에서 이러한 기능은 이제 맵의 레이어&rdquo; 속성을 통해 &ldquo;노출되며 레이어 작업을 더 쉽게 수행할 수 있는 많은 추가 기능이 제공됩니다. 또한 컨트롤, 이벤트, 지도 이미지 스프라이트, HTML 표식 및 데이터 원본에 대한 관리자 속성을 지도에 추가했습니다.</p>\n\n<p>마찬가지로 많은 기본 맵 SDK 설정을 SDK의 루트 <strong>아틀라스</strong> 네임스페이스에 직접 설정하는 옵션도 추가되었습니다. 이렇게 하면 페이지에 생성된 모든 맵 인스턴스와 생성된 모든 서비스 클라이언트가 이러한 설정을 기본값으로 사용합니다. 이전에는 애플리케이션에 추가된 모든 맵 인스턴스 및 서비스 클라이언트가 해당 기능을 초기화하는 동안 Azure 지도 키를 전달해야 했습니다. 즉, 번거로울 수 있는 애플리케이션에서 이 동일한 설정을 여러 번 설정해야 합니다. 루트 <strong>atlas</strong> 네임스페이스에서 키를 설정하면 애플리케이션에서 키를 한 번만 지정하면 되므로 필요한 경우 나중에 쉽게 업데이트할 수 있습니다.</p>\n\n<pre>\natlas.setSubscriptionKey(&#39;Your Azure Maps Key&#39;);</pre>\n\n<p>언어 및 사용자 지역 정보와 같은 몇 가지 다른 설정은 루트 <strong>아틀라스</strong> 네임스페이스에서 기본값으로 설정할 수도 있습니다. 이러한 값은 맵 인스턴스 또는 서비스 클라이언트를 초기화할 때 해당 옵션이 지정되지 않은&rsquo; 경우 사용되는 기본값입니다. 예를 들어 맵을 초기화할 때 다른 언어로 전달하면 해당 언어를 대신 사용합니다. 이 기능은 페이지에 여러 맵을 다른 언어로 표시할 수 있는 시나리오에서 유용합니다.</p>\n\n<p>이러한 개발자 중심의 향상된 기능을 통해 Azure 지도 사용하여 애플리케이션을 훨씬 쉽게 개발할 수 있는 동시에 성능을 높이고 애플리케이션을 작성하는 데 필요한 코드의 양을 줄일 수 있습니다.</p>\n\n<h2>새 데이터 원본 및 계층화 모델</h2>\n\n<p>이전에는 지도 컨트롤에서 GeoJSON 형식의 벡터 공간 데이터를 맵에 추가하는 기능만 제공했습니다. 이 데이터는 백그라운드에서 자체 데이터 원본을 만들고 관리하는 계층에 추가되었습니다. 계층의 데이터를 수정하려면 비효율적이며 아래 샘플 코드에서 볼 수 있듯이 적합하지 않은 코드가 필요한 기존 계층을 덮어써야 합니다.</p>\n\n<pre>\nvar myPins = [/* Array filled with pin data */];\n\n//Add pins to map.\nmap.addPins(pins, {\n     name: &#39;MyPinLayer&#39;\n});\n\n//Create a new pin to add to layer.\nvar pin = new atlas.data.Feature(new atlas.data.Point(lon, lat));\n\n//Add the pin to array of pins.\nmyPins.push(pin);\n\n//Update the layer by overwriting all data in the layer. This is unintuitive and creates a performance hit.\nmap.addPins(pins, {\n     name: &#39;MyPinLayer&#39;,  \n     overwrite: true\n});</pre>\n\n<p>이 릴리스에서는 데이터 원본의 단일 인스턴스만 유지하면서 여러 계층을 사용하여 단일 데이터 원본을 렌더링하는 기능과 같은 여러 가지 이점을 제공하는 계층에서 데이터 원본을 분리하여 메모리 사용량을 줄이고 성능을 개선하며 아래에서 볼 수 있듯이 훨씬 더 쉽게 이해할 수 있는 API를 만듭니다.</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a layer that defines how to render the shapes in the data source and add it to the map.\nvar myPinLayer = new atlas.layer.SymbolLayer(dataSource);\nmap.layers.add(myPinLayer);\n\n//Add pins to the data source.\ndataSource.add([/* Array filled with pin data */]);\n\n//Create a new pin to add to map.\nvar pin = new atlas.data.Feature(atlas.data.Point([lon, lat]));\n\n//Add the pin to the data source, the map automatically updates in the most efficient manner possible.\ndataSource.add(pin);</pre>\n\n<p>GeoJSON 형식 데이터에 대한 DataSource 클래스를 사용하는 것 외에도 새 VectorTileSource 클래스를 통해 벡터 타일 서비스에 대한 지원도 추가되었습니다. 이러한 데이터 원본은 맵에서 데이터가 렌더링되는 방법을 정의하는 다음 계층에 연결할 수 있습니다.</p>\n\n<ul>\n <li><strong>거품형 계층 &ndash;</strong> 픽셀 반경을 사용하여 점 데이터를 크기가 조정된 원으로 렌더링합니다.</li>\n <li><strong>선 계층 &ndash;</strong> 선 및 다각형 윤곽선을 렌더링합니다.</li>\n <li><strong>다각형 계층 &ndash;</strong> 다각형의 채워진 영역을 렌더링합니다.</li>\n <li><strong>기호 계층 &ndash;</strong> 포인트 데이터를 아이콘 및 텍스트로 렌더링합니다.</li>\n</ul>\n\n<p>또한 지도 위에 래스터 타일 이미지를 중첩할 수 있는 TileLayer 클래스도 있습니다. 이 계층을 데이터 원본에 연결하는 대신 타일 서비스 정보가 계층의 옵션으로 지정됩니다.</p>\n\n<p>SDK에서 이 새로운 데이터 원본 및 계층화 모델을 만드는 동안 맵에서 데이터를 시각화하기 위한 기능 기능 및 렌더링 옵션도 두 배 이상 증가했습니다.</p>\n\n<h2>여러 계층을 데이터 원본에 커넥트</h2>\n\n<p>앞에서 설명한 대로 이제 동일한 데이터 원본에 여러 계층을 연결할 수 있습니다. 이상하게 들릴 수도 있지만 유용하게 사용할 수 있는 다양한 시나리오가 있습니다. 다각형 그리기 환경을 만드는 시나리오를 예로 들어 보겠습니다. 사용자가 다각형을 그릴 때 사용자가 지도에 점을 추가할 때 채우기 다각형 영역을 렌더링해야 합니다. 다각형을 윤곽선으로 표시하는 스타일이 지정된 선을 추가하면 그리는 다각형의 가장자리를 더 쉽게 볼 수 있습니다. 마지막으로 다각형의 각 위치 위에 핀 또는 마커와 같은 일종의 핸들을 추가하면 각 개별 위치를 더 쉽게 편집할 수 있습니다. 다음은 이 시나리오를 보여 주는 이미지입니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b0057eae-d9db-45ec-96bb-6845dd9de7f2.png\"><img alt=\"Connect multiple layers to a data source\" border=\"0\" height=\"569\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ad8b2d0c-b4e0-4c13-b9f4-3d7804fc7377.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"여러 계층을 데이터 원본에 커넥트\" width=\"1428\"></a></p>\n\n<p>대부분의 매핑 플랫폼에서 이 작업을 수행하려면 다각형 개체, 선 개체 및 다각형의 각 위치에 대한 고정을 만들어야 합니다. 다각형이 수정되면 선과 핀을 수동으로 업데이트해야 합니다. 이 작업을 수행하는 데 필요한 작업은 매우 빠르게 복잡해집니다.</p>\n\n<p>Azure 지도 아래 코드와 같이 데이터 원본의 단일 다각형만 있으면 됩니다.</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a polygon and add it to the data source.\ndataSource.add(new atlas.data.Polygon([[[/* Coordinates for polygon */]]]));\n\n//Create a polygon layer to render the filled in area of the polygon.\nvar polygonLayer = new atlas.layer.PolygonLayer(dataSource, &#39;myPolygonLayer&#39;, {\n     fillColor: &#39;rgba(255,165,0,0.2)&#39;\n});\n\n//Create a line layer for greater control of rendering the outline of the polygon.\nvar lineLayer = new atlas.layer.LineLayer(dataSource, &#39;myLineLayer&#39;, {\n     color: &#39;orange&#39;,\n     width: 2\n});\n\n//Create a bubble layer to render the vertices of the polygon as scaled circles.\nvar bubbleLayer = new atlas.layer.BubbleLayer(dataSource, &#39;myBubbleLayer&#39;, {\n     color: &#39;orange&#39;,\n     radius: 5,\n     outlineColor: &#39;white&#39;,\n     outlineWidth: 2\n});\n\n//Add all layers to the map.\nmap.layers.add([polygonLayer, lineLayer, bubbleLayer]);</pre>\n\n<p><a href=\"https://aka.ms/am_polygondrawingsample\" target=\"_blank\">라이브 예제를 참조하세요</a>.</p>\n\n<h2>셰이프 클래스를 관리하기 쉬운 새로운 기능</h2>\n\n<p>Azure 지도 Web SDK의 모든 벡터 기반 데이터는 하루가 끝날 때 정의된 스키마를 따르는 JSON 개체인 GeoJSON 개체로 구성됩니다. GeoJSON 데이터 사용의 한 가지 제한 사항은 데이터를 수정하는 경우 맵에서 개체를 제거하고 바꿀 때까지 맵이 변경 내용을 인식하지 않는다는&rsquo; 것입니다. 작업을 더 쉽고 직관적으로 만들기 위해 GeoJSON 기능 또는 기하 도형을 래핑할 수 있는 새 Shape 클래스를 추가했습니다. 이 클래스는 GeoJSON 데이터를 쉽게 업데이트하고 셰이프가 추가된 데이터 원본에 변경 내용을 즉시 반영할 수 있는 여러 함수를 제공합니다. DataSource 클래스에 추가된 모든 GeoJSON 개체를 자동으로 래핑하는 것이 매우 유용하다는 것을 알게되었습니다.</p>\n\n<p>예를 들어 맵에서 데이터 요소의 위치를 업데이트하려는 시나리오를 예로 들어 겠습니다. 이전에는 계층의 데이터를 별도로 관리한 다음 아래 코드와 같이 계층을 덮어써야 했습니다.</p>\n\n<pre>\n//Create a pin from a point feature.\nvar pin = new atlas.data.Feature(new atlas.data.Point([-110, 45]));\n\n//Add a pin to the map.\nmap.addPins([pin], {\n     name: &#39;MyPinLayer&#39;\n});\n\n//Update pins coordinates... Map does not update.\npin.geometry.coordinates = [-120, 30];\n\n//Overwrite all pins in the layer to update the map.\nmap.addPins([pin], {\n     name: &#39;MyPinLayer&#39;,\n     overwrite: true\n});</pre>\n\n<p>이것은 직관적이지 않으며 예상보다 훨씬 더 많은 작업입니다. Shape 클래스를 사용하여 데이터 포인트를 래핑하면 아래 코드와 같이 맵에서 데이터 요소의 위치를 업데이트하는 코드 줄만 사용합니다.</p>\n\n<pre>\n//Create a data source and add it to the map.\nvar dataSource = new atlas.source.DataSource();\nmap.sources.add(dataSource);\n\n//Create a layer that defines how to render the shapes in the data source and add it to the map.\nvar myPinLayer = new atlas.layer.SymbolLayer(dataSource);\nmap.layers.add(myPinLayer);\n\n//Create a pin and wrap with the shape class and add to data source.\nvar pin = new atlas.Shape(new atlas.data.Point([-110, 45]));\ndataSource.add(pin);\n\n//Update the coordinates of the pin, map automatically updates.\npin.setCoordinates([-120, 30]);</pre>\n\n<p><strong>팁:</strong> 각 개체를 개별적으로 래핑하는 대신 데이터 원본에서 셰이프 래핑된 데이터 버전을 쉽게 검색할 수 있습니다.</p>\n\n<h2>계층의 데이터 기반 스타일 지정</h2>\n\n<p>이 업데이트의 새로운 주요 기능은 속성 함수를 사용하는 새로운 데이터 기반 스타일 기능입니다. 이렇게 하면 연결된 데이터 원본의 각 개별 셰이프에 정의된 속성을 고려하여 개별 스타일 지정 옵션에 비즈니스 논리를 추가할 수 있습니다. 레이어가 렌더링될 때 확대/축소 수준을 고려할 수도 있습니다. 데이터 기반 스타일은 if-statements 및 모니터링 맵 이벤트를 사용하여 일반적으로 이러한 유형의 비즈니스 논리를 작성하고 정의하는 데 필요한 코드의 양을 크게 줄일 수 있습니다.</p>\n\n<p>예를 들어 지진 데이터를 고려합니다. 각 데이터 요소에는 크기 속성이 있습니다. 맵에서 각 데이터 요소의 관련 크기를 표시하기 위해 데이터 요소의 크기가 클수록 원 반경이 클 때 BubbleLayer를 사용하여 배율 조정된 원을 그릴 수 있습니다. 다음 코드에서는 BubbleLayer의 반지름 옵션에 데이터 기반 스타일을 적용하는 방법을 보여 줍니다. 이 옵션은 각 데이터 요소의 크기 속성을 기준으로 선형 배율의 2픽셀, 크기는 0~40픽셀, 크기는 8입니다.&nbsp;</p>\n\n<pre>\nvar earthquakeLayer = new atlas.layer.BubbleLayer(dataSource, null, {\n     radius: [&#39;interpolate&#39;, [&#39;linear&#39;], [&#39;get&#39;, &#39;magnitude&#39;],\n         0, 2,\n         8, 40\n     ]\n});</pre>\n\n<p>각 원의 색을 정의하고 다음과 같은 맵을 생성하는 유사한 데이터 기반 스타일을 적용할 수도 있습니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fa840646-ce65-45f5-9b1f-06e5d75d75bb.png\"><img alt=\"Data driven map style\" border=\"0\" height=\"915\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/beb6bc70-7317-4e54-9d83-3b7be650a4bb.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"데이터 기반 지도 스타일\" width=\"1601\"></a></p>\n\n<p><a href=\"https://aka.ms/am_earthquakesample\" target=\"_blank\">라이브 예제</a>를 참조하세요.</p>\n\n<h2>공간 수학 라이브러리</h2>\n\n<p>많은 맵 애플리케이션에서 일반적으로 필요한 유용한 계산 컬렉션을 제공하는 새 공간 수학 라이브러리가 <strong>atlas.math</strong> 네임스페이스에 추가되었습니다. 일부 기능은 다음을 계산하는 기능을 제공합니다.</p>\n\n<ul>\n <li>위치 간 직선 거리입니다.</li>\n <li>선 또는 경로의 길이입니다.</li>\n <li>위치 사이의 제목입니다.</li>\n <li>거리 변환.</li>\n <li>카디널 스플라인은 일련의 점 간에 부드러운 곡선 경로를 계산할 수 있도록 합니다.</li>\n <li>지구 곡률을 고려하여 두 점 사이의 직접 경로인 측지 경로입니다.</li>\n <li>경로를 따라 중간 위치입니다.</li>\n</ul>\n\n<p><a href=\"https://aka.ms/am_spatialmathsample\" target=\"_blank\">라이브 예제</a>를 참조하세요.</p>\n\n<p>이 라이브러리는 일반적인 여러 간단한 공간 계산을 제공합니다. 기하 도형 합집합 또는 교집합과 같은 고급 공간 계산이 필요한 경우 <a href=\"https://github.com/Turfjs/turf\" target=\"_blank\">오픈 소스 Turf.js 라이브러리가</a> 유용할 수 있습니다. Turf.js Azure 지도 모든 벡터 데이터의 기본 형식인 GeoJSON 데이터와 직접 작동하도록 설계되어 Azure 지도 쉽게 사용할 수 있습니다.</p>\n\n<h2>지리적으로 정확한 원 지원</h2>\n\n<p>GeoJSON 스키마는 지리적으로 정확한 원을 정의하는 표준화된 방법을 제공하지 않습니다. 이러한 이유로 Azure 지도 팀은 <a href=\"https://docs.microsoft.com/en-us/azure/azure-maps/extend-geojson\" target=\"_blank\">설명서</a>와 같이 스키마를 중단하지 않고 GeoJSON에서 지리적으로 정확한 원을 정의하는 일반적인 방법을 표준화했습니다. Azure 지도 웹 컨트롤에서 순수 JSON을 사용하거나<strong> atlas.data</strong> 네임스페이스의 도우미 클래스를 사용하여 GeoJSON 개체를 정의할 수 있습니다. 다음은 시애틀에서 반경 1,000미터로 원을 정의하는 방법의 예입니다.</p>\n\n<p><strong>순수 JSON 사용</strong></p>\n\n<pre>\nvar circle = {\n     &quot;type&quot;: &quot;Feature&quot;,\n     &quot;geometry&quot;: {\n         &quot;type&quot;: &quot;Point&quot;,\n         &quot;coordinates&quot;: [-122.33, 47.6]\n     },\n     &quot;properties&quot;: {\n         &quot;subType&quot;: &quot;Circle&quot;,\n         &quot;radius&quot;: 1000\n     }\n};</pre>\n\n<p><strong>atlas.data 네임스페이스에서 도우미 클래스 사용</strong></p>\n\n<pre>\nvar circle = new atlas.data.Feature(new atlas.data.Point([-122.33, 47.6]), {\n     subType: &quot;Circle&quot;,\n     radius: 1000\n});</pre>\n\n<p>이러한 원을 렌더링할 때 Azure 지도 웹 컨트롤은 이 점 기능을 여러 렌더링 계층에서 사용할 수 있는 원형 다각형으로 변환합니다. 다음은 원형이 채워진 다각형으로 렌더링되는 맵입니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d2d894ae-5ed2-49f4-8bf3-3e06ac07c58a.png\"><img alt=\"Map of Seattle\" border=\"0\" height=\"779\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/52ab75ca-1774-4b9b-825b-07e784b1f71c.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"시애틀 지도\" width=\"1595\"></a></p>\n\n<p><a href=\"https://aka.ms/am_basicgeocirclesample\" target=\"_blank\">라이브 예제</a>를 참조하세요.</p>\n\n<p>BubbleLayer에서 생성된 지리적으로 정확한 원과 원 간의 한 가지 주요 차이점은 거품형 계층이 각 거품에 대해 픽셀 반경을 할당한다는 것입니다. 사용자가 지도를 확대/축소하면 픽셀 반경이 변경되지 않으므로&rsquo; 거품으로 덮인 지도 영역이 변경됩니다. 지리적으로 정확한 원에는 지도의 좌표로 제한된 꼭짓점이 있습니다. 지도를 확대/축소하면 원의 크기가 조정되고 덮어지는 영역이 유지됩니다.</p>\n\n<p>지도에서 사용하는 메르카토르 프로젝션으로 인해 이러한 원이 항상 원형으로 표시되지는 않을 수도 있습니다. 사실, 동그라미가 북극이나 남극에 가까울수록 더 크고 타원형으로 나타날 수 있지만, 지구상에서 나타내는 영역은 원형이다. 다음 지도는 반경이 750KM(750,000미터)인 두 개의 원을 보여 줍니다. 한 원은 북극에 가까운 그린란드 위로 렌더링되고 다른 원은 적도에 가까운 브라질을 통해 렌더링됩니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/a008a03d-02bc-41a3-8ef4-f942b11a4076.png\"><img alt=\"Azure Maps Geocircle example\" border=\"0\" height=\"600\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/21c30fa4-b00f-4316-ada7-9e893647a2d3.png\" style=\"border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"Azure 지도 Geocircle 예제\" width=\"800\"></a></p>\n\n<p><a href=\"https://aka.ms/am_geocirclesample\" target=\"_blank\">라이브 예제</a>를 참조하세요.</p>\n\n<h2>이전 버전과의 호환성</h2>\n\n<p>Azure 지도 앱을 이미 개발한 경우 전체 애플리케이션을 다시 작성해야 하는지 자문해 볼 수 있습니다. 그렇지 않을 것입니다. 이전 버전과의 호환성을 유지하기 위해 열심히 노력했습니다. 개발자가 향후 애플리케이션에서 이러한 기능을 사용하지 못하도록 하기 위해 설명서에서 이전 기능 중 상당수가 사용되지 않는 것으로 표시했지만, SDK 버전 1에 있는 것처럼 이러한 기능을 계속 지원할 것입니다.</p>\n\n<p>이 모든 것은 지도 컨트롤을 사용할 때 중요한 단계를 건너뛴 몇 가지 애플리케이션을 만났습니다. 맵 컨트롤의 인스턴스가 만들어지면 Web-GL 캔버스와 같은 여러 리소스를 로드해야 합니다. 이는 상당히 빠르게 발생하지만 비동기적으로 발생합니다. 즉, 맵 인스턴스를 만든 후 다음 코드 줄이 맵 로드를 완료하기 전에 호출될 수 있습니다. 해당 코드 줄이 로드되기 전에 맵과 상호 작용하려고 하면 오류가 발생할 수 있습니다. 이 &ldquo;문제를 해결하려면 로드&rdquo; 이벤트를 맵에 연결해야 하며, 맵이 로드된 후 실행해야 하는 기능을 이벤트의 콜백에 추가해야 합니다. 현재 맵&rsquo; 로드 이벤트를 사용하지 않는&rsquo; 경우 애플리케이션이 대부분의 시간 동안 제대로 작동할 수 있지만 다른 사용자&rsquo; 디바이스에서는 작동하지 않을 수 있습니다. 다음은 문제 및 해결 방법을 보여 주는 몇 가지 코드입니다.</p>\n\n<p><strong>문제점</strong></p>\n\n<pre>\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;, {\n     &#39;subscription-key&#39;: &#39;Your Azure Maps Key&#39;\n});\n\n//Additional code that interacts with the map. The map may not be finished loading yet.</pre>\n\n<p><strong>이전 API 인터페이스를 사용한 해결(계속 지원됨)</strong></p>\n\n<pre>\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;, {\n     &#39;subscription-key&#39;: &#39;Your Azure Maps Key&#39;\n});\n\n//Wait until the map resources have fully loaded.\nmap.addEventListener(&quot;load&quot;, function (e) {\n     //Add your additional code that interacts with the map here.\n});</pre>\n\n<p><strong>새 API 인터페이스를 사용한 해결</strong></p>\n\n<pre>\n//Add your Azure Maps subscription key to the map SDK.\natlas.setSubscriptionKey(&#39;Your Azure Maps Key&#39;);\n\n//Initialize a map instance.\nvar map = new atlas.Map(&#39;myMap&#39;);\n\n//Wait until the map resources have fully loaded.\nmap.events.add(&#39;load&#39;, function (e) {\n     //Add your additional code that interacts with the map here.\n});</pre>\n\n<h2>사용자의 의견을 듣고 싶습니다!</h2>\n\n<p>우리는 항상 Azure 지도 플랫폼을 성장시키고 개선하기 위해 노력하고 있으며 사용자 의견을 듣고 싶습니다.</p>\n\n<ul>\n <li>기능 요청이 있나요? <a href=\"https://feedback.azure.com/forums/909172-azure-maps\" target=\"_blank\">피드백 사이트에서</a> 요청을 추가하거나 투표합니다.</li>\n <li>지도 데이터 문제가 발견되었습니다. <a href=\"https://www.tomtom.com/mapshare/tools/\" target=\"_blank\">TomToms&rsquo; Map Share Reporter 도구를</a> 사용하여 데이터 공급자에게 직접 보냅니다.</li>\n <li>코드를 작동하는 데 문제가 있나요? Azure 블로그에서 다루고 싶은 주제가 있나요? <a href=\"https://stackoverflow.com/questions/tagged/azure-maps\" target=\"_blank\">Azure 지도 포럼</a>에 문의하세요. &rsquo;Azure 지도 플랫폼을 최대한 활용하려면 여기를 참조하세요.</li>\n <li>코드 샘플을 찾고 있거나 공유하려는 유용한 샘플을 작성하시겠습니까? <a href=\"https://github.com/Azure-Samples/AzureMapsCodeSamples\" target=\"_blank\">GitHub</a> 참여하세요.</li>\n</ul>"
