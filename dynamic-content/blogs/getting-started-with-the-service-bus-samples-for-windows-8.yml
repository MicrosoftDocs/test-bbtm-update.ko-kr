### YamlMime:Yaml
ms.openlocfilehash: 7ed2c3f75abb9d16413b0f363aa93cb3747bcefb
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139906780"
Slug: getting-started-with-the-service-bus-samples-for-windows-8
Title: Windows 8 대한 Service Bus 샘플 시작
Summary: Windows 8 대한 azure Toolkit Windows 일환으로 최근에 Windows 8 메트로 스타일 애플리케이션에서 Service Bus 액세스하는 샘플 라이브러리와 방법을 보여주는 샘플 메트로 앱을 출시했습니다.
Content: "<p><a href=\"https://watwindows8.codeplex.com/\" target=\"_blank\">Windows 8 azure Toolkit Windows</a> 일환으로, 최근 Windows 8 메트로 스타일 애플리케이션에서 Service Bus 액세스하기 위한 샘플 라이브러리와 몇 가지 기본 Service Bus 기능을 사용하는 방법을 보여주는 샘플 메트로 앱을 출시했습니다. 이 게시물에서는 샘플 앱을 빠르게 둘러보고, 샘플 라이브러리를 소개하고, 샘플 라이브러리의 작동 방식을 자세히 살펴보겠습니다.</p>  <h3><b>Service Bus 샘플 브라우저 for Windows 8</b></h3>  <p>정말 쉽게 시작할 수 있도록 하기 위해 Windows 8 위한 Service Bus 샘플 브라우저를 빌드했습니다. 이 간단한 지하철 스타일 애플리케이션을 사용하면 서비스 버스 기능에 대해 대화형으로 탐색하고 배울 수 있으며 항상 코드에 가깝게 유지할 수 있습니다.</p>  <p>모든 샘플에서 샘플 브라우저에서 AppBar를 가져오면(마우스로 마우스 오른쪽 단추를 클릭하거나 터치로 아래쪽 베젤에서 위로 살짝 밀기) Visual Studio 사용할 수 있도록 샘플에서 클립보드로 소스 코드를 복사할 수 있습니다.</p>  <p>샘플 브라우저를 시작하면 다음 세 가지 간단한 샘플이 포함됩니다.</p>  <p><b>단순 큐</b><br>Service Bus 큐는 분산 애플리케이션 또는 구성 요소 간의 통신을 허용하는 지속형 First In, First Out 메시지 큐입니다. <a href=\"https://azure.microsoft.com/en-us/develop/net/how-to-guides/service-bus-queues/\" target=\"_blank\">WindowsAzure.com Service Bus 큐에 대해 자세히 알아볼</a> 수 있습니다. 큐를 사용하는 패턴은 간단합니다. 다른 사용자가 큐에 메시지를 보내고, 다른 사람이 나중에 메시지를 받습니다.</p>  <p><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3617.ServiceBusSamples1.png\" alt=\"\" border=\"0\"></p>  <p>단순 큐 샘플에서는 Windows 8 메트로 스타일 애플리케이션 내에서 이 메시징 패턴을 사용하는 방법에 대한 간단한 예제를 따를 수 있습니다.&nbsp;</p>  <p><b>간단한 항목</b><br>Service Bus 토픽 및 구독은 게시/구독 통신 모델을 지원합니다. 메시지는 단일 토픽으로 전송된 다음 여러 구독자가 받을 수 있습니다. <a href=\"https://azure.microsoft.com/en-us/develop/net/how-to-guides/service-bus-topics/\" target=\"_blank\">WindowsAzure.com Service Bus 항목에 대해 자세히 알아볼</a> 수 있습니다. 토픽을 사용하는 것은 큐를 사용하는 것만큼 간단합니다. 누군가가 토픽에 메시지를 보내고 각 구독자는 나중에 해당 메시지의 복사본을 받을 수 있습니다.</p>  <p><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8831.ServiceBusSamples2.png\" alt=\"\" border=\"0\">&nbsp;</p>  <p>간단한 항목 샘플에서는 토픽을 만들고 하나 이상의 구독자를 추가한 다음 메시지를 보내고 받습니다.<b></b></p>  <p><b>잠금 피킹, 중단 및 완료</b><br>큐와 구독 모두 메시지를 받는 다양한 방법을 지원합니다. 첫 번째 수신 및 삭제는 수신 시 큐 또는 구독에서 메시지를 제거합니다. 수신자가 메시지를 처리하지 못하면 해당 콘텐츠가 손실됩니다. 두 번째 피킹 잠금은 수신 및 삭제 작업을 두 개의 별도 작업으로 만듭니다. 먼저 수신자가 큐에서 메시지를 피킹하고, 나중에 수신자가 메시지를 완료(큐 또는 구독에서 삭제하고 처리됨으로 표시)하거나 메시지를 중단(완료되지 않았거나 처리되지 않은 것으로 표시)할 수 있습니다. 피킹 잠금 시간이 중단된 경우 메시지가 큐 또는 구독에 반환됩니다(기본적으로 미리 보기 잠금 시간 제한은 30초임).</p>  <p>잠금 피킹 샘플에서는 잠금을 미리 봅니다. 각 셰이프를 클릭하여 큐로 보낸 다음 수신을 시도합니다. 셰이프를 받은 경우 해당 셰이프를 선택하여 메시지를 완료하거나 중단합니다. 완료된 메시지는 큐로 돌아가지 않지만 중단된 메시지는 큐로 돌아오지 않습니다. 메시지를 완료하거나 중단하지 않으면 잠금이 만료되고 큐에 자동으로 반환되는 것을 확인할 수 있습니다.&nbsp;</p>  <h3><b>Windows 8 샘플 Service Bus 라이브러리 - Microsoft.Samples.ServiceBus</b></h3>  <p>시작하려면 <a href=\"https://watwindows8.codeplex.com/\" target=\"_blank\">Windows 8 Windows Azure Toolkit</a> 다운로드합니다.</p>  <p>Service Bus REST API를 더 쉽게 사용할 수 있도록 큐, 토픽 및 구독과 같은 일반적인 Service Bus 기본 형식을 래핑하는 Windows 8 위한 샘플 라이브러리를 빌드했습니다. 큐 만들기, 메시지 보내기, 메시지 수신 및 큐 삭제를 보여 줄 수 있는 몇 가지 코드로 바로 살펴보겠습니다. Service Bus 접하는 경우 Service Bus <a href=\"https://azure.microsoft.com/en-us/develop/net/how-to-guides/service-bus-queues/\" target=\"_blank\">큐 및 Service Bus</a> 항목에 대한 이러한 방법 문서를 살펴보<a href=\"https://azure.microsoft.com/en-us/develop/net/how-to-guides/service-bus-topics/\" target=\"_blank\">세요</a>.</p>  <p>HTTP를 통해 Service Bus 호출하므로 다음 몇 가지를 고려해야 합니다.</p>  <ol>  <li><b>패키지 매니페스트에서 인터넷(클라이언트) 기능을 요청합니다</b>. Service Bus 인터넷에 있으므로 애플리케이션에 네트워크에 액세스할 수 있는 권한이 있는지 확인해야 합니다.</li>  <li><b>네트워크에 대한 호출은 항상 비동기여야 합니다</b>. 네트워크 호출을 완료하는 데 약간의 시간이 걸릴 수 있으므로 항상 비동기 IO를 사용해야 합니다. 샘플 Service Bus 라이브러리는 모든 작업에 간단한 비동기 메서드를 노출하여 도움을 줍니다.&nbsp;</li>  </ol>  <p>먼저 토큰 공급자가 필요합니다. 토큰 공급자는 라이브러리에서 ACS(Access Control Service)에서 권한 부여 토큰을 요청하고 해당 토큰을 Service Bus 요청에 연결하는 데 사용됩니다. 토큰 공급자를 자격 증명 집합처럼 생각할 수 있습니다. 'who'가 Service Bus 리소스에서 작업을 수행하려고 하는 것을 지정합니다.&nbsp;</p>  <p><span style=\"color: #008000;\">TokenProvider</span> tokenProvider = <span style=\"color: #008000;\">TokenProvider</span>. CreateSharedSecretTokenProvider(<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serviceNamespace: <span style=\"color: #993300;\">\"Service Bus 네임스페이스 이름(예: contoso)\"</span>,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; issuerName: <span style=\"color: #993300;\">\"owner\"</span>,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;issuerSecret:<span style=\"color: #993300;\"> \"Service Bus 발급자 비밀, 예: b66Gxx...\"</span>);</p>  <p>다음으로 큐를 만듭니다. 이 매우 간단한 호출은 만들 큐의 경로를 지정하고 기본 큐 설명을 사용합니다. 만드는 큐의 설정을 조정하려는 경우 큐 설명을 매개 변수로 수락하는 유용한 오버로드를 찾을 수 있습니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #008000;\">Queue</span> myQueue = <span style=\"color: #0000ff;\">await</span> <span style=\"color: #008000;\">Queue</span>. CreateAsync(<span style=\"color: #993300;\">\"MyQueue\"</span>, tokenProvider);</p>  <p>Service Bus 만든 큐를 사용하여 계속 진행하여 메시지를 보낼 수 있습니다. 샘플 라이브러리를 사용하면 본문이 JSON 형식의 개체인 일반 텍스트 메시지 또는 메시지를 간단하게 보낼 수 있습니다. 여기서는 메시지 본문으로 일반 텍스트 문자열을 비동기적으로 보내려고 합니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #0000ff;\">await</span> myQueue.SendAsync(<span style=\"color: #993300;\">\"Hello World!\"</span>);</p>  <p>메시지 수신은 간단합니다. 수신 및 삭제 의미 체계를 사용하여 큐에서 수신을 시도합니다. Peek Lock 의미 체계를 사용하려는 경우 PeekLockAsync 메서드가 근처에 있습니다. 메시지를 받은 후에는 일반 텍스트 본문을 추출합니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #008000;\">BrokeredMessage</span> 메시지 = <span style=\"color: #0000ff;\">await</span> myQueue.ReceiveAndDeleteAsync();<br><span style=\"color: #0000ff;\">string</span> greeting = message. <span style=\"color: #0000ff;\">GetBodystring</span>&gt;&lt;();</p>  <p>마지막으로, 스스로 정리하고 큐를 삭제하겠습니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #008000;\">awaitQueue</span>&nbsp;. DeleteAsync(<span style=\"color: #993300;\">\"MyQueue\"</span>, tokenProvider);&nbsp;</p>  <p>따라서 Service Bus 엔터티를 만들고, 보내고, 받고, 삭제하는 몇 줄의 코드만 있습니다. Windows 8 샘플 Service Bus 라이브러리에서는 시작할 간단한 API 노출 영역과 원하는 경우 REST API 표면의 모든 기능을 사용할 수 있도록 노력했습니다. 이 라이브러리를 오픈 소스 라이선스 샘플로 제공하므로 원하는 경우 코드를 자세히 알아보고 심층적으로 코드를 조정할 수 있는 자유와 유연성을 제공합니다.&nbsp;</p>  <p>Windows 8 샘플 Service Bus 라이브러리의 간소화된 API 표면을 통해 Service Bus 연결된 훌륭한 Metro Style Apps 빌드를 쉽게 시작할 수 있기를 바랍니다. 일반적인 시나리오를 달성하기 위해 익숙해져야 하는 총 개념 수를 줄이고 필요에 따라 고급 기능에 대해 더 쉽게 알아볼 수 있도록 노력했습니다.  항상 이 샘플 라이브러리가 얼마나 유용한지에 대한 피드백을 듣고자 합니다. <a href=\"https://watwindows8.codeplex.com/\" target=\"_blank\">Windows 8 Azure Toolkit Windows</a> 대한 토론 목록에 의견을 알려주세요.</p>  <h3><b>자세히 보기: Windows 8 샘플 Service Bus 라이브러리 작동 방식</b></h3>  <p>Service Bus 작업은 관리 또는 런타임이라는 두 가지 클래스 중 하나에 속합니다. 관리 작업은 큐, 토픽 및 구독과 같은 Service Bus 엔터티 만들기, 열거, 가져오기 및 삭제에 사용됩니다. 런타임 작업은 메시지를 보내고 받는 데 사용됩니다. 먼저 Windows 8 샘플 Service Bus 라이브러리에서 관리 작업을 구현하는 방법을 자세히 살펴본 다음 런타임 작업이 구현되는 방법을 살펴보겠습니다.</p>  <p><b>관리 작업: 만들기, 가져오기, 열거 및 삭제</b><br>Service Bus 네임스페이스는 ATOM 피드 집합으로 간주될 수 있으며, 각 항목은 그 아래 경로에 있는 엔터티를 설명합니다. 예를 들어 Uri <a href=\"https://contoso.servicebus.windows.net/Foo\" target=\"_blank\">https://contoso.servicebus.windows.net/Foo</a> 에 'Foo'라는 큐가 있는 경우 해당 주소에서 다음과 같은 원자 항목을 찾을 수 있습니다.</p>  <p>&nbsp;<img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1778.ServiceBusSampleCode.png\" alt=\"\" border=\"0\"></p>  <p>태그를 빠르게 살펴보면 큐 주소(줄 3), 큐 이름(줄 4) 및 여기에 있는 큐에 대한 설명(줄 12-25)이 표시됩니다. 이 패턴은 네임스페이스 전체에서 true입니다. 모든 엔터티는 Atom 항목에 래핑된 XML 엔터티 설명으로 표시됩니다.</p>  <p>Service Bus 엔터티 관리는 HTTPS를 통해 Service Bus 네임스페이스 내에서 이러한 피드에 대한 RESTful 작업을 수행하여 수행됩니다. HTTP <b>PUT</b>을 발급하는 엔터티를 만들려면 HTTP <b>GET</b> 을 발급하는 엔터티를 가져오고 HTTP <b>DELETE</b>를 발급하는 엔터티를 삭제합니다. 열거형은 네임스페이스의 루트(예: <b>/$Resources/Queues</b>)에서 예약된 <b>$Resources</b> 컬렉션 내에서 HTTP <b>GET</b>을 실행하여 수행됩니다.</p>  <p>만들 수 있는 엔터티 및 하위 엔터티의 각 형식은 리소스 설명의 계층 구조에 표시됩니다. 여기에는 친숙한 큐, 토픽 및 구독 설명 및 규칙 설명, 규칙 필터 및 규칙 작업과 같은 고급 엔터티가 포함됩니다.</p>  <p><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6253.ServiceBusSamples3.png\" alt=\"\" border=\"0\"></p>  <p>리소스 설명 형식은 Service Bus 엔터티를 나타내는 Atom 항목의 콘텐츠를 캡슐화합니다. XML로 직렬화되고( <a href=\"https://msdn.microsoft.com/en-us/library/system.runtime.serialization.datacontractserializer.aspx\" target=\"_blank\">DataContractSerializer</a> 사용) Atom 항목에 래핑된 경우 이러한 형식을 사용하여 Service Bus에서 엔터티를 만들고, 삭제하고, 나열하고, 나타낼 수 있습니다.</p>  <p>Windows 8 샘플 Service Bus 라이브러리 내에서 리소스 설명은 <b>AsSyndicationItem()</b> 메서드를 호출하여 Atom 항목으로 표현될 수 있습니다. <a href=\"https://msdn.microsoft.com/en-us/library/system.servicemodel.syndication.syndicationitem.aspx\" target=\"_blank\">SyndicationItem</a> 형식은 RSS 및 ATOM 피드 둘 다에서 작동하는 클래스를 제공하는 <a href=\"https://msdn.microsoft.com/en-us/library/system.servicemodel.syndication.aspx\" target=\"_blank\">System.ServiceModel.Syndication</a> 네임스페이스 내에 있습니다. 마찬가지로 정적 <b>ResourceDescription.CreateT&lt;&gt;(SyndicationItem)</b> 메서드를 사용하고 예상 리소스 형식을 형식 매개 변수 T(예: <b>T</b>는 <b>QueueDescription</b>일 수 있음)로 지정하여 Atom Entry에서 리소스 설명을 추출 <b></b> 할 수 있습니다.&nbsp;</p>  <p>다양한 Service Bus 엔터티(<b>ResourceDescriptions</b>)에 대한 설명을 모델링하는 방법과 해당 설명을 Atom(<b>ResourceDescription.AsSyndicationItem()</b> 및 <b>ResourceDescription.CreateT&lt;&gt;(SyndicationItem 항목)</b> 메서드 사용)로 변환하는 방법을 이해하면 만들기, 가져오기, 나열 및 삭제 작업이 구현되는 방식을 확인할 준비가 잘 되어 있습니다. 큐를 사용하여 관리 작업이 구현되는 방법을 검사하지만 토픽, 구독 및 규칙에 대한 논리는 매우 유사합니다.</p>  <p>큐 만들기를 살펴보겠습니다.&nbsp;</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #008000;\">Queue</span> myQueue = <span style=\"color: #0000ff;\">await</span> <span style=\"color: #008000;\">Queue</span>. CreateAsync(<span style=\"color: #993300;\">\"Foo\"</span>, tokenProvider);&nbsp;</p>  <p><b>Queue.CreateAsync</b>를 호출할 때 다음 작업을 수행합니다.</p>  <ol>  <li><b>QueueDescription</b> 인스턴스를 만들고 <b>경로로 \"Foo\"</b>를 지정합니다.</li>  <li><b>tokenProvider</b>에 지정된 Service Bus 네임스페이스에 대한 <b>NamespaceManager</b>를 만듭니다.</li>  <li><b>NamespaceManager</b>가 지정된 <b>QueueDescription</b>을 사용하여 새 큐를 만들게 요청합니다.</li>  <li><b>NamespaceManager</b> 내에서 <b>AsSyndicationItem()</b>을 호출하여 <b>Atom</b>에서 <b>QueueDescription</b>을 래핑합니다.</li>  <li><b>SyndicationClient</b>가 지정된 <b>SyndicationItem</b>을 사용하여 새 리소스를 만들게 요청합니다.</li>  <li><b>SyndicationClient</b>는 <b>TokenProvider</b>를 사용하여 <b>권한 부여 토큰</b>을 요청합니다.</li>  <li><b>SyndicationClient</b>는 <b>SyndicationItem</b>을 본문으로 사용하고 <b>권한 부여 토큰</b>을 헤더로 사용하여 <b>HTTP PUT</b>을 발급합니다.</li>  <li><b>HTTP 응답</b>은 <b>SyndicationClient</b>에 의해 <b>SyndicationItem</b>으로 읽고 로드됩니다.</li>  <li><b>SyndicationItem</b>이 <b>NamespaceManager</b>에 반환됩니다.</li>  <li><b>NamespaceManager</b>는 <b>SyndicationItem</b>의 <b>콘텐츠를</b> <b>QueueDescription으로 추출합니다.</b></li>  <li><b>QueueDescription</b>은 호출하는 <b>Queue.CreateAsync</b> 메서드로 반환됩니다.</li>  <li><b>새로 만든</b> <b>QueueDescription</b>을 캡슐화하기 위해 큐의 인스턴스가 만들어집니다.</li>  </ol>  <p><b>큐</b>, <b>NamespaceManager</b> 및 <b>SyndicationClient</b>를 각각 원래 의도에 정보 계층을 추가하여 요청을 Service Bus에 전달하기 전에 foo라는 큐를 만들도록 시각화할 수 있습니다.</p>  <p><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1616.ServiceBusSamples4.png\" alt=\"\" border=\"0\">&nbsp;</p>  <p><b>큐는 큐</b>의 설명을 캡슐화하는 편리한 클래스이며 한 곳에서 보내기/받기와 같은 작업도 캡슐화합니다. <b>큐</b> 형식은 <b>NamespaceManager</b>를 사용하여 Service Bus 네임스페이스에서 엔터티 만들기, 나열, 가져오기 및 삭제합니다. <b>NamespaceManager</b>는 <b>SyndicationClient</b>를 사용하여 HTTP 호출을 만들기 전에 HTTP 요청을 발급해야 하는 전체 URI를 파악하고(<b>ServiceBusEnvironment</b> 사용) 리소스 설명을 Atom에서 래핑합니다(<b>AsSyndicationItem</b> 메서드 사용). <b>SyndicationClient</b>는 권한 부여 토큰을 가져오고(<b>TokenProvider</b> 사용) HTTP 호출(<b>HTTPClient</b> 사용)을 담당합니다.&nbsp;</p>  <p>모든 관리 작업은 동일한 방식으로 수행됩니다. 먼저 큐, 토픽 또는 구독과 같은 상위 수준의 추상화에 대해 실행되고, Atom으로의 주소 지정 및 변환을 위해 네임스페이스 관리자에 전달된 다음, 배포 클라이언트가 서비스 버스에 대해 실제 원시 HTTP 요청을 수행하도록 처리합니다.</p>  <p><b>런타임 작업: 보내기, 받기, 잠금 피킹, 중단 및 완료</b><br>HTTP를 통해 메시지를 보내고 받는 것은 정말 간단합니다. 메시지를 보내려면 큐 또는 토픽의 'messages' 컬렉션에 HTTP POST를 실행하고 수신(수신 및 삭제 모드)하려면 큐 또는 구독의 'messages' 컬렉션의 머리에 HTTP DELETE를 실행합니다. 피킹 잠금은 유사하게 메시지 컬렉션의&nbsp; 머리에 HTTP POST를 실행하여 피킹 잠금을 만듭니다. 메시지를 중단하기 위해 잠금 위치에 HTTP PUT을 실행하고 잠금 위치에 HTTP DELETE를 실행합니다.</p>  <p>Service Bus 메시지에는 헤더(예: 보낸 시간, 메시지 ID 및 TTL), 사용자가 지정한 메시지 속성 및 본문이 있습니다. HTTP를 통해 헤더는 <b>BrokerProperties</b>라는 예약된 HTTP 헤더에서 JSON 형식 구조체로 캡슐화됩니다. 사용자 지정 메시지 속성은 일반 HTTP 헤더로 캡슐화되고 Service Bus 메시지의 본문은 HTTP 메시지의 본문이라고 추측했습니다.&nbsp; 큐에 메시지를 보내는 것은 해당 큐에서 <b>SendAsync</b> 를 호출하는 것만큼 간단합니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #0000ff;\">await</span> myQueue.SendAsync(<span style=\"color: #993300;\">\"Hello, World!\"</span>);&nbsp;</p>  <p>이 메시지를 보내기 위한 HTTP 추적을 살펴보고 다음과 같은 모양을 더 잘 파악해 보겠습니다.</p>  <p style=\"padding-left: 30px;\"><b>POST</b> <a href=\"https://contoso.servicebus.windows.net/Foo/Messages%20HTTP/1.1\">https://contoso.servicebus.windows.net/Foo/Messages HTTP/1.1</a><br><b>호스트</b>: contoso.servicebus.windows.net<br><b>권한 부여</b>: WRAP access_token=\"...\"<br><b>Content-Type</b>: text/plain<br><b>콘텐츠 길이</b>: 13</p>  <p>Hello, World!</p>  <p>메시지 수신은 마찬가지로 간단합니다. 이번에는 큐의 머리에서 수신 및 삭제합니다.</p>  <p style=\"padding-left: 30px;\"><span style=\"color: #008000;\">BrokeredMessage</span> 메시지 = <span style=\"color: #0000ff;\">await</span> myQueue.ReceiveAndDeleteAsync();</p>  <p>그리고 다음은 corresponsing HTTP 요청 및 응답 추적입니다.</p>  <p style=\"padding-left: 30px;\"><b>삭제</b> <a href=\"https://contoso.servicebus.windows.net/Foo/Messages/Head?timeout=30\">https://contoso.servicebus.windows.net/Foo/Messages/Head?timeout=30</a> HTTP/1.1<br><b>호스트</b>: contoso.servicebus.windows.net<br><b>권한 부여</b>: WRAP access_token=\"...\"<br><b>콘텐츠 길이</b>: 0</p>  <p style=\"padding-left: 30px;\">-</p>  <p style=\"padding-left: 30px;\"><b>HTTP/1.1 200 OK</b><br><b>Transfer-Encoding</b>: 청크<br><b>Content-Type</b>: text/plain<br><b>서버</b>: Microsoft-HTTPAPI/2.0<br><b>BrokerProperties</b>: {\"DeliveryCount\":1,\"MessageId\":\"62a7eceab7eb4d52ac741af5f44393ce\",\"SequenceNumber\":1,\"TimeToLive\":922337203685.47754}<br><b>날짜</b>: 2015년 8월 4일 월요일 16:23:42 GMT</p>  <p style=\"padding-left: 30px;\">Hello, World!</p>  <p>여기에서 HTTP를 통한 Service Bus 메시지의 간단한 형식을 확인하고 <b>BrokerProperties</b> 헤더에서 사용할 수 있는 메타데이터 중 일부를 식별하기 시작할 수 있습니다. Windows 8 샘플 Service Bus 라이브러리 내에서 <b>BrokeredMessage</b> 형식은 Service Bus 메시지, 헤더, 속성 및 본문에 대한 캡슐화로 사용됩니다. SendAsync 호출이 실제로 작동하는 방식을 살펴보겠습니다.</p>  <ol>  <li><b>SendAsync(string &hellip;) </b>는 일반 텍스트 서비스 버스 메시지를 보내야 함을 나타내는 호출됩니다.</li>  <li>새 <b>BrokeredMessage</b>가 생성되고 메시지 본문을 <b>Stream</b>에 씁니다.</li>  <li>큐는 새로 생성된 메시지를 사용하여 <b>MessageSender</b>에서 <b>SendAsync(BrokeredMessage)</b>를 호출합니다.</li>  <li><b>MessageSender</b>는 <b>TokenProvider</b>를 사용하여 <b>권한 부여 토큰</b>을 요청합니다.</li>  <li><b>MessageSender</b>는 BrokeredMessage의 BodyStream을 본문으로 지정하는 <b>HTTP POST</b>를 발급합니다.</li>  <li><b>BrokerProperties</b>, 사용자 지정 메시지 속성 및 <b>권한 부여</b> <b>헤더</b>를 포함한 HTTP 헤더가 요청에 추가됩니다.</li>  <li><b>HTTP 응답</b>이 확인(200) 상태 코드를 확인합니다.</li>  </ol>  <p>또한 메시지 발신자는 JSON으로 직렬화하여 메시지 본문으로 더 복잡한 형식을 보낼 수 있도록 지원합니다. <b>MessageReceiver</b>는 큐 또는 구독에서 메시지를 받는 데 비슷한 방식으로 사용됩니다.</p>  <p>Windows 8 샘플 Service Bus 라이브러리의 빠른 회오리바람 투어를 통해 시작할 수 있는 몇 가지 포인터가 제공되기를 바랍니다. 라이브러리에 대한 피드백을 듣고 빌드한 멋진 연결된 앱을 확인하게 되어 매우 기쁩니다. Windows <a href=\"https://watwindows8.codeplex.com/\">Azure Toolkit</a> Windows 8 대한 토론 목록에 있는 내용을 알려주세요.</p>"
