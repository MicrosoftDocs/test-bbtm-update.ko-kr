### YamlMime:Yaml
ms.openlocfilehash: 92271c31f73fd3a57c4de8284f5df07aa3ac213e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911074"
Slug: creating-a-data-stream-from-nist-manufacturing-lab-data-part-1
Title: NIST 제조 랩 데이터에서 데이터 스트림 만들기 - 1부
Summary: 산업 환경 팀은 최근 기존 IoT 데이터에서 인사이트를 추출하기 위한 솔루션 가이드를 게시했습니다. 솔루션은 다음과 같은 상위 수준 구성 요소로 구성됩니다.
Content: >-
  <p>산업 환경 팀은 최근 기존 IoT 데이터에서 인사이트를 추출하기 위한 <a href="https://docs.microsoft.com/azure/industry/manufacturing/extracting-insights-from-iot-data?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">솔루션 가이드</a> 를 게시했습니다. 솔루션은 다음과 같은 상위 수준 구성 요소로 구성됩니다.</p>


  <ul>
   <li>데이터 수집</li>
   <li>핫 경로 처리</li>
   <li>콜드 경로 처리</li>
   <li>분석 클라이언트</li>
  </ul>


  <p>이러한 구성 요소를 자세히 설명하는 일련의 블로그 중 첫 번째입니다. 먼저 솔루션에 데이터를 수집하고 데이터 스트림을 만듭니다.</p>


  <h2>NIST 데이터</h2>


  <p>이 솔루션은 제조 랩&rsquo; 데이터를 노출하는 미국 국립 표준 및 기술 스마트 제조 시스템 테스트 베드에서 게시한 데이터를 사용합니다. 랩&#39;<a href="https://smstestbed.nist.gov/vds" target="_blank">VDS(휘발성 데이터 스트림)의 데이터를</a> 사용합니다.</p>


  <p>VDS는 MTConnect 표준을 사용하여 구현됩니다. 이 표준은 제조 장비에 대한 의미 체계 어휘를 제공합니다. MTConnect 에이전트 및 반환된 데이터에 대한 스키마와 통신하는 프로토콜을 정의합니다.</p>


  <h2>에이전트 및 해당 메서드</h2>


  <p>에이전트는 다음 API 작업을 지원하는 HTTP 엔드포인트를 노출합니다.</p>


  <ul>
   <li><a href="https://smstestbed.nist.gov/vds/probe" target="_blank">프로브</a>: 디바이스, 구성 요소, 하위 구성 요소 및 데이터 항목의 목록을 반환합니다.</li>
   <li><a href="https://smstestbed.nist.gov/vds/current" target="_blank">current</a>: 데이터 항목의 스냅샷을 특정 시점에&#39;최신 값 또는 디바이스 상태를 반환합니다.</li>
   <li><a href="https://smstestbed.nist.gov/vds/sample" target="_blank">샘플</a>: 시계열의 샘플, 이벤트 및 조건을 반환합니다.</li>
   <li><a href="https://smstestbed.nist.gov/vds/asset" target="_blank">asset</a>: 이 디바이스에 알려진 자산의 최신 상태입니다.</li>
  </ul>


  <p>이 솔루션에 대한 프로토콜 흐름의 예는 다음과 같습니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3c44cc84-b7e3-4b46-b5ab-bc08c512f67b.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures" border="0" height="457" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/32b7cfd4-42bc-493c-a282-4a21d326031c.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT 데이터에서 Insights 추출 - 솔루션 가이드 그림" width="517"></a></p>


  <p>솔루션은 VDS 엔드포인트를 폴링해야 합니다. 데이터 스트림을 받으면 데이터 스트림의 데이터 레코드를 이름 값 쌍으로 Azure Event Hubs에 게시할 수 있습니다. 그런 다음 다른 쪽 끝의 스트림 처리 기술로 스트림을 처리할 수 있습니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b9d1e1ff-5b8c-4dd7-ba1a-799387b8df1d.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 2" border="0" height="305" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/efbe2f85-6e89-4d11-87ea-30276ad4133f.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT 데이터에서 Insights 추출 - 솔루션 가이드 그림 2" width="703"></a></p>


  <h2>수집 구성 요소</h2>


  <p>수집 구성 요소는 다음 작업을 수행합니다.</p>


  <ul>
   <li>VDS 엔드포인트를 폴링합니다.</li>
   <li>원시 응답을 AZURE Blob Storage에 XML로 저장합니다.</li>
   <li>계층적 XML 결과를 이름-값 쌍 및 타임스탬프를 사용하여 플랫 데이터 레코드 구조로 변환합니다.</li>
   <li>각 레코드를 Azure Event Hub에 게시합니다. 각 메시지 유형에 대해 다른 이벤트 허브가 사용됩니다.</li>
  </ul>


  <p>수집 구성 요소를 구현하기 위한 많은 Azure 서비스 옵션이 있습니다. 다음 모든 서비스는 HTTP 엔드포인트를 폴링하고, 원시 데이터를 중간 스토리지 솔루션에 저장하고, 변환된 데이터를 Azure Event Hubs에 게시할 수 있습니다.</p>


  <ul>
   <li><a href="https://docs.microsoft.com/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a></li>
   <li>실행 중인 사용자 지정 코드 <ul>
    <li><a href="https://docs.microsoft.com/azure/aks/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Kubernetes Service</a></li>
    <li><a href="https://docs.microsoft.com/azure/app-service/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">App Service</a></li>
    <li><a href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Container Instances</a></li>
    <li><a href="https://docs.microsoft.com/azure/virtual-machines/windows/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Virtual Machines</a></li>
    <li><a href="https://docs.microsoft.com/azure/service-fabric/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Service Fabric</a></li>
    <li><a href="https://docs.microsoft.com/azure/azure-functions/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">함수</a></li>
   </ul>
   </li>
  </ul>


  <p>매우 간단한 워크플로를 쉽게 설정하고, VDS 엔드포인트에 대해 몇 가지 HTTP 호출을 수행하고, 필요한 REST 작업을 호출하고, 예약된 간격 동안 폴링을 계속하기 때문에 <a href="https://docs.microsoft.com/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a> 사용하도록 선택했습니다. Azure Logic Apps 데이터로 작업을 수행하기 위해 200개 이상의 <a href="https://docs.microsoft.com/azure/connectors/apis-list?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">커넥터</a>를 제공합니다. 데이터 저장소에 원시 응답을 저장하려고 하므로 <a href="https://docs.microsoft.com/azure/connectors/connectors-create-api-azureblobstorage?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Blob Storage 커넥터</a>가 가장 쉬운 솔루션입니다.</p>


  <p>두 개의 작업이 남아 있습니다. 구성 요소는 XML 페이로드를 플랫 데이터 레코드 구조로 변환하고 결과를 <a href="https://docs.microsoft.com/azure/event-hubs/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Event Hubs</a>에 게시해야 합니다.</p>


  <p>응답 데이터는 MTConnectStreams 문서 형식으로 지정됩니다. <a href="https://github.com/mtconnect/schema" target="_blank">다양한 MTConnect 문서에 대한 XSD 스키마</a>를 찾습니다. 결과 문서&rsquo; <a href="https://github.com/mtconnect/schema/blob/master/MTConnectStreams_1.3_1.0.xsd" target="_blank">스키마</a> 를 자세히 살펴보면 다형성이 문서에서 광범위하게 사용됨을 알 수 있습니다. 예를 들어 이름 온도가 있는 요소는 XML 기능 <a href="https://www.w3.org/TR/xmlschema-0/#SubsGroups" target="_blank">대체 그룹을</a> 사용하여 다형성 <a href="https://github.com/mtconnect/schema/blob/master/MTConnectStreams_1.3_1.0.xsd#L1437" target="_blank">TemperatureType</a> 형식입니다.</p>


  <p>Logic Apps용 <a href="https://docs.microsoft.com/azure/logic-apps/logic-apps-enterprise-integration-transform?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Transform XML</a> 커넥터가 있습니다. 이 커넥터를 간단히 살펴보면 <a href="https://docs.microsoft.com/en-us/azure/logic-apps/logic-apps-enterprise-integration-overview?WT.mc_id=iotinsightsblog2-blog-ercenk" target="_blank">Enterprise 통합 팩</a>을 사용하여 맵을 개발할 필요가 있음을 알 수 있습니다. 맵을 개발할 수 있지만 해당 작업은 사용자 지정 코드와 동일한 작업을 수행하는 것과 비교할 때 많은 노력이 필요할 수 있습니다.</p>


  <p>나는 재미있는 코딩 주말 중 하나 동안 <a href="https://github.com/Ercenk/MTConnect.Client" target="_blank">MTConnect 클라이언트</a> 를 개발했다. 구성 요소는 POCO(Plain Old CLR Object) 클래스를 사용합니다. 클래스는 Visual Studio s xsd.exe&rsquo; 도구를 사용하여 생성되었습니다. 생성된 코드는 다형 XML을 직렬화 해제할 수 없지만 성공하도록 수정하는 것은 쉽습니다. 다형<a href="https://github.com/Ercenk/MTConnect.Client/blob/master/src/MTConnect.Client/Client/Schemas/MTConnectStreams_1_3_1_0.cs#L385" target="_blank">성 생성 클래스</a>에 <a href="https://docs.microsoft.com/dotnet/api/system.xml.serialization.xmlincludeattribute?redirectedfrom=MSDN&amp;view=netframework-4.7.2" target="_blank">XmlIncludeAttribute</a>를 적용하기만 하면 됩니다.</p>


  <p>다음 두 작업을 분리했습니다. VDS 엔드포인트를 폴링하고 원시 데이터를 저장한 다음 변환한 다음, 결과를 이벤트 허브에 게시합니다. 이러한 디자인은 결과를 구문 분석하고 변환하는 더 복잡한 작업을 개발, 디버그 및 유지 관리하는 데 도움이 되는 더 쉬운 환경으로 이동합니다. 결과 디자인은 두 개의 마이크로 서비스로 구성됩니다. 첫 번째는 Azure Logic Apps 서비스에서 관리하는 논리 앱으로 개발됩니다. 두 번째 사용자 지정 코드는 <a href="https://docs.microsoft.com/azure/container-instances/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Container Instances</a> 서비스에 배포됩니다. 두 마이크로 서비스 간의 통신에 Storage 큐를 사용합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3e540a1c-23d9-4535-b7ca-e29b540fdcfa.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 3" border="0" height="376" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/83c8fb7d-accd-4f9b-9cea-0e9cb52cb8e6.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT 데이터에서 Insights 추출 - 솔루션 가이드 그림 3" width="919"></a></p>


  <h2>논리 앱 구현</h2>


  <p>구성 요소의 논리 앱 부분의 전체 구현을 진행하는 데는 많은 공간과 반복이 필요할 수 있습니다. 나는 여분의주의가 필요한 부분만 강조 할 것이다. 구현은 다음 순서도를 따릅니다. 전체 소스 코드는 <a href="https://github.com/MSIndustryExperiences/IoTInsights/blob/master/ingest/poll/src/logicapp.json" target="_blank">GitHub</a> 찾을 수 있습니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2d9e4625-f20a-46ad-8f83-a0ee674ac1c1.jpg"><img alt="Extracting Insights from IoT Data - Solution Guide Figures 4" border="0" height="529" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/dee33a69-1d49-459f-8fd1-cd76014d1b81.jpg" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="IoT 데이터에서 Insights 추출 - 솔루션 가이드 그림 4" width="443"></a></p>


  <p>Logic Apps는 <a href="https://docs.microsoft.com/azure/logic-apps/logic-apps-workflow-definition-language?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">워크플로 정의 언어</a>에 포함된 JSON 및 XML을 직렬화 해제 및 직렬화하는 데 기본 제공 함수를 사용할 수 있습니다. 원시 결과는 스토리지 요구 사항을 최적화하기 위해 JSON으로 저장됩니다. 동일한 데이터의 JSON 표현은 공간을 적게 사용합니다. XML 태그는 더 자세한 정보입니다. 현재 및 샘플 요청의 결과는 다음 수식을 사용하여 변수에 저장됩니다. 워크플로 편집에 GUI를 사용하는 경우 첫 번째 줄을 사용할 수 있습니다. 코드 보기에서 편집하려면 인터프리터가 작동할 수 있도록 함수가 @로 시작하는지 확인합니다.</p>


  <pre>

  json(replace(string(json(xml(trim(body(&#39;Current&#39;))))), &#39;&quot;@&#39;, &#39;&quot;&#39;))


  &quot;value&quot;: &quot;@json(replace(string(json(xml(trim(body(&#39;Current&#39;))))), &#39;\&quot;@&#39;, &#39;\&quot;&#39;))&quot;</pre>


  <p>먼저 XML을 직렬화 해제한 다음 결과를 JSON으로 직렬화하는 것이 중요합니다. 이 작업은 특성 이름이 문자 앞에 추가된 JSON 문자열을 &ldquo;@&rdquo; 만듭니다. 활동&nbsp; 은 JSON을 문자열로 변환합니다. &ldquo;@&rdquo; 결과를 제거하고 새 JSON을 만듭니다.</p>


  <p>원래 XML은 다음과 같습니다.</p>


  <pre>

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

  &lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;/styles/Streams.xsl&quot;?&gt;

  &lt;MTConnectStreams xmlns:m=&quot;urn:mtconnect.org:MTConnectStreams:1.3&quot; xmlns=&quot;urn:mtconnect.org:MTConnectStreams:1.3&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xmlns:x=&quot;urn:nist.gov:NistStreams:1.3&quot; xsi:schemaLocation=&quot;urn:nist.gov:NistStreams:1.3 /schemas/NistStreams_1.3.xsd&quot;&gt;
     &lt;Header creationTime=&quot;2018-08-24T22:02:06Z&quot; sender=&quot;5c182aaf5077&quot; instanceId=&quot;1535115106&quot; version=&quot;1.3.0.18&quot; bufferSize=&quot;1048576&quot; nextSequence=&quot;438473124&quot; firstSequence=&quot;437424548&quot; lastSequence=&quot;438473123&quot;/&gt;
     &lt;Streams&gt;
       &lt;DeviceStream name=&quot;GFAgie01&quot; uuid=&quot;mtc_adapter001&quot;&gt;
         &lt;ComponentStream component=&quot;Device&quot; name=&quot;GFAgie01&quot; componentId=&quot;GFAgie01&quot;&gt;
           &lt;Events&gt;
             &lt;Availability dataItemId=&quot;GFAgie01-dtop_1&quot; timestamp=&quot;2018-08-24T22:02:06.397326&quot; name=&quot;avail&quot; sequence=&quot;438473077&quot;&gt;UNAVAILABLE&lt;/Availability&gt;
             &lt;EmergencyStop dataItemId=&quot;GFAgie01-dtop_2&quot; timestamp=&quot;2018-08-24T22:02:06.397970&quot; name=&quot;estop&quot; sequence=&quot;438473086&quot;&gt;UNAVAILABLE&lt;/EmergencyStop&gt;
             &lt;AssetChanged dataItemId=&quot;GFAgie01_asset_chg&quot; timestamp=&quot;2018-08-24T22:02:06.390521&quot; sequence=&quot;438472999&quot; assetType=&quot;&quot;&gt;UNAVAILABLE&lt;/AssetChanged&gt;</pre>

  <p>그리고 문자가 &ldquo;@&rdquo; 제거되지 않으면 JSON은 다음과 같습니다.</p>


  <pre>

  {
       &quot;?xml&quot;: {
           &quot;@version&quot;: &quot;1.0&quot;,
           &quot;@encoding&quot;: &quot;UTF-8&quot;
       },
       &quot;?xml-stylesheet&quot;: &quot;type=\&quot;text/xsl\&quot; href=\&quot;/styles/Streams.xsl\&quot;&quot;,
       &quot;MTConnectStreams&quot;: {
           &quot;@xmlns:m&quot;: &quot;urn:mtconnect.org:MTConnectStreams:1.3&quot;,
           &quot;@xmlns&quot;: &quot;urn:mtconnect.org:MTConnectStreams:1.3&quot;,
           &quot;@xmlns:xsi&quot;: &quot;https://www.w3.org/2001/XMLSchema-instance&quot;,
           &quot;@xmlns:x&quot;: &quot;urn:nist.gov:NistStreams:1.3&quot;,
           &quot;@xsi:schemaLocation&quot;: &quot;urn:nist.gov:NistStreams:1.3 /schemas/NistStreams_1.3.xsd&quot;,
           &quot;Header&quot;: {
               &quot;@creationTime&quot;: &quot;2018-08-24T22:02:06Z&quot;,
               &quot;@sender&quot;: &quot;5c182aaf5077&quot;,
               &quot;@instanceId&quot;: &quot;1535115106&quot;,</pre>

  <p>결과를 JSON으로 변환하면 firstSequence 및 lastSequence에 대한 특성 값에 액세스할 수도 있습니다.</p>


  <pre>

  &quot;value&quot;: &quot;@int(variables(&#39;CurrentResult&#39;).MTConnectStreams.Header.firstSequence)&quot;


  Then I can plug in the values to the query parameter of the sample request.


  &quot;Sample&quot;: {
     &quot;type&quot;: &quot;Http&quot;,
     &quot;inputs&quot;: {
       &quot;method&quot;: &quot;GET&quot;,
       &quot;uri&quot;: &quot;<a href="https://smstestbed.nist.gov/vds/sample?from=@{variables('NextSequence')}&quot;">https://smstestbed.nist.gov/vds/sample?from=@{variables(&#39;NextSequence&#39;)}&quot;</a>
     },
     &quot;runAfter&quot;: {
       &quot;Delay&quot;: [
         &quot;Succeeded&quot;
       ]
     }
  },</pre>


  <p>각 프로브 요청이 성공적으로 수신되면 워크플로는 Azure Blob Storage Blob에 결과를 저장합니다. 그런 다음 저장된 Blob의 URL을 사용하여 Storage 큐에 메시지를 넣습니다. 그러면 다른 마이크로 서비스에 데이터 레코드를 변환하고 후속 Event Hubs에 게시하도록 알립니다.</p>


  <h2>다음 단계</h2>


  <ul>
   <li>자세한 내용은 <a href="https://docs.microsoft.com/en-us/azure/logic-apps/?WT.mc_id=iotinsightsblog2-acomblog-ercenk" target="_blank">Azure Logic Apps</a> 설명서를 확인하세요.</li>
   <li><a href="https://github.com/MSIndustryExperiences/IoTInsights" target="_blank">샘플 리포지토리</a> 복제</li>
   <li><a href="https://na01.safelinks.protection.outlook.com/?url=https%3A%2F%2Fazure.microsoft.com%2Fblog%2Fingesting-a-data-stream-from-nist-manufacturing-lab-data-part-2%2F%3FWT.mc_id%3Diotinsightsblog2-acomblog-ercenk&amp;data=02%7C01%7Cv-cabas%40microsoft.com%7Ccfdc6e0fe56a45aebea408d6347d532f%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636754110201149265&amp;sdata=zUuVx3845UgjkMamiH1MHxORcQkp24A8j9zPrrfdxsc%3D&amp;reserved=0" target="_blank">NIST 제조 랩 데이터에서 데이터 스트림 수집 읽기 -</a> 마이크로 서비스 간 통신 구현 및 두 번째 마이크로 서비스의 구현 세부 정보에 대한 2부</li>
  </ul>
