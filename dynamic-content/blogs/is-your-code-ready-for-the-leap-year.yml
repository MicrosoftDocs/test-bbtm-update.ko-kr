### YamlMime:Yaml
ms.openlocfilehash: 77891dd01f95e9a08cae963c98e5c06f7a1ee224
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139910962"
Slug: is-your-code-ready-for-the-leap-year
Title: 코드가 윤년을 맞이할 준비가 됐나요?
Summary: 2016년은 윤년이며, 이는 버그를 방지하기 위해 신중하게 코딩되지 않은 소프트웨어 애플리케이션에 문제가 있음을 의미할 수 있습니다. 경계해야 하는 버그 유형과 윤년이 과거 Azure 및 기타 소프트웨어에 미치는 영향을 자세히 알아봅니다.
Content: "<p>2월에 들어서면 2016년이 <strong>윤년</strong>이라는 것을 기억하기에 좋은 시기입니다. 대부분의 사람들에 대 한, 이것은 단지 흥미로운 이상한 수 있습니다.; 일하거나 놀 수있는 여분의 하루. 그러나 소프트웨어 개발자에게 윤년은 상당한 고통을 야기할 수 있습니다.</p> <p><em>이제 코드</em>에서 윤년 버그를 확인하는 것을 고려하고 있다면 빠르게 이동하는 것이 좋습니다. 사실, 당신은 <em>이미 </em>효과를 경험하고 심지어 그것을 실현하지 않을 수 있습니다! 코드에 어떤 종류의 버그가 숨어 있을 수 있나요?</p> <ul> <li>특히 날짜 범위 쿼리를 사용한 데이터 필터링과 관련된 일대일 문제  <li>사용자 인터페이스에서 예기치 않거나 원치 않는 동작  <li>에지 사례가 발생할 때 예외, 충돌 또는 중단 가능성이 있습니다. </li></ul> <p>\"메,\" 당신은 말한다. \"내 코드는 괜찮습니다. 단위 테스트가 있습니다.\"</p> <p>\"아, 정말.\" 나는 말한다. \"테스트가 시계를 제대로 조롱합니까? 2월 29일과 12월 31일을 포함한 에지 사례를 테스트합니까? 시스템의 나머지 부분뿐만 아니라 가질 수 있는 하위 수준 C++ 코드를 테스트했나요? 윤년 버그가 어떤 모습인지도 알고 계십니까?\"</p> <p>대부분 빈 응시.</p> <h1>Azure에서 이 문제가 중요한 이유는 무엇인가요?</h1> <p>실제로 개발자가 작성할 수 있는 코드에만 적용되며, 많은 코드가 Azure 클라우드에서 실행될 수 있습니다. Azure는 <a href=\"https://azure.microsoft.com/en-us/blog/summary-of-windows-azure-service-disruption-on-feb-29th-2012/\" target=\"_blank\">2012년에 자체적으로 윤년 가동 중단</a>을 겪었으며, 이번에는 원활한 환경을 보장하기 위해 열심히 노력해 왔습니다. 우리는 모든 고객이 그 이후로 우리의 연구와 경험을 활용하기를 것입니다.</p> <h1>좋아, 그래서 내가 알아야 할 것은 무엇입니까?</h1> <p>여기서 다루어야 할 것이 많기 때문에 먼저 가장 중요한 것부터 시작해 보겠습니다.</p> <ul> <li><strong>2월 29</strong> 일은 윤년의 영향을 받는 유일한 날이 아닙니다. 또 다른 매우 중요한 날짜는 <strong>12월 31</strong>일입니다. 이는 올해의 366번째 날이며 많은 애플리케이션이 실수로 1년 365일로 하드 코딩하기 때문입니다.  <ul> <li>클라우드에 대한 특별한 고려 사항으로, 대부분의 클라우드 애플리케이션이 UTC(협정 세계시)를 사용하거나 적어도 반드시 사용해야 한다고 가정합니다. 즉, 2월 29일 자정에 현지 표준 시간대의 다른 시간이 될 수 있습니다. 예를 들어 미국 태평양 표준 시간대에서 윤일은 2월 28일 오후 4시(달력의 전날)인 경우 UTC에 도달합니다. <a href=\"https://www.timeanddate.com/worldclock/fixedtime.html?msg=Leap+Day+in+Universal+Time&amp;iso=20160229T00\" target=\"_blank\">다른 표준 시간대의 시간을 확인합니다</a>.  <li>윤일 문제에 대해 실시간으로 시스템을 모니터링할 준비를 하고 있는 경우 2월 28일부터 3월 1일까지 3일간의 기간을 고려해야 합니다. 마찬가지로 12월 30일부터 1월 1일까지 366일차 이슈를 주의해야 합니다. </li></ul> <li>윤년 버그는 모든 언어로 어디에서나 찾을 수 있지만 C/C++ 코드에서 가장 위험하며, 여기서 애플리케이션 충돌 또는 버퍼 오버플로(보안 위험)가 발생할 수 있습니다.  <li>지난 윤년 동안 다음과 같은 몇 가지 영향력이 큰 유명 버그가 포함되어 있습니다.  <ul> <li><a href=\"https://azure.microsoft.com/en-us/blog/summary-of-windows-azure-service-disruption-on-feb-29th-2012/\">2012년 Microsoft Azure 중단</a>: 인증서 만료 날짜를 잘못 계산하여 최대 12시간 동안 서비스 중단이 발생했습니다.  <li><a href=\"https://www.bbc.com/news/technology-17599701\">2012 TomTom GPS 탐색 버그</a>: 많은 모델이 현재 위치를 식별하지 못하게 했습니다.  <li><a href=\"https://www.nbcnews.com/id/35646131/ns/technology_and_science-games/t/leap-year-glitch-fixed-sony-playstation\">2010 소니 플레이 스테이션 네트워크 중단</a>: 윤년으로 2010의 오인으로 인해 발생  <li><a href=\"https://www.theguardian.com/technology/blog/2009/jan/01/zune-firmware-mistake\">모든 Microsoft Zune 디바이스의 2008년 벽돌 만들기: 12</a>월 31일 논리 오류로 인해 발생  <li><a href=\"https://blogs.technet.com/b/exchange/archive/2008/02/29/3405004.aspx\" target=\"_blank\">2008 Microsoft Exchange 관리 버그</a>: 관리자가 2월 29일에 많은 작업을 수행하지 못하도록 방지  <li>Lotus 1-2-3의 1900년의 오산은 30년이 지난 지금도 오늘날 Microsoft Excel 영향을 미칩니다! </li></ul></li></ul> <p>이들은 뉴스 헤드 라인을 만든 단지 큰 이야기입니다. 나는 영향과 눈에 띄는 다양한 각도로 수천 더 발생 확신합니다. <a href=\"https://catless.ncl.ac.uk/Risks/18.74.html#subj5\">1996년의 또 다른 덜 알려진 윤년 버그</a>로 인해 뉴질랜드와 태즈메이니아의 알루미늄 제련 공장의 공정 제어 시스템이 12월 31일 자정(366일)에 갑자기 문을 닫았습니다.</p> <p>이로 인해 용융 금속의 온도가 규제되지 않게 되면서 장비에 수백만 달러의 피해가 발생했습니다. 이 같은 지난 해의 이야기는 소프트웨어 결함의 실제 위험을 생각 나게한다. IOT의 최근 광범위한 채택과 클라우드 컴퓨팅과의 교집합을 고려할 때, 우리는 모두 높은 경고를 받아야 합니다.</p> <h1>가장 위험한 윤년 버그 2개</h1> <h3>#1: C/C++에서 연도 추가 또는 빼기</h3> <p>Win32 API를 사용하는 C/C++ 코드에서 <a href=\"https://msdn.microsoft.com/library/windows/desktop/ms724950.aspx\" target=\"_blank\"><font face=\"Courier New\">SYSTEMTIME</font></a> 구조는 시민 시간의 일반적인 표현입니다. 날짜의 각 부분에 대해 연도, 월, 일 값(및 기타)을 구분하는 고유 필드가 있습니다. 다음 코드를 보는 것은 매우 일반적입니다.</p><pre class=\"prettyprint\">SYSTEMTIME st;       // declare a SYSTEMTIME variable \nGetSystemTime(&amp;st);  // set it to the current date and time \nst.wYear++;          // increment it by one year \n</pre>\n<p>이 코드는 오류 없이 성공합니다. 그러나 코드가 2월 29일에 호출되면 결과 값은 2월 29일 <em>이지만 윤년이 아닌 연도에</em> 있을 수 있습니다. 예를 들어 존재하지 <code>2016-02-29 + 1 year = 2017-02-29</code>않습니다.</p>\n<p>이 값은 최종적으로 <a href=\"https://msdn.microsoft.com/library/windows/desktop/ms724948.aspx\" target=\"_blank\"><font face=\"Courier New\">SystemTimeToFileTime</font></a>과 같은 다른 함수에 대한 매개 변수로 끝나기 전에 꽤 많이 전달될 수 있습니다. 그러면 함수가 반환 값 0으로 실패하게 됩니다. 아쉽게도 <em>반환 값을 확인하지 않고</em> 이 메서드를 사용하는 코드를 찾는 것이 <em>매우 </em>일반적입니다. 이렇게 하면 초기화되지 않은 상태로 값을 남기 <code>FILETIME</code> 는 등 예측할 수 없는 결과가 발생할 수 있습니다.</p>\n<ul>\n<li>Win32 함수의 상태 결과, 특히 <code>SystemTimeToFileTime</code>항상 확인합니다. \n<li>결과의 유효성을 확인하고 필요한 경우 조정하여 연도 <code>SYSTEMTIME</code> 를 올바르게 추가합니다. </li></ul><pre class=\"prettyprint\">SYSTEMTIME st;       // declare a SYSTEMTIME variable \nGetSystemTime(&amp;st);  // set it to the current date and time \nst.wYear++;          // increment it by one year \n\n윤년 부울 도약 = st.wYear % 4 == 0 &amp;&amp; (st.wYear % 100 != 0 || st.wYear % 400 == 0)인지 확인합니다. \n\n2월 29일이지만 윤년이 아닌 경우 2월 28일 st.wDay = st.wMonth == 2 st.wDay == 29 &amp;&amp; &amp;&amp; !leap ? 28 : st.wDay; </pre>\n<p>표준 C++(비 Windows) 코드에서도 비슷한 버그가 발생할 수 있습니다. 구조체는 <code>tm</code> 약간 다른 동작을 <code>SYSTEMTIME</code>가지는 대신 사용됩니다. 월은 1-12가 아닌 0-11이므로 2월은 1개월입니다. 대신 <code>SystemTimeToFileTime</code>구조를 생성 <code>time_t</code> 하도록 호출 <code>_mkgmtime</code> 할 수 있습니다. 하지만 주요 차이점은 실패하는 대신 윤년이 아닌 2월 29일을 통과하면 3월 1일을 나타내는 값을 생성한다는 것입니다. 애플리케이션은 2월 28일을 예상할 수 있으며, 이 경우 조정해야 합니다.</p>\n<h3>#2: 연중 각 날짜에 대한 값 배열 선언</h3><pre class=\"prettyprint\">int items[365];\nitems[dayOfYear - 1] = x;\n</pre>\n<p>위의 C 코드는 C# 또는 다른 언어로 쉽게 다시 작성하거나 정수 대신 문자열 또는 다른 데이터 형식을 사용할 수 있습니다. 핵심은 데이터를 저장할 고정 크기 배열을 선언하고 연중 매일 배열에 위치가 있다고 가정하는 것입니다. 문제는 물론 윤년에는 12월 31일 366일의 배열에 자리가 없다는 것입니다.</p>\n<p>이 것의 효과 언어에 따라 상당히 다양 합니다. C#에서 이 경우 <code>IndexOutOfRangeException</code>. C에서는 경계 검사 컴파일러 옵션을 사용하지 않는 한 <a href=\"https://en.wikipedia.org/wiki/Buffer_overflow\" target=\"_blank\">버퍼 오버플로</a>가 생성되며, 그 효과는 무시할 수 있거나 <em>상당할 수 있습니다</em>. JavaScript 개발자는 366번째 요소가 자동으로 추가되므로 이러한 측면에서 걱정할 필요가 없습니다.</p>\n<h1>데이터 필터링 문제</h1>\n<p>전년도 2월 28일부터 다음 해 3월 1일까지 데이터에 영향을 줄 수 있는 윤년 버그의 다른 영향이 있습니다. 일반적으로 이러한 항목은 <em>데이터 필터링</em>에 있습니다. 여기서 범위 쿼리는 추가 일을 고려하지 않습니다. 1년이 항상 365일이라고 가정하거나 2월이 항상 28일이라고 가정합니다. 다음과 같은 SQL 문을 고려합니다.</p><pre class=\"prettyprint\">SELECT AVG(Total) as AverageOrder, SUM(Total) as GrandTotal\nFROM Orders WHERE OrderDate &gt;= @startdate AND OrderDate &lt; @enddate\n</pre>\n<p>이 쿼리는 괜찮지만 오늘로 설정되고 오늘 <code>@startdate</code> -365일로 설정된 경우 <code>@enddate</code> 어떻게 되는지 고려합니다. 범위가 2월 29일 윤일을 포함하는 경우 1년 내내 포함되지 않습니다. 시작 날짜가 1일 짧으므로 1년 분량의 데이터를 나타내려는 의도가 실제로 있다고 가정하면 값이 올바르지 않습니다.</p>\n<p>이와 같은 버그를 평가할 때 버그의 <em>영향이</em> 무엇인지 자문해 보세요. 이 경우 이러한 값은 어디에 표시됩니다. 예를 들어, 평균 주문 금액이 매일 업데이트되는 대시보드에서 차트를 제공하는 경우 SEC 제출과 같은 회사의 재무 보고서에 연도의 총 판매액이 나열되는 경우만큼 중요하지 않을 수 있습니다. 물론 이 평가에는 애플리케이션에 익숙한 사람이 필요하며 사용법입니다. 따라야 할 한 가지 크기의 모든 규칙이 없습니다.</p>\n<p>다음과 같은 접근 방식으로 이 문제를 해결하는 것이 좋습니다.</p><pre class=\"prettyprint\">TimeSpan oneYear = TimeSpan.FromDays(isLeapYear(endDate.Year) ? 366 : 365);\nDateTime startDate = endDate - oneYear;\n</pre>\n<p>그러나 이 방법은 결함이 있습니다. 연도만 평가하여 추가할 일 수를 결정할 수 없습니다. <code>endDate</code> <code>2016-01-01</code>2016년은 윤년이지만 365<code>2015-01-01</code>일밖에 되지 않습니다. 대신 2월 29일 윤일이 범위에 포함되는지 여부를 고려해야 합니다. 이는 특히 1년이 아닌 여러 년을 처리하는 것을 고려할 때 손으로 수행하려는 경우 상당히 복잡한 코드로 이어집니다.</p>\n<p>궁극적으로 .NET(및 다른 언어의 유사한 형식)은 <em>절대 시간의</em> 표현이며 \"year\"와 \"month\"는 <em>모두 시민 시간의</em> 단위라는 사실에 <code>TimeSpan</code> 달려 있습니다. 1년 또는 1개월의 절대 시간은 설명하는 연도 또는 개월에 따라 <em>가변 </em>적입니다. 일광 절약 시간을 고려할 때 \"일\"에 대해 실제로도 마찬가지입니다.</p>\n<p>.NET에 대한 올바른 솔루션은 다음과 같습니다.</p><pre class=\"prettyprint\">DateTime startDate = endDate.AddYears(-1);</pre>\n<p>이 메서드는 <code>AddYears</code> 음수 값의 경우 앞으로 또는 뒤로 이동할 일 수를 결정하는 데 필요한 모든 논리를 올바르게 구현합니다.</p>\n<h1>JavaScript에서 연도 추가</h1>\n<p>JavaScript 개발자는 다음과 같이 간단한 <a href=\"https://momentjs.com\" target=\"_blank\">moment.js</a> 사용해야 합니다.</p><pre class=\"prettyprint\">var m = moment();\nm.add(1, 'years');\n</pre>\n<p>그러나 일부 사람들은 여전히 어려운 방식으로 작업을 수행하는 것을 좋아하기 때문에 종종 다음을 볼 수 있습니다.</p><pre class=\"prettyprint\">var d = new Date();\nd.setFullYear(d.getFullYear() + 1);\n</pre>\n<p>여기서 문제는 앞서 언급한 문제입니다. 오늘이 윤년의 2월 29일이면 결과 값은 3월 1일입니다. 그것은 당신에게 받아 들일 수도 있고 허용되지 않을 수도 있습니다. 다른 모든 날짜에 대해 결과가 원래 값과 동일한 달에 있는 것을 고려합니다. 또한 애플리케이션에서 월 시작 날짜 대신 월말 날짜를 예상할 수 있습니다.</p>\n<p>다음은 전체 라이브러리를 요구하지 않고 JavaScript에서 연도를 올바르게 추가하는 데 사용할 수 있는 함수입니다.</p><pre class=\"prettyprint\">function addYears(d, n) { \n  var m = d.getMonth(); \n  d.setFullYear(d.getFullYear() + n); \n  if (d.getMonth() !== m) \n  d.setDate(d.getDate() - 1); \n} \n\n// example usage \nvar d = new Date(); \naddYears(d, 1); \n</pre>\n<p>이 구현은 연도를 추가한 다음 3월로 롤오버가 발생했는지 여부를 확인하고, 그 경우 보정합니다. 다시 말하지만, 추가할 일 수를 정확히 파악하여 구현하지 마세요. 당신이 <em>정말로</em> 무엇을하고 있는지 알고하지 않는 한.</p>\n<h1>기타 일반적인 실수</h1>\n<p>개발자가 윤년과 관련하여 잘못 되는 다른 많은 것들이 있습니다. 예를 들면 다음과 같습니다.</p>\n<ul>\n<li>윤년 알고리즘을 엉망으로. 그것은 단지 4 년마다 아니다. 400으로 나눌 수 없다면 연도가 100으로 나눌 수 <em>없는 한</em> 4년마다입니다. 1900년은 윤년이 아니었습니다. 2000년은 윤년이었습니다. 2100은 윤년이 되지 않습니다. \n<li>매월 일의 배열을 사용합니다. 여기서 2월은 28일입니다. 이러한 배열을 사용하는 경우 윤년의 29일을 고려해야 합니다. 더 나은 방법은 윤년 동안 일반적인 연도와 <em>다른</em> 배열을 사용하는 것입니다. 또는 더 나은 아직, 당신이 가지고있는 API를 사용 (사용 가능한 경우) 대신 직접 수학을 수행하려고합니다. \n<li>윤년 동안 코드를 분기한 다음 모든 코드 경로를 테스트하지 않습니다. 예를 들어 <a href=\"https://www.theguardian.com/technology/blog/2009/jan/01/zune-firmware-mistake\">Zune 버그</a>의 코드는 맨 위에 <font face=\"Courier New\">IsleapYear(year)</font> 분기가 있으며, 이 분기는 테스트되지 않았습니다. \n<li>유효성을 검사하지 않고 별도의 연도, 월 및 일 값을 사용합니다. 예를 들어 각 구성 요소를 선택하는 별도의 드롭다운 컨트롤이 있는 UI가 있을 수 있습니다. 해당 날짜가 월 내에 유효한지 테스트하는 것만으로는 충분하지 않습니다. 또한 <em>연도</em>를 고려해야 합니다. \n<li>날짜 수학에서 365.25 또는 365.2425일과 같은 1 <em>년의 평균 길이</em>를 사용합니다. 이것은 과학적으로 정확할 수 있지만 시민 시간의 실제 조작에는 결코 적절하지 않습니다. 적어도 정확한 값에 관심이 있는 경우는 아닙니다. 근사치만 필요한 경우 괜찮지만, 연결된 하루 중 시간이 결과에서 꺼질 수 있습니다. </li></ul>\n<h1>윤년 버그를 catch하려면 어떻게 해야 하나요?</h1>\n<ul>\n<li>코드를 주의 깊게 조사합니다. 관련된 시간을 검색하고 미세 이빨 빗으로 그것을 통해 이동합니다.\n<li>단위 테스트가 많이 있는지 확인하고 \"시계를 모의\"하는 방법을 알고 있어야 합니다(다음 섹션에서 설명). \n<li>윤년 전뿐만 아니라 연중 내내 테스트합니다. \n<li><em>구성</em>을 포함하여 모든 입력의 유효성을 검사합니다. \n<li>결과의 유효성을 검사하고 시나리오를 완료합니다. 실패 전략을 가지고! </li></ul>\n<p>나는 종종 두 가지 다른 접근 방식에 대해 묻는다:</p>\n<h3>정적 코드 분석</h3>\n<p>윤년 버그가 있는 위치를 가리키는 코드에 대해 실행할 수 있는 도구 집합이 있다면 굉장할 것입니다. 불행히도, 나는 어떤 것을 모른다. 간단한 문자열 검색 또는 심지어 regex 검색은 지금까지만 얻을 수 있습니다.</p>\n<p>실제로 .NET에 필요한 것은 윤년, 표준 시간대, 일광 절약 시간, 구문 분석 등을 비롯한 일반적인 날짜/시간 버그를 catch할 수 있는 <a href=\"https://msdn.microsoft.com/en-us/library/mt162308.aspx\" target=\"_blank\">포괄적인 Roslyn 분석</a> 기 집합입니다. 아쉽게도 이러한 분석기를 직접 만들 시간이 없습니다. 어쩌면 나는 미래의 어느 시점에서 그것을 얻을 것이다, 그러나 그것은 오늘 존재하지 않습니다.</p>\n<p>C++, JavaScript 및 기타 언어에 대해 유사한 도구를 사용하는 것도 좋습니다. 나는 아무도 알지 못하지만.</p>\n<h3>시간 왜곡</h3>\n<p>왜 그냥 앞으로 시계를 이동하고 무슨 일이 일어나는지 볼 수 없습니다? 이는 실제로 일부 시스템에서 작동할 수 있지만 이 아이디어에는 몇 가지 문제가 있습니다.</p>\n<ul>\n<li>단위 테스트는 <em>여전히</em> 모든 항목을 catch하지 못할 수 있습니다. 전체 애플리케이션의 모든 화면과 보고서에서 실제로 (수동으로) 보지 않는 한 데이터 필터링 오류를 catch하지 못할 수 있습니다. 이것은 확실히 오류가 발생하기 쉽습니다. \n<li>모든 것이 괜찮다고 믿는 잘못된 보안 감각을 개발할 수 있습니다. 고객이 2월 29일 또는 3월 1일에 불만을 제기할 때만 자신이 얼마나 잘못되었는지 깨닫게 됩니다. \n<li>많은 시스템에서 도메인 서버를 사용하여 인증하거나 시간이 중요한 다른 인증 체계를 사용해야 합니다. <a href=\"https://en.wikipedia.org/wiki/Kerberos_(protocol\">Kerberos</a> 프로토콜에는 엄격한 시간 동기화 요구 사항이 있으며 기본 허용 오차는 5분임을 인식합니다. 또한 SSL 인증서, 코드 서명 인증서 및 기타 보안 관련 항목은 클록에 따라 달라지며 실제로 몇 시에 대해 거짓말을 하려고 하면 실패합니다. </li></ul>\n<p>그래서, 일반적으로, 나는이 접근 방식에 <em>대해</em> 권장합니다. 또는 적어도 가양성을 만들거나 특정 코드 경로가 테스트되지 않도록 방지할 수 있는 외부 리소스에 대한 종속성을 고려해야 합니다.</p>\n<h1>시계 모의</h1>\n<p>다른 날짜에 다르게 동작하는 코드를 테스트하려면 어떻게 해야 할까요? 시계를 모의!</p>\n<p>이는 많은 신뢰할 수 있는 시스템에서 발견되는 일반적인 패턴입니다(\"가상 시계\"와 같은 다른 이름으로도 알려짐). 핵심은 시스템 시계 - 알다시피, 그것이 몇 시간인지 알려주는 것은 우연히 사용되어서는 안된다는 것입니다. 애플리케이션 논리는 현재 날짜와 시간을 가져오기 위해 <code>DateTime.Now</code> <code>DateTime.UtcNow</code> <code>new Date()</code> 해당 언어에 해당하는 것을 직접 호출하거나 <code>GetSystemTime</code> 또는 해당 언어로 호출해서는 안 됩니다.</p>\n<p>대신, 시계를 <em>서비스</em> (DDD 의미)로 처리해야 하며, 모든 서비스와 마찬가지로 <em>모</em> 의할 수 있어야 합니다.</p>\n<p>예를 들어 .NET에서는 애플리케이션 논리에서 직접 호출 <code>DateTimeOffset.UtcNow</code> (또는 유사한 API)하는 대신 다음을 수행합니다.</p>\n<ul>\n<li>를 반환하는 메서드 <code>GetCurrentTime</code> 를 사용하여 인터페이스 <code>IClock</code> 를 만듭니다<code>DateTimeOffset</code>. \n<li><code>SystemClock</code> 에서 구현하는 클래스를 만듭니다. 여기서 <code>GetCurrentTime</code> 호출<code>DateTimeOffset.UtcNow</code>합니다<code>IClock</code>. \n<li><code>FakeClock</code> 고정 값을 생성자 매개 변수로 수락하고 <code>GetCurrentTime</code> 고정 값을 반환하는 구현 클래스<code>IClock</code>를 만듭니다. \n<li>애플리케이션 논리에서 인터페이스에만 의존합니다 <code>IClock</code> . 일반적으로 이것은 생성자가 주입됩니다. \n<li>테스트하는 동안 A를 <code>FakeClock</code> 사용하고 런타임에 <code>SystemClock</code> 연결합니다. </li></ul>\n<p>이것은 많은 일처럼 들릴 지 모르지만, 일단 움직임을 거치면 장점이 있는 곳을 볼 수 있습니다. 현재 날짜와 시간이 종속성일 때 모든 코드를 테스트할 수 있는 유일한 방법입니다.</p>\n<p>패턴이 여러 다른 언어에 대해 동일해야 하므로 의도적으로 여기에 대한 코드를 제공하지 않았습니다. 또한 메인 어셈블리 및 어셈블리 <code>FakeClock</code> 와 함께 <code>IClock</code> <code>SystemClock</code> 제공되는 <a href=\"https://nodatime.org\" target=\"_blank\">Noda Time</a>에는 이미 매우 훌륭한 구현이 <code>NodaTime.Testing</code> 있습니다. 당신은 이것에 대한 노다 시간을 사용하는 것이 좋습니다, 그리고 다른 많은 이유.</p>\n<p>JavaScript 개발자는 <a href=\"https://sinonjs.org/\" target=\"_blank\">Sinon.JS</a> 또는 <a href=\"https://github.com/boblauer/MockDate\" target=\"_blank\">MockDate</a>와 같은 라이브러리 또는 <a href=\"https://momentjs.com/docs/#/customization/now/\" target=\"_blank\">moment.js기본 제공 모의 지원을 </a>고려해야 합니다.</p>\n<p>다른 언어용 라이브러리에는 유사한 기능이 있을 수 있습니다. 집에서 재배한 구현을 시도하기 전에 해당 구현을 찾아야 합니다.</p>\n<h1>결론</h1>\n<p>윤년이 여기에 있습니다. Y2K 또는 <a href=\"https://en.wikipedia.org/wiki/Year_2038_problem\" target=\"_blank\">Y2038</a>은 아니지만 정기적으로 싸워야 합니다. 지난 4년 동안 얼마나 많은 코드를 작성했나요? 당신은 모든 파까지 확신? 이제 시간을 내어 코드를 테스트하고 검사합니다. 당신은 아마 당신이 몰랐던 몇 가지 그림자에 숨어 있었다 찾을 수 있습니다.</p>\n<p>질문이 있으세요? 여기에 의견을 남겨주세요 그리고 우리는 기꺼이 응답합니다.</p>\n<p><em>이 콘텐츠의 일부는 원래 <a href=\"https://codeofmatt.com/2016/01/01/happy-new-leap-year/\" target=\"_blank\">codeofmatt.com</a> 게시되었으며 사용 권한으로 다시 인쇄되었습니다.</em></p>"
