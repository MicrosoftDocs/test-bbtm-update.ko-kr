### YamlMime:Yaml
ms.openlocfilehash: e633f830754396cd460606d11c52504d40b4aa15
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139897700"
Slug: creating-primary-keys-across-databases
Title: 데이터베이스에서 기본 키 만들기
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 여러 SQL Azure 데이터베이스에서 데이터를 수평 분할하거나 SQL Azure 데이터 동기화 Server를 사용하는 경우 다음과 같은 경우가 있을 수 있습니다.'
Content: <p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>여러 SQL Azure 데이터베이스에서 데이터를 수평 분할하거나 SQL Azure 데이터 동기화 Server를 사용하는 경우 기본 키 병합 충돌을 일으키지 않고 멤버 데이터베이스에 작성해야 하는 경우가 있을 수 있습니다. 이 경우 모든 데이터베이스에서 고유한 기본 키를 생성할 수 있어야 합니다. 이 문서에서는 기본 키와 해당 장점 및 단점을 생성하는 다양한 기술에 대해 설명합니다.</p>  <h2>UniqueIdentifier</h2>  <p>고유한 기본 키를 생성하는 한 가지 방법은 Transact-SQL NEWID() 함수를 사용하는 것입니다. 이 함수는 <strong>GUID를 uniqueidentifier</strong> 데이터 형식으로 생성합니다. GUID는 모든 데이터베이스에서 고유하도록 보장됩니다.</p>  <p>장점</p>  <ul>   <li>SQL Azure 네이티브 형식입니다.</li>    <li>그것은 무한히 크고 당신은 GUID가 부족하지 않습니다</li>    <li>수평 분할 및 데이터 동기화 서비스에서 작동합니다.</li> </ul>  <p>단점은:</p>  <ul>   <li>이 기술을 사용할 때의 단점은 GUID를 기반으로 한다는 것입니다. 생성된 데이터베이스를 식별할 수 있는 방법은 없습니다. 이로 인해 수평 분할을 수행할 때 추가적인 복잡성이 발생할 수 있습니다.</li>    <li><strong>uniqueidentifier</strong> 데이터 형식은 크며 행 크기에 추가됩니다. </li> </ul>  <h2>Bigint </h2>  <p>또 다른 옵션은 <strong>int</strong> 대신 <b>bigint</b> 데이터 형식을 사용하는 것입니다. 이 기술에서 기본 키는 ID 열에서 생성됩니다. 그러나 각 데이터베이스의 각 ID는 다른 오프셋에서 시작합니다. 서로 다른 오프셋은 충돌하지 않는 기본 키를 만듭니다.</p>  <p>대부분의 사람들이 묻는 첫 번째 질문은 필요한 모든 기본 키를 나타낼 수 있을 만큼 큰 <b>데이터</b> 형식입니다. <b> bigInt</b> 데이터 형식은 8바이트 단위로 저장되므로 9,223,372,036,854,775,807만큼 클 수 있습니다. 이는 <b>int</b> 데이터 형식의 최대 크기인 2,147,483,647보다 4,294,967,298배 더 큰 값입니다. 즉, 40억 개의 SQL Azure 데이터베이스가 약 20억 행의 테이블로 수평 분할될 수 있습니다. 데이터 형식 및 크기에 대한 자세한 내용은 <a href="https://msdn.microsoft.com/en-us/library/ms187745.aspx">여기에서</a> 확인할 수 있습니다.</p>  <p>첫 번째 SQL Azure 데이터베이스에서 다음과 같이 테이블을 만듭니다.</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST(x bigint <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">IDENTITY</span> (1,1))</pre>      <p>두 번째 SQL Azure 데이터베이스에서 다음과 같이 테이블을 만듭니다.</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST(x bigint <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">IDENTITY</span> (2147483648,1))</pre>      <p>그리고 수평 분할에서 각 데이터베이스에 대한 시드 값을 계속 증가합니다.</p>    <p>장점</p>    <ul>    <li><b>int</b> 데이터 형식을 기본 키로 사용한 레거시 테이블에서 <b>bigint</b> 데이터 형식으로 업그레이드하는 것이 더 쉽습니다(레거시 테이블은 첫 번째 파티션이 됩니다).</li>      <li>행 이동에는 다시 계산된 해시가 아닌 직선 대/소문자 문이 포함되므로 다른 기술보다 더 쉽게 배상할 수 있습니다.</li>      <li>분할을 구현하는 데이터 계층 코드는 기본 키에 <strong>uniqueidentifier</strong> 를 사용하는 것과 달리 기본 키가 있는 파티션을 파악할 수 있습니다.</li>      <li><b>bigint</b> 데이터 형식은 16바이트를 차지하는 <b>uniqueidentifier</b> 데이터 형식보다 작은 8바이트의 공간을 사용합니다.</li>  </ul>    <p>단점</p>    <ul>    <li>각 파티션의 데이터베이스 스키마는 다릅니다.</li>      <li>이 기술은 수평 분할에 적합하지만 데이터 동기화 서비스에서는 작동하지 않습니다.</li>  </ul>    <h2>기본 키 풀</h2>    <p>이 기술에서는 모든 기본 키가 저장되지만 데이터가 없는 단일 ID 데이터베이스가 빌드됩니다. 이 ID 데이터베이스에는 단일 정수 열(<b>int</b> 데이터 형식)을 자동 증분 ID로 포함하는 일치하는 테이블 집합만 있습니다. 전체 파티션의 테이블에 삽입이 필요한 경우 데이터 계층 코드는 ID 데이터베이스에 삽입되고 @@IDENTITY을 가져옵니다. ID 데이터베이스의 이 기본 키는 멤버 데이터베이스 또는 파티션에 삽입할 기본 키로 사용됩니다. ID 데이터베이스가 키를 생성하기 때문에 충돌이 발생하지 않습니다.</p>    <p>그렇다면 50기가바이트 SQL Azure 데이터베이스를 보유할 수 있는 정수는 몇 개일까요? 기본 키 풀 역할을 하는 데이터베이스의 공간이 부족하면 더 이상 행을 삽입할 수 없기 때문에 좋은 질문입니다. 기본 키 데이터베이스의 단일 열 정수인 모든 테이블에는 50기가바이트 SQL Azure 데이터베이스에 200만 행(테이블 크기 2MB)이 있는 25,000개의 테이블이 있을 수 있습니다. 50GB는 현재 기본 키 데이터베이스에 사용할 수 있는 가장 큰 SQL Azure 데이터베이스입니다. 또는 400만 행의 12,000개 테이블 또는 800만 행의 6,000개 테이블과 같은 일부 조합입니다.</p>    <p>장점</p>    <ul>    <li>레거시 테이블을 사용하여 구현하는 가장 쉬운 기술입니다. 데이터 형식이 변경되지 않습니다. 그러나 IDENTITY 특성은 데이터 테이블에서 제거해야 합니다.</li>      <li>수평 분할 및 데이터 동기화 서비스에서 작동합니다.</li>  </ul>    <p>단점</p>    <ul>    <li>이 기술은 기본 키 데이터베이스에 대한 경합이 문제가 되지 않는 낮은 쓰기 높은 읽기 시나리오에서 가장 잘 작동합니다.</li>      <li>모든 INSERT에는 주 데이터베이스에 대한 추가 쿼리가 필요하며, 특히 데이터 데이터베이스와 주 데이터베이스가 동일한 데이터 센터에 없는 경우 성능 문제가 발생할 수 있습니다.</li>      <li>데이터 계층 계층이 기본 키에서 데이터가 있는 파티션을 식별할 수 있는 방법은 없습니다. 이러한 이유로 읽고 쓰는 알려진 멤버 데이터베이스가 있는 데이터 동기화 Services에서 가장 잘 작동합니다. </li>      <li>가장 큰 50기가바이트 SQL Azure 데이터베이스에서 보유할 수 있는 기본 키(<b>int</b> 데이터 형식)의 수에 대한 제약 조건이 있으며 이는 전체 파티션의 행 수에 대한 제한 사항입니다.</li>  </ul>    <h2>이중 열 기본 키</h2>    <p>또 다른 방법은 두 열을 사용하여 기본 키를 나타내는 것입니다. 첫 번째 열은 파티션 또는 멤버 데이터베이스를 지정하는 정수입니다. 두 번째 열은 자동 증가되는 int IDENTITY입니다. 여러 멤버 또는 파티션 데이터베이스를 사용하면 두 번째 열에 충돌이 있지만 두 열을 함께 사용하면 고유한 기본 키가 만들어질 수 있습니다.</p>    <p>다음은 이중 열 기본 키가 있는 CREATE TABLE 문의 예입니다.</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> TEST ([partition] <span class="kwrd">int</span>,       [id] <span class="kwrd">int</span> <span class="kwrd">IDENTITY</span>,       <span class="kwrd">CONSTRAINT</span> PK_TEST           <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span>([partition], [id]));</pre>      <p>모든 기본 키에 대한 두 번째 열과 모든 외래 키 참조에 두 번째 열을 추가해야 합니다.</p>    <p>장점</p>    <ul>    <li>추가 열을 추가하여 레거시 테이블에서 업그레이드하는 것이 더 쉽습니다. 그런 다음 해당 테이블을 <strong>uniqueidentifier</strong> 기본 키로 변환하는 것입니다. </li>      <li>두 정수는 16바이트를 차지하는 <b>uniqueidentifier</b> 데이터 형식보다 작은 8바이트의 공간을 사용합니다.</li>      <li>수평 분할 및 데이터 동기화 서비스에서 작동합니다.</li>      <li>분할을 구현하는 데이터 계층 코드는 기본 키에 <strong>uniqueidentifier</strong> 를 사용하는 것과 달리 기본 키가 있는 파티션을 파악할 수 있습니다.</li>  </ul>    <p>단점</p>    <ul>    <li>두 개의 열이 기본 키가 되도록 하는 것은 부자연스럽고 번거롭습니다.</li>      <li>데이터 계층 코드는 기본 키에 액세스하기 위해 두 정수의 추적을 유지해야 합니다. 언어 요소를 사용하여 <a href="https://msdn.microsoft.com/en-us/library/ah19swz4(VS.71).aspx">C#의 사용자 지정 <b>구조체</b></a>와 같은 새 데이터 형식을 만들어 난독화할 수 있습니다.</li>  </ul>    <h2>요약</h2>    <p>동일한 문제를 해결하기 위해 즐겨 찾는 기술이 있나요? 아래의 의견에 우리와 함께 공유합니다. 또는 어떤 기술이 최고인지에 대한 의견을 보내주세요. 질문, 우려 사항, 의견이 있습니까? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>
