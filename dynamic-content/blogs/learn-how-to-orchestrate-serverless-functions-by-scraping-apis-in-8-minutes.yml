### YamlMime:Yaml
ms.openlocfilehash: d88a99cf9ab64e4fe639253cee98ba5a721e14be
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911784"
Slug: learn-how-to-orchestrate-serverless-functions-by-scraping-apis-in-8-minutes
Title: 8분 안에 API를 스크래핑하여 서버리스 함수를 오케스트레이션하는 방법 알아보기
Summary: '시나리오 작업 중인 프로젝트에서는 NuGet 및 GitHub API와 같은 여러 원본에서 정보를 검색해야 합니다. GitHub API에서 데이터를 다운로드하는 방법을 집중 살펴보겠습니다. '
Content: >-
  <p><em>이 블로그 게시물은 Maxime Rouille, 클라우드 개발자 옹호자 II, Microsoft에 의해 작성되었습니다.</em></p>


  <h2>시나리오</h2>


  <p>작업 중인 프로젝트 Im&rsquo;을 사용하려면 NuGet 및 GitHub API와 같은 여러 원본에서 정보를 검색해야 합니다. &rsquo;Im&rsquo;이 GitHub API에서 데이터를 다운로드하는 방법에 초점을 맞출 수 있습니다. 당신이 <a href="https://twitter.com/MaximRouiller/status/1019597611341402112">트위터에</a> 나를 따르는 경우, 당신은&rsquo; 아마 이미 내가 그것에 대해 이야기 들었어요.</p>


  <p>지금까지 당신이&rsquo; 가지고있는 문제를 커버해야 샘플에 끝났다, 하지만 그냥 작동하지 않습니다&rsquo;? 그런 다음 마지막 커밋 날짜만 확인하여 마지막 커밋 이후 2년이 되었음을 확인&rsquo;합니다. 클라우드가 진화하는 방식, 해당 샘플은 사용자에게 거의 좋지 않습니다.</p>


  <p>Azure-Samples 조직의 리포지토리 중 일부는 정확한 문제를 가지고 있으며&rsquo; Im&rsquo;이 해결하려는 많은 문제 중 하나입니다.</p>


  <p>GitHub <a href="https://github.com/Azure-Samples/">Azure-Samples</a> 조직에는 수많은 샘플이 있으며, 어떤 샘플이 너무 오래되어 있는지 &ldquo;확인할 수 있기를 원합니다.&rdquo; 사용자는 유효한 샘플을 어떻게 생각하나요? 저에게 유효한 샘플은 최신 샘플입니다.</p>


  <p>900개가 넘는 샘플을 검색하고 마지막 커밋 날짜의 유효성을 검사하는 방법이 필요합니다.</p>


  <p>그러나 먼저 모든 정보를 검색할 수 있어야 합니다.</p>


  <pre>

  File -&gt; New Project -&gt; Console Application</pre>


  <p>프로그래머로서 첫 번째 본능은 콘솔 애플리케이션을 통해 한 번 시도하는 것입니다. 복잡성&rsquo;의 최소 크기입니다. 콘솔에서 작동할 수&rsquo; 없다면 다른 곳에서도 작동할 수 있다는&rsquo; 희망은 없습니다.</p>


  <p>그래서 GitHub <a href="https://developer.github.com/v3/">API 설명서를</a> 참조하고, GitHub 토큰을 만들고, 필요한 정보를 찾기 시작했습니다.</p>


  <p>결국 <a href="https://www.nuget.org/packages/Octokit/">Octokit</a> 라이브러리를 사용하여 모든 API 액세스를 수행했습니다. 마지막 커밋 날짜를 검색하는 코드는 다음과 같습니다.</p>


  <pre>

  var github = new GitHubClient(new ProductHeaderValue(&quot;AzureSampleChecker&quot;)) { Credentials = new Credentials(&quot;&quot;) };

  var lastCommit = await github.Repository.Commit.GetAll(repositoryId, new ApiOptions { PageSize = 1, PageCount = 1 });

  var commit = lastCommit.FirstOrDefault()?.Commit;

  var lastCommitDate = commit.Committer.Date;

  //snipped: saving to the database</pre>


  <h2>첫 번째 문제: 로컬로 실행</h2>


  <p>모든 것이 제대로 실행되고 있었지만, 그 시점에서 저에게 문제는 로컬로 실행되는 단일 콘솔 애플리케이션이었습니다. 애플리케이션을 컨테이너에 있는 그대로 사용할 수 있었지만 이 문제를 해결하는 또 다른 방법을 보았습니다. 나는 그것을 확장하는 또 다른 방법을 보았다. Azure Functions는 규모를 확장하는 데 도움이 됩니다.</p>


  <p>기존 코드를 Azure Functions로 마이그레이션함으로써 이제 문제는 여전히 Azure Functions 내에서 실행되는 콘솔 애플리케이션일 뿐이라는 것이었습니다. 이것은 단지 그것을 잘라하지 않습니다. &rsquo;동일한 워크플로를 순서대로 실행하기만 하면 좋습니다. 이 워크플로를 병렬로 실행하고 스케일 아웃할 수 있어야 합니다.</p>


  <p>쿼리하려는 모든 리포지토리를 알게 되면 분산된 문제가 됩니다. 두 리포지토리 간에 상관 관계가 없는 상태에서 한 번에 얼마나 많은 리포지토리를 적중할 수 있나요? 대답은 그들 모두입니다.</p>


  <p>이 프로세스를 더 견고하게 만들기 위해 리팩터링해야 했습니다. 나는 그것이 내구성이 필요했다.</p>


  <h2>지속성 함수 소개</h2>


  <p>서버리스를 접하는 경우 제레미&rsquo; 리크니스(Jeremy Likness)의 <a href="https://docs.microsoft.com/dotnet/standard/serverless-architecture/serverless-architecture?WT.mc_id=appserviceteam-blog-marouill">훌륭한 책이</a> 있어 속도를 끌어올릴 수 있습니다. Azure Functions는 서버리스 아키텍처의 Microsofts&rsquo; 구현입니다. 새로 고침이 필요한 경우 가능한 항목에 대한 <a href="https://docs.microsoft.com/azure/azure-functions/functions-overview?WT.mc_id=appserviceteam-blog-marouill">Azure Functions 개요</a> 를 검토할 수 있습니다.</p>


  <p>지속성 함수란? 내구성이 뛰어나면 오케스트레이션에 관한 모든 것이&rsquo; 있습니다. 음악과 마찬가지로 오케스트레이터는 모든 사람이 멜로디를 따르고 있는지 확인하지만&rsquo;, 각 뮤지션이 악기를 연주할 책임이 있습니다.</p>


  <p>Durable Functions와 관련하여 오케스트레이터는 일련의 함수를 시작하고 추적하는 일을 담당하지만&rsquo; 각 작업의 역할을 실행해야 합니다. 오케스트레이터는 코드 및 활동으로 작성된 워크플로를 워크플로의 단계로 간주합니다. 오케스트레이터와 활동은 여전히 Azure Functions입니다.</p>


  <p>&rsquo;내 코드에서 Im&rsquo;에서 사용하는 두 가지 패턴을 소개합니다.</p>


  <h2>함수 연결</h2>


  <p>빠르게 다루고 싶은 패턴은 <a href="https://docs.microsoft.com/azure/azure-functions/durable-functions-sequence?WT.mc_id=appserviceteam-blog-marouill">함수 연결</a>입니다. &rsquo;가장 간단하고 가장 일반적으로 사용되는 패턴입니다.</p>


  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3ba39f58-353f-4d3b-a050-66d49223b14d.png" style="margin-right: auto; margin-left: auto; float: none; display: block;"></p>


  <h2>함수 연결</h2>


  <p>오케스트레이터가 다른&rsquo; 함수를 실행하기 전에 함수를 대기할 때마다 함수 체인을 수행합니다. 코드 예제에서 시각화된 위의 이미지를 여기에&rsquo; 표시합니다.</p>


  <pre>

  [FunctionName(&quot;FunctionChaining&quot;)]


  public static async Task RunFunctionChaining([OrchestrationTrigger]) DurableOrchestrationContext context)


  {
      await context.CallActivityAsync(&quot;F1&quot;, null);
      await context.CallActivityAsync(&quot;F2&quot;, null);
      await context.CallActivityAsync(&quot;F3&quot;, null);
      await context.CallActivityAsync(&quot;F4&quot;, null);
  }</pre>


  <h2>팬아웃/팬인</h2>


  <p>제가 사용한 지속성 함수 디자인 패턴 중 하나는 <a href="https://docs.microsoft.com/azure/azure-functions/durable-functions-cloud-backup?WT.mc_id=appserviceteam-blog-marouill">팬아웃/팬인</a>입니다.</p>


  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/870bee86-855c-4e80-9c4a-5e4f93584826.png" style="margin-right: auto; margin-left: auto; float: none; display: block;"></p>


  <h2>팬아웃/팬인 패턴</h2>


  <p>패닝 아웃은 오케스트레이터 함수(F1)가 원하는 리포지토리와 같은 일부 초기 매개 변수와 병렬로 필요에 따라 많은 함수(F2)를 시작한다는 것을 의미합니다. 이러한 모든 함수의 실행이 완료되면 요청된 데이터를 오케스트레이터(F3)로 반환하는 방법이 필요합니다. 이러한 모든 함수가 동일한 서버에서 실행되지 않을 수 있습니다. 다중 스레드 애플리케이션만큼 간단하지는 않습니다. &rsquo;다중 스레드 다중 서버의 고도로 병렬 실행 워크플로를 생성합니다.</p>


  <p>로컬 데이터 센터에서 어떻게 하시겠습니까? 콘솔 애플리케이션은 팬아웃하려는 항목 목록을 검색합니다. 그런 다음, 해당 목록을 메시징 시스템에 큐에 넣습니다. 큐에 대기한 후에는 다른 서버에 있는 다른 콘솔 애플리케이션에서 이러한 메시지를 비동기적으로 큐에서 제거해야 합니다. 그런 다음 각 콘솔 애플리케이션은 실행 결과를 공유 스토리지에 저장해야 합니다. 완료되면&rsquo; 워크플로를 완료하는 첫 번째 콘솔 애플리케이션을 가져올 방법을 찾아야 합니다. 워크플로를 완료하려면 모든 결과를 다시 패닝하고 데이터베이스에 저장하는 작업이 포함됩니다.</p>


  <p>Azure Functions를&rsquo; 사용하면 개체를 반환하는 것만큼 쉽게 사용할 수 있습니다. 개별 함수의 결과를 저장하고 함께 집계하는 데 필요한 모든 작업은 자동으로 수행됩니다.</p>


  <p>이 시나리오는 어려운 문제입니다. Durable Functions는 1주일의 작업과 더 많은 테스트, 디버깅 및 프로세스 구체화를 쉽게 저장했습니다.</p>


  <p>이제 소개가 완료되었으므로 시나리오로 다시 이동할 수&rsquo; 있습니다.</p>


  <h2>오케스트레이터는 특수 함수입니다.</h2>


  <p><a href="https://docs.microsoft.com/azure/azure-functions/durable-functions-bindings?WT.mc_id=appserviceteam-blog-marouill">OrchestrationTrigger를 사용하는 함수는 일반 Azure Function과 크게 다르게 동작</a>합니다. 이 트리거는 일반적인 Azure 함수를 Orchestrator 함수로 만듭니다. 그냥</p>


  <p>해당 동작은 다른 함수와 매우 다릅니다. 이러한 함수의 실행을 오케스트레이션하기 위해 서로 다른 순간에 여러 번 호출됩니다. 해당 컨텍스트에서 시간을 계산하고 외부 리소스(예: SQL, Storage, API)에 액세스하지 않는 것이 가장 중요합니다. 오케스트레이터는 변경될 때 반복적으로 실행하여 시작한 함수의 상태를 실행하고 추적하는 작업을 수행합니다. 오케스트레이터 함수가 결정적이어야 합니다. 즉, 다른 시간에 실행되는 동일한 코드가 동일한 결과를 제공해야 합니다. 따라서 DateTime, Math.Random 또는 Guid.NewGuid()가 오케스트레이터에 없어야 합니다.</p>


  <p>&rsquo;또한 CallActivityAsync를 사용하는 모든 호출은 동일한 오케스트레이터 인스턴스에 대해 두 번 이상 실행되지 않습니다&rsquo;. 결과는 지속성 함수에 의해 캐시되고 처리됩니다.</p>


  <p>CallActivityAsync는 <a href="https://docs.microsoft.com/azure/azure-functions/durable-functions-checkpointing-and-replay?WT.mc_id=appserviceteam-blog-marouill">검사점 및 재생</a>을 호출하는 개념의 일부입니다. 간단히 말하면 서버 간에 신뢰할 수 있는 방식으로 실행한 이전 활동의 실행 상태를 기억하면서 오케스트레이터 실행을 다시 열 수 있습니다.</p>


  <h2>웹 스크래핑 시나리오</h2>


  <p>내 샘플 오케스트레이터에 대한 코드를 여기에&rsquo; 표시합니다.</p>


  <pre>

  [FunctionName(&quot;DownloadSamples_Orchestrator&quot;)]

  public static async Task RunOrchestrator([OrchestrationTrigger] DurableOrchestrationContext context, TraceWriter log)

  {
      var repositories = await context.CallActivityAsync&lt;List&gt;(&quot;DownloadSamples_GetAllPublicRepositories&quot;, null);
      var tasks = new Task[repositories.Count];
      for (int i = 0; i &lt; repositories.Count; i++)
      {
          tasks[i] = context.CallActivityAsync(&quot;DownloadSamples_UpdateRepositoryData&quot;, repositories[i]);
      }
      await Task.WhenAll(tasks);
      var samplesToAdd = tasks.Select(x =&gt; x.Result).ToList();
      await context.CallActivityAsync(&quot;DownloadSamples_SaveAllToDatabase&quot;, samplesToAdd);
  }</pre>


  <p>따라서 이를 함께 분해할 수&rsquo; 있습니다. 먼저 함수를 호출하여 Azure-Samples 사용할 수 있는 900개가 넘는 공용 리포지토리 목록을 검색하고 결과를 기다리고 있습니다. 그런 다음, 작업 배열을 만들고 샘플을 살펴보고 각 작업을 기다리지 않고 함수를 시작합니다. &rsquo;클라우드에서 자동으로 실행 및 확장할 함수의 실행을 계획합니다. Were&rsquo; not using await here. 그렇지 않으면 병렬이 아닌 순차적으로 실행됩니다.</p>


  <p>그런 다음 작업이 완료될 때까지 대기해야 합니다. 마지막으로 이러한 함수에서 반환된 Samples 개체를 목록으로 집계합니다. 마지막으로 함수에 보내 데이터베이스에 저장합니다. Weve&rsquo;는 100s 함수의 결과를 성공적으로 부채질했습니다. 타사 시스템이 필요하지 않습니다. 다른 구성은 없습니다. 복잡한 메시징 아키텍처가 없습니다. 그냥 코드.</p>


  <p>마찬가지로 weve&rsquo;는 복잡한 병렬 문제를 쉽게 만들었습니다.</p>


  <h2>고급 시나리오: 하위 오케스트레이터를 사용하여 오케스트레이터 오케스트레이션</h2>


  <p>놀랍지 않습니까&rsquo;? 이제 900개가 넘는 DownloadSamples_UpdateRepositoryData 함수를 인스턴스화하여 GitHub API에서 데이터를 다운로드하는 Orchestrator가 있습니다. 데이터 수집의 오케스트레이터가 여러 대 있는 경우 어떻게 될까요?</p>


  <p>오케스트레이터를 오케스트레이션하려면 어떻게 해야 하나요? 물론 다른 오케스트레이터가 필요합니다! 내 코드의 간소화된 버전을 여기에&rsquo; 추가합니다.</p>


  <blockquote>

  <pre>

  [FunctionName(&quot;MainDownloadOrchestrator_TimerStart&quot;)]


  public static async Task TimerStart([TimerTrigger(&quot;0 0 7 * * *&quot;)]TimerInfo myTimer,

      [OrchestrationClient]DurableOrchestrationClient starter,

  TraceWriter log)


  {

      string instanceId = await starter.StartNewAsync(&quot;MainDownloadOrchestrator&quot;, null);

  log.Info($&quot;Started orchestration with ID = &#39;{instanceId}&#39;.&quot;);


  }


  [FunctionName(&quot;MainDownloadOrchestrator&quot;)]


  public static async Task RunOrchestrator(

      [OrchestrationTrigger] DurableOrchestrationContext context)

  {

      var runId = await context.CallActivityAsync(&quot;CommonActivityFunctions_CreateRun&quot;, null);

      var downloadPipelines = new List();

  downloadPipelines.Add(context.CallSubOrchestratorAsync(&quot;DownloadSamples_Orchestrator&quot;, runId));


  downloadPipelines.Add(context.CallSubOrchestratorAsync(&quot;DownloadSomethingElse_Orchestration&quot;, runId));

      //todo: add more orchestrators

      await Task.WhenAll(downloadPipelines);

      return context.InstanceId;

  }</pre>

  </blockquote>


  <h3>수행하는 작업</h3>


  <p>다른 모든 데이터 수집 오케스트레이터를 호출하는 데 사용할 단일 실행을 만듭니다.</p>


  <p>이러한 모든 오케스트레이터는 모두 매일 오전 7시에 동시에 시작됩니다. 그들은 모두 전에 설명 된 대로 실행 하려고 합니다. 이번에는 다른 오케스트레이터에도 보고합니다.</p>


  <p>간단한 워크플로 구현을 시작하면 간단한 시나리오에서 복잡한 시나리오를 쉽게 빌드할 수 있습니다. 단일 오케스트레이터를 빌드하는 데 사용된 것과 동일한 패턴을 사용하여 여러 하위 오케스트레이터를 오케스트레이션할 수 있습니다.</p>


  <h3>이 작업을 원하는 이유는 무엇인가요?</h3>


  <p>Imagine 병렬로 실행해야 하는 다양한 프로세스가 있는 팀에서 작업합니다. 어쩌면 한 팀이 배송 프로세스에 대해 작업하고, 다른 한 팀은 결제 프로세스에 대해 작업하고 있습니다. 단일 오케스트레이터를 사용하여 여러 하위 오케스트레이터를 관리하면 팀 협업이 더 쉬워집니다.</p>


  <p>내 경우 다른 사람이 다른 API의 구문 분석을 추가하려는 경우 어떻게 해야 할까요? 오케스트레이터에서 작업하여 내 MainDownloadOrchestrator 함수에 연결할 수 있으며 이를 연결할&rsquo; 수 있습니다.</p>


  <p>API에서 데이터를 스크래핑하는 것은 단일 시나리오에 불과합니다. 주문 처리 시스템, 회의 조직 도구 또는 IoT 데이터 처리의 다음 혁명을 빌드하는 경우 솔루션 내에서 복잡성을 구성하는 방법이 필요하다는 것을 알고 있습니다. 단일 함수보다 시스템의 더 중요한 부분을 다시 사용하려고 합니다.</p>


  <p>Durable Functions는 서버리스를 사용하여 복잡한 시스템을 빌드하는 방법입니다.</p>


  <h3>누락된 내용</h3>


  <p>구현하지 않은&rsquo; 것은 속도 제한을 처리하는 방법입니다. GitHub API에는 시간당 5000(쓰기 시) API 호출의 제한이 있으며, 이는 제가 사용하는 데 충분합니다.</p>


  <p>그러나 다른 팀이 GitHub 좀 더 쿼리하는 경우 Id&rsquo;는 구현을 조사해야 합니다. 나는 아직도&rsquo; 이것에 대한 우아한 해결책을 가지고 있지 않지만, 다음에&rsquo; 구현하고자하는 Im이&rsquo; 될 것입니다.</p>


  <h2>사용해 보기</h2>


  <p>사용해 보려는 경우 Azure Functions에는 평가판 계정으로도 무료 할당량이 제공됩니다. 계정이 필요한 경우 <a href="https://azure.microsoft.com/free/?WT.mc_id=appserviceteam-blog-marouill">무료로 계정을 만들 수 있습니다</a>.</p>


  <h3>참가</h3>


  <p>Azure Functions도 오픈 소스입니다. 이 리포지토리에 참여하거나 프로젝트에 어떤 일이 일어나고 있는지&rsquo; 알고 싶다면 이 리포지토리를 살펴보세요.</p>


  <ul>
   <li>
   <p><a href="https://github.com/Azure/azure-functions-host">Azure 함수 런타임</a></p>
   </li>
  </ul>


  <ul>
   <li>
   <p><a href="https://github.com/Azure/azure-functions-core-tools">로컬 개발을 위한 Azure Function CLI</a></p>
   </li>
   <li>
   <p><a href="https://github.com/Azure/azure-functions-ux">Azure Function Portal</a></p>
   </li>
   <li>
   <p><a href="https://github.com/Azure/azure-functions-templates">포털 및 Visual Studio 대한 Azure Functions 템플릿</a></p>
   </li>
  </ul>


  <p>시작하기 위한 리소스</p>


  <ul>
   <li>
   <p><a href="https://docs.microsoft.com/azure/azure-functions/functions-overview?WT.mc_id=appserviceteam-blog-marouill">Azure Functions 소개</a></p>
   </li>
  </ul>


  <ul>
   <li>
   <p><a href="https://docs.microsoft.com/azure/azure-functions/functions-create-first-azure-function?WT.mc_id=appserviceteam-blog-marouill">Azure Portal에서 첫 번째 함수 만들기</a></p>
   </li>
   <li>
   <p><a href="https://docs.microsoft.com/azure/azure-functions/functions-create-scheduled-function?WT.mc_id=appserviceteam-blog-marouill">타이머 트리거에서 Azure Functions 실행</a></p>
   </li>
   <li>
   <p><a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-install?WT.mc_id=appserviceteam-blog-marouill">지속성 함수 확장 설치</a></p>
   </li>
   <li>
   <p><a href="https://docs.microsoft.com/en-us/dotnet/standard/serverless-architecture/durable-azure-functions?WT.mc_id=appserviceteam-blog-marouill">지속성 Azure Functions란?</a></p>
   </li>
  </ul>
