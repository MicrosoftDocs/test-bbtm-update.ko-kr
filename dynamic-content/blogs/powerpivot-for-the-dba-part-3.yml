### YamlMime:Yaml
ms.openlocfilehash: a3a2326f7e6bba9f86437a6dceeaf0de110cf8ce
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139908761"
Slug: powerpivot-for-the-dba-part-3
Title: 'DBA에 대한 PowerPivot: 3부'
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 이 문서에서는 Transact-SQL 비즈니스 인텔리전스의 간단한 용어와 방법론을 계속 연결하겠습니다.'
Content: "<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>이 문서에서는 Transact-SQL 비즈니스 인텔리전스의 몇 가지 간단한 용어와 방법론을 DBA를 위해 지구로 끌어올릴 것입니다. Transact-SQL PowerPivot 동일시하는 일련의 블로그 게시물(1부, 2부)의 연속입니다.</p>  <h2>Scope</h2>  <p>이 이전 블로그 게시물에서 설명한 대로 측정값은 계산 중인 셀의 행, PowerPivot 표의 셀 범위에 전달됩니다. 해당 범위에서 단일 셀을 합산하는 경우 실제로 잘 작동합니다. 그러나 셀이 있는 행이나 전체 피벗 테이블과 같이 이 범위와 더 큰 범위 사이의 비율을 얻으려면 어떻게 해야 할까요?</p>  <p>측정값은 범위를 벗어나 더 큰 그림에서 정보를 그릴 수 있습니다. 셀이 피벗 테이블이 Bike 범주에 있는 행 집합이고 주문 날짜가 2001년 7월 1일인 경우 측정값은 자전거 범주에 있는 모든 행에 액세스할 수 있으며 주문 날짜가 2001년 7월 1일인 모든 행에 액세스할 수 있으며 전체 피벗 테이블의 모든 행에 액세스할 수도 있습니다. </p>  <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image001\" border=\"0\" alt=\"clip_image001\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4024.clip_5F00_image001_5F00_thumb_5F00_56FFE9B2.png\" width=\"853\" height=\"634\"></a></p>  <p>로컬 범위 이상에 액세스하는 기능은 PowerPivot 측정값의 힘입니다. 이 기능은 셀 데이터가 피벗 테이블의 다른 테이블과 어떻게 비교되는지에 대한 인사이트를 사용자에게 제공합니다.</p>  <h2>ALL</h2>  <p>측정값 수식에 사용되는 언어인 <a href=\"https://technet.microsoft.com/en-us/library/ee835613.aspx\">DAX(데이터 분석 식)</a>에서 <a href=\"https://technet.microsoft.com/en-us/library/ff452076.aspx\">ALL</a> 은 적용되었을 수 있는 필터를 무시하고 테이블의 모든 행 또는 열의 모든 값을 반환합니다. 다음은 ALL을 사용하여 셀의 총 품목 판매액과 범주의 총 품목 판매량 비율을 계산하는 예제입니다.</p>  <pre class=\"csharpcode\">=SUM(SalesOrderDetail[LineTotal])/CALCULATE(SUM(SalesOrderDetail[LineTotal]),ALL(ProductCategory))</pre>    <p>수식에서 나누기를 찾습니다. 왼쪽은 이 이전 블로그 게시물에서 이미 설명한 수식입니다. 셀 범위의 모든 <b>LineTotal</b> 열을 합산합니다. 나누기 오른쪽에는 수식의 흥미로운 부분이 있으며 <a href=\"https://technet.microsoft.com/en-us/library/ff452134.aspx\">CALCULATE</a> 키워드를 호출하여 합계 범위를 변경합니다. CALCULATE는 지정된 필터에 의해 수정된 컨텍스트의 식을 평가합니다. 이 경우 이러한 필터는 피벗 테이블의 이 특정 행의 결과에서 반환된 모든 행입니다. 위의 예제에서는 주문 날짜입니다. 결과는 다음과 같습니다.</p>    <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image002\" border=\"0\" alt=\"clip_image002\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2816.clip_5F00_image002_5F00_thumb_5F00_2A36E43F.png\" width=\"827\" height=\"658\"></a></p>    <h2>Transact-SQL</h2>    <p>이제 Transact-SQL 동일한 결과를 가져올 수 있습니다. 이는 테이블(T1)로 사용되는 중첩된 SELECT로 인해 날짜당 <b>LineTotal</b> 열의 합계를 가져오기 위해 200 수준 transact-SQL 문으로 바뀝니다. </p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span>    ProductCategory.Name, SalesOrderHeader.OrderDate,       <span class=\"kwrd\">SUM</span>(LineTotal)/ <span class=\"kwrd\">MAX</span>(T1.ProductCategoryTotal)  <span class=\"kwrd\">FROM</span>    Sales.SalesOrderHeader      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Sales.SalesOrderDetail <span class=\"kwrd\">ON</span>           SalesOrderHeader.SalesOrderID = SalesOrderDetail.SalesOrderID      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.Product <span class=\"kwrd\">ON</span>           Product.ProductID = SalesOrderDetail.ProductID      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.ProductSubcategory <span class=\"kwrd\">ON</span>           Product.ProductSubcategoryID = ProductSubcategory.ProductSubcategoryID      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.ProductCategory <span class=\"kwrd\">ON</span>           ProductSubcategory.ProductCategoryID = ProductCategory.ProductCategoryID      <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> (          <span class=\"kwrd\">SELECT</span> <span class=\"kwrd\">SUM</span>(LineTotal) <span class=\"str\">'ProductCategoryTotal'</span>, SalesOrderHeader.OrderDate          <span class=\"kwrd\">FROM</span>    Sales.SalesOrderHeader              <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Sales.SalesOrderDetail <span class=\"kwrd\">ON</span>                   SalesOrderHeader.SalesOrderID = SalesOrderDetail.SalesOrderID          <span class=\"kwrd\">GROUP</span> <span class=\"kwrd\">BY</span> SalesOrderHeader.OrderDate                  ) <span class=\"kwrd\">AS</span> T1 <span class=\"kwrd\">ON</span>     SalesOrderHeader.OrderDate = T1.OrderDate  <span class=\"kwrd\">GROUP</span> <span class=\"kwrd\">BY</span> ProductCategory.Name, SalesOrderHeader.OrderDate  <span class=\"kwrd\">ORDER</span> <span class=\"kwrd\">BY</span> SalesOrderHeader.OrderDate</pre>      <p>이렇게 하면 올바른 결과가 모두 반환되지만 Excel 피벗 테이블에 비해 그리 좋지는 않습니다. 백분율은 서식이 지정되지 않고 결과가 피벗되지 않으며 총합계가 없으며 데이터를 읽기가 매우 쉽지 않습니다.</p>    <p>다음은 테이블을 피벗하는 Transact-SQL입니다.</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SELECT</span> OrderDate, [1] <span class=\"kwrd\">AS</span> Bikes, [2] <span class=\"kwrd\">AS</span> Components, [3] <span class=\"kwrd\">AS</span> Clothing,      [4] <span class=\"kwrd\">AS</span> Accessories  <span class=\"kwrd\">FROM</span>   (<span class=\"kwrd\">SELECT</span>    Sales.SalesOrderDetail.LineTotal/T1.ProductCategoryTotal <span class=\"str\">'LineTotal'</span>,       ProductCategory.ProductCategoryID,       SalesOrderHeader.OrderDate      <span class=\"kwrd\">FROM</span>    Sales.SalesOrderHeader          <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Sales.SalesOrderDetail <span class=\"kwrd\">ON</span>               SalesOrderHeader.SalesOrderID = SalesOrderDetail.SalesOrderID          <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.Product <span class=\"kwrd\">ON</span>               Product.ProductID = SalesOrderDetail.ProductID          <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.ProductSubcategory <span class=\"kwrd\">ON</span>               Product.ProductSubcategoryID =           ProductSubcategory.ProductSubcategoryID          <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Production.ProductCategory <span class=\"kwrd\">ON</span>               ProductSubcategory.ProductCategoryID =           ProductCategory.ProductCategoryID          <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> (              <span class=\"kwrd\">SELECT</span> <span class=\"kwrd\">SUM</span>(LineTotal) <span class=\"str\">'ProductCategoryTotal'</span>, SalesOrderHeader.OrderDate              <span class=\"kwrd\">FROM</span>    Sales.SalesOrderHeader                  <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> Sales.SalesOrderDetail <span class=\"kwrd\">ON</span>                       SalesOrderHeader.SalesOrderID = SalesOrderDetail.SalesOrderID              <span class=\"kwrd\">GROUP</span> <span class=\"kwrd\">BY</span> SalesOrderHeader.OrderDate                      ) <span class=\"kwrd\">AS</span> T1 <span class=\"kwrd\">ON</span>     SalesOrderHeader.OrderDate = T1.OrderDate            ) p  PIVOT  (      <span class=\"kwrd\">SUM</span>(LineTotal)      <span class=\"kwrd\">FOR</span> ProductCategoryID <span class=\"kwrd\">IN</span> ( [1], [2], [3], [4] )  ) <span class=\"kwrd\">AS</span> pvt  <span class=\"kwrd\">ORDER</span> <span class=\"kwrd\">BY</span> pvt.OrderDate;</pre>      <h2>요약</h2>    <p>질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>"
