### YamlMime:Yaml
ms.openlocfilehash: f83e5a1c10e43004fa66697a61f27d794df1f9c0
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139912122"
Slug: azure-cosmos-db-and-multi-tenant-systems
Title: Azure Cosmos DB 및 다중 테넌트 시스템
Summary: 이 블로그 게시물에서는 Azure Cosmos DB에서 다중 테넌트 시스템을 빌드하는 방법을 설명합니다. Azure Cosmos DB 자체는 Azure의 다중 테넌트 PaaS 제품입니다.
Content: >-
  <p>이 블로그 게시물에서는 Azure Cosmos DB에서 다중 테넌트 시스템을 빌드하는 방법을 설명합니다. Azure Cosmos DB 자체는 Microsoft Azure 다중 테넌트 PaaS 제품입니다. 다른 다중 테넌트 시스템에서 다중 테넌트 시스템을 빌드하는 것은 어려울 수 있지만 Azure는 작업을 쉽게 수행할 수 있는 모든 도구를 제공합니다. 다중 테넌트 시스템의 예로는 다른 회사가 HR 시스템에서 사용할 수 있는 백그라운드 검사 서비스를 제공하는 회사가 있습니다. 이 블로그 게시물의 목적을 위해 이 예제를 사용하고 서비스로 백그라운드 검사를 제공하는 회사의 관점에서 계속 진행하겠습니다. 이 회사를 게시자로 &ldquo;지칭합니다.&rdquo;</p>


  <p>중요한 사용자 데이터를 저장하는 다중 테넌트 시스템을 빌드하는 방법에 대해 알아보겠&rsquo;습니다. 데이터 격리 및 보안은 모든 시스템의 가장 중요한 측면입니다. <strong>각 테넌트&rsquo; 데이터가 서로 격리되도록 시스템을 디자인해야 합니다</strong>. 특정 테넌트에 저장된 데이터는 하나의 테넌트 위반이 다른 테넌트로 흘러들어갈 수 없도록 구획으로 나눠야 합니다. 이것은 <a href="https://en.wikipedia.org/wiki/Ship_floodability" target="_blank">홍수 가능성을</a> 줄이기 위해 선박의 선체를 구획화하는 것과 유사합니다.</p>


  <p>다중 테넌트 시스템에서 고객 데이터의 격리 및 보호를 강화하려면 테넌트 데이터에 대한 JIT(Just-In-Time) 액세스를 가질 수 있는 승인된 서비스를 하나만 사용하여 시스템을 빌드해야 합니다. 모든 보안 주체에 대한 액세스 범위가 고객별로 분할되도록 각 고객&rsquo; 데이터 파티션에 대해 다른 시스템 주체를 설정해야 합니다. 우리는 서비스가 모든 테넌트 데이터에 액세스하는 것을 원하지 않습니다&rsquo;. 이는 큰 보안 위험입니다. 우리가 원하는 것은 하나의 테넌트 JIT에 대한 액세스 권한을 얻는 서비스입니다. 이 방법의 이점은 테넌트가 언제든지 인증서와 키를 회전할 수 있다는 것입니다.</p>


  <p>모든 테넌트는 게시자&#39;FES(프런트 엔드 서비스)를 사용하여 데이터를 관리할 수 있지만 Azure Cosmos DB 컬렉션에서 자체 데이터를 직접 조작할 수는 없습니다. 이렇게 격리하면 모든 테넌트가 마스터 및 읽기 전용 키에 액세스할 필요가 없습니다. 모든 데이터 액세스는 서비스를 통해 수행되며 포털 또는 코드를 통해 직접 액세스하지 않는 한 아무도 Azure Cosmos DB에 액세스하지 않습니다. 고객 데이터를 관리하는 게시자 애플리케이션은 고객 테넌트 및 데이터와는 별개인 다른 Azure Active Directory 테넌트 및 구독에서&rsquo; 호스팅됩니다.</p>


  <p>그러나 테넌트는 데이터에 직접 액세스하지 않고 모든 컬렉션과 데이터를 소유합니다. 이렇게 하면 테넌트가 직접 청구되는 모든 데이터 스토리지 및 처리량에 대한 청구가 간소화되지만 까다로운 요구 사항입니다. 이 요구 사항을 관리하는 방법을 살펴보겠습니다&rsquo;.</p>


  <p>이 솔루션의 주요 행위자는 <a href="https://docs.microsoft.com/en-us/azure/managed-applications/overview" target="_blank">Azure Managed Applications</a>, <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/service-to-service" target="_blank">디먼 애플리케이션</a>, <a href="https://docs.microsoft.com/en-us/azure/cosmos-db/introduction" target="_blank">Azure Cosmos DB</a>, <a href="https://azure.microsoft.com/en-us/services/key-vault/" target="_blank">Azure Key Vault</a> 및 <a href="https://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-whatis" target="_blank">Azure Active Directory</a>(AAD)입니다. 다음 단락은 언급된 각 솔루션을 이해하는 데 도움이 됩니다.</p>


  <p>Azure Managed Application은 마켓플레이스의 서비스 카탈로그와 비슷하지만 한 가지 주요 차이점이 있습니다. 관리되는 애플리케이션에서 리소스는 앱 게시자가 관리하는 리소스 그룹에 프로비전됩니다. 리소스 그룹은 소비자&#39;구독에 있지만 게시자&#39;테넌트의 ID는 고객 구독의 리소스 그룹에 액세스할 수 있습니다. 게시자는 <a href="https://azure.microsoft.com/en-us/pricing/details/managed-applications/" target="_blank">솔루션에 대한 지속적인 지원 비용을 지정합니다</a>.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/69cadeac-9577-42b4-aa0d-5104ee693492.png"><img alt="Customer subscription flow chart" border="0" height="200" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/e4182aa3-487d-4584-b05e-c601df406d39.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="고객 구독 흐름도" width="558"></a></p>


  <p>관리되는 애플리케이션은 솔루션을 사용하는 소비자의 장벽을 낮춥니다. 솔루션 사용을 위해 클라우드 인프라에 대한 전문 지식이 필요하지 않습니다. 소비자들은 중요 리소스에 대한 액세스가 제한됩니다. 그들은 그것을 관리 할 때 실수를 하는 것에 대해 걱정할 필요가&#39;없습니다. 관리형 애플리케이션을 통해 고객은 기본 Azure 인프라에 대한 전문 지식 없이도 솔루션을 채택할 수 있습니다.</p>


  <p>관리되는 애플리케이션을 사용하면 소비자와의 지속적 관계를 구현할 수 있습니다. 애플리케이션 관리 약관을 정의하고 모든 요금은 Azure 청구를 통해 처리됩니다.</p>


  <p>고객은 이러한 관리형 애플리케이션을 구독에 배포하지만 유지 관리, 업데이트 또는 서비스를 제공할 필요는 없습니다. 모든 고객이 승인된 버전을 사용하게 할 수 있습니다. 고객은 이러한 애플리케이션을 관리하기 위해 애플리케이션별 도메인 지식을 개발할 필요가 없습니다. 애플리케이션의 문제 해결 및 진단에 대해 걱정할 필요 없이 애플리케이션 업데이트를 자동으로 획득합니다. Azure Managed Application의 장점은 청구, 서로 다른 테넌트 간의 데이터 분리, 손쉬운 유지 관리, 기타 이점입니다. 자세한 내용은 <a href="https://docs.microsoft.com/en-us/azure/managed-applications/overview" target="_blank">Azure Managed Applications</a>에 대해 자세히 알아보세요.</p>


  <p>테넌트 관리형 애플리케이션을 배포한 후 디먼 애플리케이션을 만듭니다. 리소스에 액세스할 수 <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-authenticate-service-principal-powershell" target="_blank">있는 AAD 애플리케이션 및 서비스 주체를 만드는 방법에</a> 대한 지침을 따릅니다. 이 디먼 애플리케이션에는 고유한 ID와 테넌트 구독에 대한 액세스 권한이 있습니다. 이 애플리케이션은 고객 테넌트 애플리케이션과 서비스 공급자(게시자) 간의 브리지입니다.</p>


  <p>몇 가지를 이해하는 것이 중요합니다. 첫째, 디먼 애플리케이션에서 사용자 조작이 불가능하므로, 이 애플리케이션에 고유한 ID가 있어야 합니다. 디먼 애플리케이션의 예로는 일괄 처리 작업 또는 백그라운드에서 실행되는 운영 체제 서비스가 있습니다. 이 유형의 애플리케이션은 애플리케이션 ID를 사용하고 애플리케이션 ID, 자격 증명(암호 또는 인증서) 및 애플리케이션 ID URI를 AAD 표시하여 액세스 토큰을 요청합니다. 인증이 성공하면 디먼은 AAD 애플리케이션의 ID를 나타내는 액세스 토큰을 받은 다음 웹 API를 호출하는 데 사용됩니다.</p>


  <p>Azure Managed Applications의 마법은 게시자가 관리되는 고객 구독 리소스에 액세스할 수 있다는 것입니다. 이러한 리소스는 게시&rsquo;자 AAD 테넌트에 있는 구독 내에 있는 것처럼 관리됩니다. 고객 테넌트 구독 리소스는 자체 Azure 구독에서 고객에게 표시되지만 Azure 리소스 잠금으로 인해 액세스할 수 없습니다. 게시자만 고객&rsquo; 구독에서 관리되는 애플리케이션 리소스에 대한 모든 권한을 가집니다.</p>


  <p>디먼 애플리케이션을 만든 후에는 고객 테넌트 구독의 관리되는 리소스 구성 요소로 배포되는 Azure Cosmos DB 인스턴스의 ID 및 액세스(IAM)에 등록해야 합니다.</p>


  <p>개발하려는 마지막 조각은 FES(프런트 엔드 서비스)입니다. 이 서비스는 고객 테넌트에서 구성 요소를 관리하는 데 사용됩니다. 이 서비스는 디먼 애플리케이션 ID를 사용하는 오케스트레이션을 통과할 때까지 Azure Cosmos DB에 직접 액세스할 수 없습니다. 다음은 고객&rsquo; 구독 리소스와의 FES 상호 작용에 대한 단계별 연습을 보여 줍니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/97c5795c-c676-4dba-8c48-3fb57044b52f.png"><img alt="FES interaction with the customer subscription resources flow chart" border="0" height="375" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2c3fa919-d443-45c3-90a1-da33a13f0914.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="고객 구독 리소스 흐름도와 FES 상호 작용" width="558"></a></p>


  <p>FES는 런타임에 디먼 애플리케이션 ID를 인수합니다. FES에는 액세스를 위해 Key Vault에 등록된 자체 MSI(관리 ID)도 있습니다. 런타임에 FES는 Azure MSI를 사용하여 Key Vault에 연결하고 인증서 자격 증명을 가져오며, 자격 증명을 사용하여 디먼 애플리케이션을 나타내는 AAD 토큰을 가져옵니다(1단계).</p>


  <p>FES가 인증서를 가져오면 클라이언트 ID 및 비밀 인증서를 사용하여 디먼 서비스의 ID를 가정합니다. 그런 다음 AAD 호출하여 관리되는 애플리케이션에 대한 액세스 토큰을 가져옵니다(2단계). 이 FES는 Azure Active Directory 권한 부여 DLL(AAD DLL)을 사용합니다. FES가 AAD 토큰을 가져오는 데 도움이 되는 아래 FES 코드 조각을 참조하세요.</p>


  <pre>

  using Microsoft.Azure.KeyVault;

  using Microsoft.Azure.Services.AppAuthentication;

  using Microsoft.IdentityModel.Clients.ActiveDirectory;


  string secretIdentifier = &quot; key vault secretIdentifier for daemon app goes here &quot;;

  var tokenCache = TokenCache.DefaultShared;

  string pubTenantId = &quot; publisher&rsquo;s Azure AD directory id here &quot;;


  //// get app key from Key Vault (&hellip; let me know if you need a sample for reading a certificate/private key instead of a secret

  var azureServiceTokenProvider = new AzureServiceTokenProvider();


  var keyVaultClient = new KeyVaultClient(new KeyVaultClient.AuthenticationCallback(azureServiceTokenProvider.KeyVaultTokenCallback));

  string secret = keyVaultClient.GetSecretAsync(appKey)

  .GetAwaiter()

  .GetResult();


  //// now get a token representing the Daemon app, using the secret credential of the Daemon Azure AD application.  Resource is the appropriate Azure resource Uri.

  string daemonAppId = &quot;daemon Azure AD application Id&quot;;

  string authString = $&quot;https://login.microsoftonline.com/{pubTenantId}&quot;;

  string daemonAppResourceUri = &quot;https://management.core.windows.net/&quot;;

  var clientCredential = new ClientCredential(daemonAppId, secret.Value);

  var authenticationContext = new AuthenticationContext(authString, false, tokenCache);


  var authnResult = authenticationContext.AcquireTokenAsync(resourceUri, clientCredential)

  .GetAwaiter()

  .GetResult();


  string daemonToken = authnResult.AccessToken;


  //// alternately, to use a certificate you would substitute the above variables:

  ////     var clientCredential = new ClientAssertionCertificate(clientId, certificate);</pre>


  <p>FES에서 액세스 토큰을 가져오면 Azure Cosmos DB를 호출하여 마스터 키를 가져옵니다(3단계 및 4단계). 이 작업은 디먼 애플리케이션의 액세스 토큰을 사용하여 수행됩니다. 이 FES의 경우 헤더에 AAD 토큰을 전달합니다.</p>


  <pre>

  using Microsoft.Azure.Management.CosmosDB.Fluent;

  using Microsoft.Azure.Management.Fluent;

  using Microsoft.Azure.Management.ResourceManager.Fluent;

  using Microsoft.Azure.Management.ResourceManager.Fluent.Core;


  string subscriptionId = &quot; subscribing customer&rsquo;s subscription id &quot;;

  string resourceGroupName = &quot; subscribing customer&rsquo;s resource group name &quot;;

  string databaseAccountName = &quot; subscribing customer&rsquo;s Cosmos DB account name &quot;;


  var credential = new AzureCredentials(new TokenCredentials(daemonToken), pubTenantId, AzureEnvironment.AzureGlobalCloud);


  var azure = Azure.Configure()

  .WithLogLevel(HttpLoggingDelegatingHandler.Level.Basic)

  .Authenticate(credential)

  .WithSubscription(subscriptionId);


  var cosmosDbAccounts = azure.CosmosDBAccounts;

  var readWritekeys = cosmosDbAccounts.ListKeysAsync(resourceGroupName, databaseAccountName)

  .GetAwaiter()

  .GetResult();</pre>


  <p>마스터 키가 있으면 Cosmos DB에 액세스하기 시작합니다(5단계).</p>


  <pre>

  using Microsoft.Azure.Documents;

  using Microsoft.Azure.Documents.Client;


  string cosmosDBendpointUri = $&quot;{databaseAccountName}.documents.azure.com:443/&quot;;


  string masterKey = readWritekeys.PrimaryMasterKey; //// pick the one you need


  var connectionPolicy = new ConnectionPolicy { ConnectionMode = ConnectionMode.Direct, ConnectionProtocol = Protocol.Tcp };


  var documentClient = new DocumentClient(new Uri(cosmosDBendpointUri), masterKey, connectionPolicy);


  client.OpenAsync()

  .GetAwaiter()

  .GetResult();</pre>


  <p>FES를 나타내는 <a href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview" target="_blank">Azure MSI</a>가 아닌 디먼 애플리케이션 ID가 Azure Cosmos DB 키를 검색하는 데 사용되는 이유가 궁금할 수 있습니다. 정답은 보안 격리, JIT 액세스, Key Vault에서 디먼 애플리케이션 비밀을 가져오고, AAD 액세스하여 보안 격리를 지원하는 데 도움이 되는 토큰을 가져오는&rsquo; 것입니다. 이 오케스트레이션은 FES가 모든 테넌트 키에 액세스할 수 없도록 합니다&rsquo; . 디먼 ID를 사용해야만 JIT 키에 액세스할 수 있습니다.</p>


  <p>이 시스템에는 다음과 같은 이점이 있습니다.</p>


  <ul>
   <li>게시자, 코드 또는 구성 파일에서 액세스 키가 유지되지 않습니다. 이 메서드는 모든 테넌트에 필요한 보안을 제공합니다.</li>
   <li>한 게시자 액세스 토큰이 모든 테넌트에 액세스할 수 없습니다.</li>
   <li>각 구독 고객은 해당 고객 리소스에 액세스하기 위해 고유한 디먼 애플리케이션 ID로&rsquo; 프로비전됩니다.</li>
   <li>런타임에만 FES는 디먼 애플리케이션 비밀을 사용하여 액세스 토큰을 가져올 수 있습니다.</li>
  </ul>


  <p>Azure Cosmos DB는 다음과 같은 이 솔루션에 많은 이점을 제공합니다.</p>


  <ul>
   <li>게시자는 새 테넌트를 온보딩할 때 필요한 처리량과 공간을 알지 못합니다.</li>
   <li>스토리지 및 처리량에 대한 Azure Cosmos DB&rsquo; 탄력적 특성은 이 솔루션을 매우 유연하게 유지합니다.</li>
   <li>게시자가 정의한 Azure Managed Applications 템플릿에는 필요에 따라 요청 단위를 확장할 수 있는 최소 기본 Azure Cosmos DB가 함께 제공됩니다.</li>
   <li>디먼 애플리케이션 및 Key Vault를 사용하여 JIT에 액세스합니다.</li>
  </ul>


  <p>이 문서에서는 Azure Cosmos DB를 통해 다중 테넌트 시스템을 빌드하기 위한 여정을 시작하는 데 도움이 되는 충분한 포인터를 제공했으면 합니다.</p>


  <p><em>이 블로그 게시물에 기여해 주신 테리 카터, 니키샤 레예스 그레인지, 스네하 군다에게 특별한 감사드립니다.</em></p>
