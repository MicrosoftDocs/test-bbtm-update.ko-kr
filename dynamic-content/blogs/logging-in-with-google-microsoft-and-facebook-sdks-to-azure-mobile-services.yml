### YamlMime:Yaml
ms.openlocfilehash: c9df4bea86bf39a777c7b668778ee7e31f93fcde
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911777"
Slug: logging-in-with-google-microsoft-and-facebook-sdks-to-azure-mobile-services
Title: Google, Microsoft 및 Facebook SDK를 사용하여 Azure Mobile Services 로그인
Summary: Azure Mobile Services 대한 .NET 및 node.js 백 엔드의 새로운 릴리스는 Google, Microsoft 및 Facebook의 네이티브 SDK를 사용하여 서비스에 로그인하기 위한 지원을 추가했습니다. 이 게시물에서는 클라이언트 SDK를 사용하여 모바일 애플리케이션 사용자에게 더 나은 로그인 환경을 제공하는 방법을 보여 줍니다.
Content: "Azure Mobile Services 제공하는 값 중 하나는 매우 간단한 API를 통해 모바일 애플리케이션에 대한 인증을 구현하는 쉬운 방법입니다. 지원되는 플랫폼 중 하나에서 클라이언트 개체에 <em>대한 로그인</em> 함수(또는 해당)를 호출하면 사용자에게 모바일 서비스에 로그인할 수 있는 간단한 웹 기반 인터페이스가 제공됩니다. 이는 <em>서버 쪽 인증 흐름</em>이라고 하며, 여기서 서비스는 클라이언트를 공급자(웹 페이지의 리디렉션을 통해)로 안내한 다음 다시 자체로 안내합니다.\n\n서버 쪽 인증을 사용하는 것은 애플리케이션을 시작하는 좋은 방법이지만 사용하려는 인증 공급자에 로그인을 지원하는 일부 네이티브 SDK가 있는 경우 앱에서 애플리케이션을 사용하는 경우 더 나은 환경을 사용할 수 있습니다. 예를 들어 사용자가 Android 디바이스에 있는 경우 해당 디바이스와 연결된 Google 계정이 있을 가능성이 매우 높으므로 자격 증명을 다시 입력하지 않고도 해당 계정을 사용할 수 있는 경우 더 나은 사용자 환경을 제공합니다. Android, iOS 또는 Windows Phone 디바이스의 Facebook 계정 또는 Windows 또는 Windows Phone Microsoft 계정과 동일합니다. 이 시나리오는 <em>클라이언트 쪽 인증 흐름</em>이라고 하며, 여기서 클라이언트 애플리케이션은 공급자(기본 SDK를 통해)와 직접 대화한 다음, 공급자의 일부 토큰을 모바일 서비스와 교환하여 서비스 자체를 인증합니다.\n\n몇 시간 동안 node.js 백 엔드에서 Facebook 및 Microsoft 인증에 대해 작동하는 클라이언트 쪽 인증 흐름이 있었지만 .NET 런타임에서는 작동하지 않았습니다. 지금까지는 어떤 런타임에서도 Google SDK 인증을 지원하지 않았습니다. .NET SDK의 세 소셜 공급자 모두의 SDK 데이터를 통한 인증을 지원하는 것 외에도 node.js 백 엔드에서 Google 인증에 대한 지원을 발표했습니다. <a href=\"https://stackoverflow.com/q/23185985/751090\">이</a> <a href=\"https://social.msdn.microsoft.com/forums/azure/en-US/51cbf1cb-2de2-4516-aa75-75cbec2069d4/post-of-google-token-is-not-supported-405-error?forum=azuremobile\">기능은</a> <a href=\"https://github.com/Azure/azure-mobile-services/issues/185\">오랫동안 요청</a>된 기능<a href=\"https://stackoverflow.com/q/23285860/751090\">으로</a>, 라이브로 만나게 되어 기쁩니다. 이 게시물에서는 이 새로운 기능을 사용하는 방법을 살펴보겠습니다.\n<h2>Microsoft 계정</h2>\nLive SDK Windows Phone/Windows 스토어 앱에 로그인하는 것은 모바일 서비스(node.js)의 첫 번째 릴리스 이후 백 엔드를 node.js 옵션이었습니다. .NET 백 엔드에서 사용하도록 설정되었으므로 사용하도록 설정하는 단계는 노드에서와 정확히 동일합니다. 인증을 위해 앱을 등록하고 Windows 스토어 대시보드 정보를 모바일 서비스의 ID 탭에 복사하고, 애플리케이션에 Live SDK 추가합니다. Live SDK 사용하여 로그인하고, 나중에 SDK에서 받은 인증 토큰을 모바일 서비스로 보냅니다. 이러한 모든 단계는 자습서에 <a title=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/\" href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-single-sign-on/\"></a> 나열되어 있으며 이를 따라 .NET 백 엔드를 사용하는 애플리케이션에 Live SDK 로그인을 추가할 수 있습니다.\n<h2>Facebook 로그인</h2>\nMicrosoft 계정의 경우와 마찬가지로 Facebook SDK의 토큰으로 로그인하는 것은 오랫동안 node.js 백 엔드에서 옵션이었습니다. 이제 .NET 백 엔드는 이 클라이언트 흐름도 지원합니다. 또한 이전 섹션과 마찬가지로 클라이언트 코드(또는 작성해야 하는 서버의 코드에서도)에는 전혀 차이가 없으므로 노드에 대한 모든 자습서도 .NET 백 엔드에도 적용됩니다. Facebook SDK를 통해 앱에 로그인을 추가하는 방법에 대한 자세한 내용은 <a href=\"https://blogs.msdn.com/b/carlosfigueira/archive/2014/02/05/using-the-facebook-ios-sdk-for-logging-in-to-azure-mobile-services.aspx\">iOS 앱</a> 및 <a href=\"https://blogs.msdn.com/b/carlosfigueira/archive/2014/01/08/using-the-facebook-android-sdk-for-logging-in-to-azure-mobile-services.aspx\">Android 앱</a> 블로그 게시물에서 확인할 수 있습니다.\n<h2>Google 로그인</h2>\nGoogle 계정에 대한 클라이언트 인증 흐름은 node.js 및 .NET 백 엔드 모두에 대한 새로운 기능이며 둘 다에서 동일하게 작동합니다. Android 앱에 로그인 작업을 추가하는 시나리오를 살펴보겠습니다.\n<h3>인증을 위해 앱 등록</h3>\nGoogle SDK를 사용하여 네이티브 Android 앱 인증을 시작하기 전에 <a href=\"https://console.developers.google.com/\">Google 개발자 콘솔</a>의 프로젝트에 연결하여 백 엔드 모바일 서비스를 \"준비\"해야 합니다. 이렇게 하려면 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-dotnet-backend-android-get-started-users/\">모바일 서비스 앱에 인증 추가</a> 자습서의 첫 번째 섹션을 따릅니다(<a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-how-to-register-google-authentication/\">Mobile Services Google 로그인에 앱을 등록</a>하는 옵션에 따라). 완료되면 네이티브 부분으로 이동할 수 있습니다.\n<h3>Android 앱에 Google+ 통합</h3>\n애플리케이션에 Google 로그인을 추가하려면 애플리케이션에 Google Play 서비스 라이브러리를 추가해야 합니다. Google 설명서의 <a href=\"https://developers.google.com/+/mobile/android/getting-started\">시작 페이지에</a> 는 이 작업을 수행하는 데 필요한 모든 단계가 있습니다. 첫 번째 단계에서는 이전 단계에서 만든 것과 동일한 프로젝트를 사용하는 대신 <a href=\"https://console.developers.google.com/\">Google 개발자 콘솔</a>에서 새 프로젝트를 만들도록 지시합니다. 프로젝트에서 웹 애플리케이션에 대한 클라이언트 ID가 이미 있으며 Android 설치 애플리케이션에 대한 새 OAuth 클라이언트 ID를 추가하게 됩니다.\n<h3>Android 앱에 대한 로그인 추가</h3>\nGoogle Play가 프로젝트에 대해 제대로 설정되면 이제 먼저 Google 자체에 로그인한 다음 모바일 서비스에 로그인하는 데 사용할 수 있습니다. Google Play 서비스를 사용하기 전에 항상 존재하는지 확인해야 합니다(에뮬레이터가 제대로 설정되지 않은 경우 디버깅하는 데 많은 시간을 절약할 수 있습니다.)\n<pre class=\"prettyprint\">    btn.setOnClickListener(new View.OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            int isAvailableResult = GooglePlayServicesUtil.isGooglePlayServicesAvailable(activity);\n            if (isAvailableResult == ConnectionResult.SUCCESS) {\n                Log.d(\"msg\", \"Result for isGooglePlayServicesAvailable: SUCCESS\");\n                pickUserAccount();\n            } else {\n                Log.e(\"error\", \"Google play services is not available: \" + isAvailableResult);                \n            }\n        }\n    });</pre>\n서비스가 디바이스(실제 또는 가상)에서 실행되고 있음을 설정한 후에는 사용자가 사용하려는 디바이스와 연결된 계정을 선택할 수 있습니다. 이를 위해 사용자가 계정을 선택할 수 있는 UI를 표시하는 <a href=\"https://developer.android.com/reference/com/google/android/gms/common/AccountPicker.html\">AccountPicker</a> 클래스를 사용하거나 사용자에게 계정이 하나만 있는 경우 사용자 개입 없이 자동으로 선택합니다(더 나은 환경).\n<pre class=\"prettyprint\">    static final int REQUEST_CODE_PICK_ACCOUNT = 1000;\n    private void pickUserAccount() {\n        String[] accountTypes = new String[] { \"com.google\" };\n        Intent intent = AccountPicker.newChooseAccountIntent(null, null, accountTypes, false, null, null, null, null);\n        startActivityForResult(intent, REQUEST_CODE_PICK_ACCOUNT);\n    }</pre>\n선택기 UI는 별도의 작업으로 제공되므로 결과를 얻으려면 onActivityResult 메서드를 재정의해야 합니다. 결과적으로 사용자가 사용하려는 계정의 이름을 가져올 수 있으며, 이 작업이 완료되면 모바일 서비스에 로그인하는 데 필요한 토큰을 요청할 수 있습니다.\n<pre class=\"prettyprint\">    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CODE_PICK_ACCOUNT) {\n            if (resultCode == RESULT_OK) {\n                String accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);\n                Log.d(\"msg\", \"Account name: \" + accountName);\n                getTokenAndLogin(accountName);\n            } else if (resultCode == RESULT_CANCELED) {\n                Log.d(\"msg\", \"Activity cancelled by user\");\n            }\n        }\n    }</pre>\nGoogle에서 서비스에 로그인하는 데 필요한 토큰은 ID 토큰입니다. Android ID 토큰은 Android 앱이 사용자가 다시 로그인할 필요 없이 원격 서비스와 통신할 수 있도록 웹 애플리케이션에 사용자를 인증하는 데 사용됩니다. 이는 사용자가 개발자 콘솔에 정의된 <em>네이티브 </em>앱을 사용하여 인증한 다음 <em>원격 </em>앱(모바일 서비스)에 토큰을 표시하는 클라이언트 간 인증의 한 형태이며, 이 토큰은 Google에서 토큰이 동일한 <em>프로젝트에서</em> 온다는 유효성을 검사합니다. 동일한 프로젝트와 연결된 두 개의 OAuth 클라이언트 ID를 만들었습니다. 모바일 서비스와 Google은 사용자가 해당 애플리케이션에 대해서만 인증되도록 통신할 수 있습니다.\n\nID 토큰을 검색하려면 디바이스가 온라인 상태여야 하고(또 다른 모범 사례) 백그라운드 스레드로 이동하여 토큰을 검색합니다. 여기서 <a href=\"https://developer.android.com/reference/android/os/AsyncTask.html\">는 AsyncTask</a>를 사용합니다.\n<pre class=\"prettyprint\">    static final String GOOGLE_SCOPE_TAKE2 = \"audience:server:client_id:\";\n    static final String CLIENT_ID_WEB_APPS = \"0000000000000-0aaaaaaa00aa00aa0aaa0a0aaaaaaa0a.apps.googleusercontent.com\";\n    static final String GOOGLE_ID_TOKEN_SCOPE = GOOGLE_SCOPE_TAKE2 + CLIENT_ID_WEB_APPS;\n\n    private void getTokenAndLogin(String accountName) {\n        if (mAccountName == null) {\n            pickUserAccount();\n        } else {\n            if (isDeviceOnline()) {\n                new GetTokenAndLoginTask(this, GOOGLE_ID_TOKEN_SCOPE, accountName).execute((Void)null);\n            } else {\n                Toast.makeText(this, R.string.not_online, Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n\n    private boolean isDeviceOnline() {\n        ConnectivityManager mgr = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);\n        NetworkInfo netInfo = mgr.getActiveNetworkInfo();\n        return netInfo != null &amp;&amp; netInfo.isConnected();\n    }</pre>\n디바이스가 온라인 상태인지 확인할 때 사용하려는 계정과 요청 범위를 사용하는 <a href=\"https://developer.android.com/reference/com/google/android/gms/auth/GoogleAuthUtil.html#getToken(android.content.Context, java.lang.String, java.lang.String)\">GoogleAuthUtil.getToken</a> 메서드를 사용할 수 있습니다. 클라이언트 간 인증의 경우 범위는 \"audience:server:client_id:\" 접두사로 정의되고 <em>웹 애플리케이션에 대한 클라이언트 ID</em> (이 섹션의 첫 번째 단계에서 만든)로 정의됩니다. 이 경우 Android 애플리케이션에 대한 클라이언트 ID를 사용하지 마세요. 사용자가 아직 애플리케이션에 데이터를 사용하도록 권한을 부여하지 않은 경우 UserRecoverableAuthException이 throw되고 나중에 표시할 대로 처리할 수 있습니다. 사용자가 앱에 해당 정보를 사용하도록 권한을 부여한 경우 토큰이 반환되고 해당 토큰을 가져와서 \"id_token\" 속성이 있는 개체에 래핑하여 모바일 서비스의 로그인 호출로 보낼 수 있습니다. 해당 호출이 완료되면 모바일 서비스에 로그인하고 보호된 리소스에 액세스할 수 있습니다.\n<pre class=\"prettyprint\">    class GetTokenAndLoginTask extends AsyncTask&lt;Void, Void, Void&gt; {\n\n        MainActivity mActivity;\n        String mScope;\n        String mEmail;\n\n        public GetTokenAndLoginTask(MainActivity activity, String scope, String email) {\n            this.mActivity = activity;\n            this.mScope = scope;\n            this.mEmail = email;\n        }\n\n        @Override\n        protected Void doInBackground(Void... params) {\n            try {\n                final String token = fetchIdToken();\n                if (token != null) {\n                    loginToMobileService(token);\n                }\n            } catch (IOException e) {\n                Log.e(\"error\", \"Exception: \" + e);\n            }\n\n            return null;\n        }\n\n        protected void loginToMobileService(final String idToken) {\n            runOnUiThread(new Runnable(){\n\n                @Override\n                public void run() {\n                    mActivity.updateTextView(\"Token: \" + idToken);\n                    JsonObject loginBody = new JsonObject();\n                    loginBody.addProperty(\"id_token\", idToken);\n                    mClient.login(MobileServiceAuthenticationProvider.Google, loginBody, new UserAuthenticationCallback() {\n\n                        @Override\n                        public void onCompleted(MobileServiceUser user, Exception error,\n                                ServiceFilterResponse response) {\n                            if (error != null) {\n                                Log.e(\"error\", \"Login error: \" + error);\n                            } else {\n                                Log.d(\"msg\", \"Logged in to the mobile service as \" + user.getUserId());\n                            }\n                        }\n                    });\n                }\n            });\n        }\n\n        protected String fetchIdToken() throws IOException {\n            try {\n                return GoogleAuthUtil.getToken(mActivity, mEmail, mScope);\n            } catch (UserRecoverableAuthException urae) {\n                mActivity.handleException(urae);\n            } catch (GoogleAuthException gae) {\n                Log.e(\"error\", \"Unrecoverable exception: \" + gae);\n            }\n            return null;\n        }\n    }</pre>\n퍼즐의 마지막 조각은 getToken 메서드가 복구 가능한 예외를 반환한 경우를 처리하는 것입니다. 이 경우 예외에 의해 지정된 작업을 시작하여 예외를 처리할 수 있습니다. 그러면 사용자에게 앱을 사용하도록 권한을 부여하라는 대화 상자가 표시됩니다. 그런 다음 앱이 해당 권한 부여 화면에서 반환될 때 토큰을 다시 가져오기 위해 호출할 수 있도록 onActivityResult 구현을 업데이트해야 합니다(사용자가 앱에 권한을 부여한 경우 성공).\n<pre class=\"prettyprint\">    static final int REQUEST_CODE_PICK_ACCOUNT = 1000;\n    static final int REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR = 1001;\n\n    public void handleException(final Exception e) {\n        // Because this call comes from the AsyncTask, we must ensure that the following\n        // code instead executes on the UI thread.\n        runOnUiThread(new Runnable() {\n            @Override\n            public void run() {\n                if (e instanceof GooglePlayServicesAvailabilityException) {\n                    // The Google Play services APK is old, disabled, or not present.\n                    // Show a dialog created by Google Play services that allows\n                    // the user to update the APK\n                    int statusCode = ((GooglePlayServicesAvailabilityException)e)\n                            .getConnectionStatusCode();\n                    Dialog dialog = GooglePlayServicesUtil.getErrorDialog(statusCode,\n                            MainActivity.this,\n                            REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);\n                    dialog.show();\n                } else if (e instanceof UserRecoverableAuthException) {\n                    // Unable to authenticate, such as when the user has not yet granted\n                    // the app access to the account, but the user can fix this.\n                    // Forward the user to an activity in Google Play services.\n                    Intent intent = ((UserRecoverableAuthException)e).getIntent();\n                    startActivityForResult(intent,\n                            REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR);\n                }\n            }\n        });\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CODE_PICK_ACCOUNT) {\n            if (resultCode == RESULT_OK) {\n                String accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME);\n                Log.d(\"msg\", \"Account name: \" + accountName);\n                getTokenAndLogin(accountName);\n            } else if (resultCode == RESULT_CANCELED) {\n                Log.d(\"msg\", \"Activity cancelled by user\");\n            }\n        } else if (requestCode == REQUEST_CODE_RECOVER_FROM_PLAY_SERVICES_ERROR &amp;&amp; resultCode == RESULT_OK) {\n            getTokenAndLogin();\n        }\n    }</pre>\n이를 통해 모바일 앱에 네이티브 Google 인증을 추가하고 이를 사용하여 모바일 서비스에 로그인하는 방법을 살펴보았습니다. 앞에서 설명한 것처럼 node.js 및 .NET 백 엔드 모두에 대해 동일한 방식으로 작동합니다.\n<h2>요약</h2>\n잠시 동안 요청된 기능을 릴리스할 수 있고 이번 주에는 그렇게 하면 항상 좋습니다. 이렇게 하면 사용자에게 더 나은 사용자 로그인 환경을 제공하여 Azure Mobile Services 애플리케이션에 더 많은 가치를 추가할 수 있기를 바랍니다.\n\n평소와 같이, 트위터 <a href=\"https://twitter.com/azuremobile\">@AzureMobile</a> 또는 <a href=\"https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile\">MSDN 포럼</a>을 통해이 게시물의 의견으로 의견을 보내주세요."
