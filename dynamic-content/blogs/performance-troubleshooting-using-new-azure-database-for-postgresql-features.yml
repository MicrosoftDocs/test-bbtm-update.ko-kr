### YamlMime:Yaml
ms.openlocfilehash: b941d2d06628ecdac9e52a6248dd41d96ae2e84e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907611"
Slug: performance-troubleshooting-using-new-azure-database-for-postgresql-features
Title: 새 Azure Database for PostgreSQL 기능을 사용하여 성능 문제 해결
Summary: Ignite 2018에서 Microsoft의 Azure Database for PostgreSQL은 고객 피드백에 따라 성능 문제 해결을 용이하게 하기 위해 QS(쿼리 저장소), QPI(Query Performance Insight) 및 PR(성능 권장 사항)의 미리 보기를 발표했습니다. 이 블로그는 몇 가지 일반적인 시나리오를 해결하기 위해 현재 사용할 수 있는 기능을 사용하는 방법에 대한 아이디어를 제공합니다.
Content: "<p>Ignite 2018에서 Microsofts&rsquo; Azure Database for PostgreSQL은 고객 피드백에 따라 성능 문제 해결을 용이하게 하기 위해 QS(쿼리 저장소), QPI(Query Performance Insight) 및 PR(성능 권장 사항)의 미리 보기를 <a href=\"https://azure.microsoft.com/en-us/blog/latest-updates-to-open-source-database-services-for-azure-ignite-2018\" target=\"_blank\">발표</a>했습니다. 이 블로그는 몇 가지 일반적인 시나리오를 해결하기 위해 현재 사용할 수 있는 기능을 사용하는 방법에 대한 아이디어를 제공합니다.</p>\n\n<p>사용 중인 애플리케이션 패턴에 따라 문제가 발생할 수 있는 계층에 대한 <a href=\"https://azure.microsoft.com/en-us/blog/performance-best-practices-for-using-azure-database-for-postgresql/\" target=\"_blank\">성능 모범 사례</a> 에 대한 이전 블로그 게시물입니다. 이 블로그는 문제 공간을 여러 영역과 일반적인 기술로 잘 분류하여 근본 원인을 신속하게 파악할 수 있는 가능성을 배제합니다. 이러한 새로 발표된 기능(QS, QPI 및 PR)의 도움으로 이 기능을 추가로 확장하고자 합니다.</p>\n\n<p>이러한 기능을 사용하려면 <strong>pg_qs.query_capture_mode 및 pgms_wait_sampling.query_capture_mode를 ALL로</strong> 설정하여 데이터 수집을 사용하도록 설정해야 합니다.</p>\n\n<p><strong><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7df716f3-3bdb-4da0-9a2a-8eed9d5725c0.png\"><img alt=\"New features on Azure Database for PostgreSQL\" border=\"0\" height=\"379\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d125a2ad-7e33-48db-95c5-863faa95f8a6.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure Database for PostgreSQL의 새로운 기능\" width=\"1607\"></a></strong></p>\n\n<p>쿼리 저장소를 사용하여 데이터 수집을 사용하도록 설정하여 이러한 시나리오 문제를 보다 효율적으로 해결할 수 있는 다양한 시나리오에 사용할 수 있습니다. 이 문서에서는 범위를 회귀된 쿼리 시나리오로 제한합니다.</p>\n\n<h2>회귀된 쿼리</h2>\n\n<p>쿼리 저장소에서 모니터링할 수 있는 중요한 시나리오 중 하나는 <strong>회귀된 쿼리입니다</strong>. <strong>pg_qs.query_capture_mode</strong>를 <strong>ALL</strong>로 설정하면 시간에 따른 쿼리 성능 기록을 얻을 수 있습니다. 이 데이터를 활용하여 요구 사항에 따라 단순하거나 더 복잡한 비교를 수행할 수 있습니다.</p>\n\n<p>회귀된 쿼리 목록을 생성할 때 직면하는 과제 중 하나는 쿼리 런타임 통계를 기준으로 하는 비교 기간을 선택하는 것입니다. 비교 기간을 선택할 때 고려해야 할 몇 가지 요인이 있습니다.</p>\n\n<ul>\n <li><strong>계절성</strong>: 워크로드 또는 관심 쿼리가 지속적으로 수행되지 않고 주기적으로 발생하나요?</li>\n <li><strong>역사</strong>: 충분한 기록 데이터가 있습니까?</li>\n <li><strong>임계값</strong>: 일정 비율의 변경 임계값에 익숙한가요 아니면 회귀의 통계적 중요성을 증명하기 위해 더 복잡한 방법이 필요한가요?</li>\n</ul>\n\n<p>이제 워크로드의 계절성이 없고 기록의 기본 7일이 회귀된 쿼리를 선택하기 위한 간단한 변경 임계값을 평가하기에 충분하다고 가정해 보겠습니다&rsquo;. 기준 시작 및 종료 시간을 선택하고 테스트 시작 및 종료 시간을 선택하여 추적하려는 메트릭의 회귀 양을 계산하기만 하면 됩니다.</p>\n\n<p>지난 7일간의 기록을 지난 2시간의 실행과 비교하여 살펴보면 아래는 가장 많이 회귀된 쿼리를 내림차순으로 표시합니다. 결과 집합에 음수 값이 있는 경우 기준에서 테스트 기간&rsquo;(0)으로 개선되었음을 나타내며, 기준 기간 동안 변경되지 않거나 실행되지 않을 수 있습니다.</p>\n\n<pre>\ncreate or replace function get_ordered_query_performance_changes(\nbaseline_interval_start int,\nbaseline_interval_type text,\ncurrent_interval_start int,\ncurrent_interval_type text)\nreturns table (\n     query_id bigint,\n     baseline_value numeric,\n     current_value numeric,\n     percent_change numeric\n) as $$\nwith data_set as (\nselect query_id\n, round(avg( case when start_time &gt;= current_timestamp - ($1 || $2)::interval and start_time &lt; current_timestamp - ($3 || $4)::interval then mean_time else 0 end )::numeric,2) as baseline_value\n, round(avg( case when start_time &gt;= current_timestamp - ($3 || $4)::interval then mean_time else 0 end )::numeric,2) as current_value\nfrom query_store.qs_view where query_id != 0 and user_id != 10 group by query_id ) , \nquery_regression_data as (\nselect *\n, round(( case when baseline_value = 0 then 0 else (100*(current_value - baseline_value) / baseline_value) end )::numeric,2) as percent_change \nfrom data_set ) \nselect * from query_regression_data order by percent_change desc;\n$$\nlanguage &#39;sql&#39;;</pre>\n\n<p>이 함수를 만들고 다음을 실행하면 지난 7일 동안의 계산 기준 값과 비교하여 최근 2시간 동안의 상위 회귀 쿼리를 내림차순으로 가져옵니다.</p>\n\n<pre>\nselect * from get_ordered_query_performance_changes (7, &#39;days&#39;, 2, &#39;hours&#39;);</pre>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0815ff55-718c-4087-bd8a-3fe7d29e84a5.png\"><img alt=\"Query performance\" border=\"0\" height=\"289\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ff43913d-284a-405c-82d5-8991dfa13f00.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"쿼리 성능\" width=\"483\"></a></p>\n\n<p>데이터 크기가 변경되거나 트랜잭션 볼륨이 증가할 것이라는 것을 알고 있기 때문에 기준 기간의 델타 종류를 기대하지 않는 한 상위 변경 내용은 모두 좋은 후보입니다. 추가 조사하려는 쿼리를 식별한 후 다음 단계는 쿼리 저장소 데이터를 자세히 살펴보고 기준 통계가 현재 기간과 어떻게 비교되는지 확인하고 추가 단서를 수집하는 것입니다.</p>\n\n<pre>\ncreate or replace function compare_baseline_to_current_by_query_id(baseline_interval_cutoff int,baseline_interval_type text,query_id bigint,percentile decimal default 1.00)\nreturns table(\n     query_id bigint,\n     period text,\n     percentile numeric,\n     total_time numeric,\n     min_time numeric,\n     max_time numeric,\n     rows numeric,\n     shared_blks_hit numeric,\n     shared_blks_read numeric,\n     shared_blks_dirtied numeric,\n     shared_blks_written numeric,\n     local_blks_hit numeric,\n     local_blks_read numeric,\n     local_blks_dirtied numeric,\n     local_blks_written numeric,\n     temp_blks_read numeric,\n     temp_blks_written numeric,\n     blk_read_time numeric,\n     blk_write_time numeric\n)\nas $$\n\nwith data_set as\n( select *\n, ( case when start_time &gt;= current_timestamp - ($1 || $2)::interval then &#39;current&#39; else &#39;baseline&#39; end ) as period\nfrom query_store.qs_view where query_id = ( $3 )\n)\nselect query_id\n, period\n, round((case when $4 &lt;= 1 then 100 * $4 else $4 end)::numeric,2) as percentile\n, round(percentile_cont($4) within group ( order by total_time asc)::numeric,2) as total_time\n, round(percentile_cont($4) within group ( order by min_time asc)::numeric,2) as min_time\n, round(percentile_cont($4) within group ( order by max_time asc)::numeric,2) as max_time\n, round(percentile_cont($4) within group ( order by rows asc)::numeric,2) as rows\n, round(percentile_cont($4) within group ( order by shared_blks_hit asc)::numeric,2) as shared_blks_hit\n, round(percentile_cont($4) within group ( order by shared_blks_read asc)::numeric,2) as shared_blks_read\n, round(percentile_cont($4) within group ( order by shared_blks_dirtied asc)::numeric,2) as shared_blks_dirtied\n, round(percentile_cont($4) within group ( order by shared_blks_written asc)::numeric,2) as shared_blks_written\n, round(percentile_cont($4) within group ( order by local_blks_hit asc)::numeric,2) as local_blks_hit\n, round(percentile_cont($4) within group ( order by local_blks_read asc)::numeric,2) as local_blks_read\n, round(percentile_cont($4) within group ( order by local_blks_dirtied asc)::numeric,2) as local_blks_dirtied\n, round(percentile_cont($4) within group ( order by local_blks_written asc)::numeric,2) as local_blks_written\n, round(percentile_cont($4) within group ( order by temp_blks_read asc)::numeric,2) as temp_blks_read\n, round(percentile_cont($4) within group ( order by temp_blks_written asc)::numeric,2) as temp_blks_written\n, round(percentile_cont($4) within group ( order by blk_read_time asc)::numeric,2) as blk_read_time\n, round(percentile_cont($4) within group ( order by blk_write_time asc)::numeric,2) as blk_write_time\nfrom data_set\ngroup by 1, 2\norder by 1, 2 asc;\n$$\nlanguage &#39;sql&#39;;</pre>\n\n<p>함수를 만든 후에는 조사하려는 쿼리 ID를 제공합니다. 이 함수는 제공한 구분 시간을 기준으로 이전과 이후의 집계 값을 비교합니다. 예를 들어 아래 문은 지금부터 2시간 이전의 모든 지점을 쿼리에 대한 2시간 후의 지점과 비교합니다. 제외하려는 이상값을 알고 있는 경우 백분위수 값을 사용할 수 있습니다.</p>\n\n<pre>\nselect * from compare_baseline_to_current_by_query_id(30, &#39;minutes&#39;, 4271834468, 0.95);</pre>\n\n<p>사용하지 않는&rsquo; 경우 기본값은 모든 데이터 요소를 포함하는 100입니다.</p>\n\n<pre>\nselect * from compare_baseline_to_current_by_query_id(2, &#39;hours&#39;, 4271834468);</pre>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5e676856-576d-4681-8d86-d6d328612940.png\"><img alt=\"Query performances\" border=\"0\" height=\"90\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8edbd5c2-7942-48f6-96a8-e200f5cd7c81.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"쿼리 성능\" width=\"1713\"></a></p>\n\n<p>중요한 데이터 크기 변경이 없고 캐시 적중률이 다소 안정적이라는 것을 배제하는 경우 동일한 기간 내에 명백한 대기 이벤트 발생 변경 내용을 조사할 수도 있습니다. 대기 이벤트 유형은 서로 다른 대기 유형을 기본적으로 비슷한 버킷으로 결합하므로 데이터를 분석하는 방법에 대한 처방전은 하나도 없습니다. 그러나 일반적인 비교를 통해 시스템 상태 변경에 대한 아이디어를 얻을 수 있습니다.</p>\n\n<pre>\ncreate or replace function compare_baseline_to_current_by_wait_event (baseline_interval_start int,baseline_interval_type text,current_interval_start int,current_interval_type text)\nreturns table(\n     wait_event text,\n     baseline_count bigint,\n     current_count bigint,\n     current_to_baseline_factor double precision,\n     percent_change numeric\n)\nas $$\nwith data_set as\n( select event_type || &#39;:&#39; || event as wait_event\n, sum( case when start_time &gt;= current_timestamp - ($1 || $2)::interval and start_time &lt; current_timestamp - ($3 || $4)::interval then 1 else 0 end ) as baseline_count\n, sum( case when start_time &gt;= current_timestamp - ($3 || $4)::interval then 1 else 0 end ) as current_count\n, extract(epoch from ( $1 || $2 ) ::interval) / extract(epoch from ( $3 || $4 ) ::interval) as current_to_baseline_factor\nfrom query_store.pgms_wait_sampling_view where query_id != 0\ngroup by event_type || &#39;:&#39; || event\n) ,\nwait_event_data as\n( select *\n, round(( case when baseline_count = 0 then 0 else (100*((current_to_baseline_factor*current_count) - baseline_count) / baseline_count) end )::numeric,2) as percent_change\nfrom data_set\n)\nselect * from wait_event_data order by percent_change desc;\n$$\nlanguage &#39;sql&#39;;\n\nselect * from compare_baseline_to_current_by_wait_event (7, &#39;days&#39;, 2, &#39;hours&#39;);</pre>\n\n<p>위의 쿼리를 사용하면 두 기간 사이에 몇 가지 비정상적인 변경 내용을 볼 수 있습니다. 여기서 이벤트 수는 근사값으로 간주되며 시간이 지정된 경우 인스턴스의 비교 부하 컨텍스트 내에서 숫자를 가져와야 합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0bbc0dc9-18df-4dae-b675-36854248d316.png\"><img alt=\"Queries\" border=\"0\" height=\"165\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/50e7c13a-c2dd-46b3-bb82-c6f3900f3c9a.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"쿼리\" width=\"748\"></a></p>\n\n<p>여기서 볼 수 있듯이 쿼리 저장소에서 사용 가능한 시계열 데이터를 통해 창의성은 여기서 구현할 수 있는 분석 및 알고리즘의 종류에 대한 제한입니다. 후보자를 식별하고 개선하기 위해 바로 앞으로 기술을 적용할 수 있는 몇 가지 간단한 계산을 보여 줍니다. 우리는 이것이 당신의 출발점이 될 수 있고 당신이 작동하는 것, 하지 않는&rsquo; 것 및 다음 단계로 이것을 취하는 방법을 우리와 공유하기를 바랍니다.</p>\n\n<p>여러분의 의견을 항상 기다리고 있습니다!</p>\n\n<h2>감사의 글</h2>\n\n<p>이 블로그 게시물에 기여한 수석 데이터 과학자 Korhan Ileri와 수석 데이터 과학자 인타이크 파크와 사이카트 센에게 특별한 감사드립니다.</p>"
