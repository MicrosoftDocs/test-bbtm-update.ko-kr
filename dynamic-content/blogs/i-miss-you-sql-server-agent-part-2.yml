### YamlMime:Yaml
ms.openlocfilehash: f06ead8ed47cc42c318edaee01d59ef31f479d7c
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139906739"
Slug: i-miss-you-sql-server-agent-part-2
Title: '에이전트를 SQL Server 그리워요: 2부'
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 현재 SQL Azure SQL Server 에이전트의 개념이 없습니다. 이 블로그 시리즈에서는 경량 대체를 만들려고 합니다...'
Content: '<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>현재 SQL Azure SQL Server 에이전트의 개념이 없습니다. 이 블로그 시리즈에서는 Windows Azure 작업자 역할을 사용하여 경량 대체를 만들려고 합니다. 시리즈의 첫 번째 블로그 게시물에서 Windows Azure 작업자 역할이 SQL Server 에이전트와 어떻게 비교되는지 알아보고 Visual Studio 및 일부 코드를 시작했습니다. 이 블로그 게시물에서 하루에 한 번 "작업"을 완료하는 메커니즘을 만들겠습니다.</p>  <h2>데이터베이스 만들기</h2>  <p>Windows Azure는 언제든지 데이터 센터의 다른 서버로 작업자 역할을 이동할 수 있는 상태 비지방 플랫폼입니다. 이 때문에 작업 완료 상태를 직접 유지해야 합니다. 그래서 명백한 선택은 SQL Azure. 이렇게 하려면 <b>SQLServerAgent</b>(데이터베이스 이름 <b>msdb</b>가 예약됨)라는 SQL Azure 서버 아래에 데이터베이스를 만들었습니다. 이 데이터베이스에서 온-프레미스 SQL Server 에이전트 테이블 <b>sysjobactivity</b>의 간소화된 버전인 <b>jobactivity</b>라는 테이블을 만들었습니다. 사용한 만들기 스크립트는 다음과 같습니다.</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> [dbo].[jobactivity](      [job_id] uniqueidentifier <span class="kwrd">NOT</span> <span class="kwrd">NULL</span> <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span>,      [job_name] nvarchar(100) <span class="kwrd">NOT</span> <span class="kwrd">NULL</span>,      [start_execution_date] datetime <span class="kwrd">NOT</span> <span class="kwrd">NULL</span>,      [stop_execution_date] datetime <span class="kwrd">NULL</span>,  ) </pre>      <p>job_id 개체의 일별 인스턴스를 나타내며, job_name 실행 중인 작업에 대한 임의의 키입니다. 이 테이블을 사용하여 이름이 다른 많은 작업을 실행할 수 있습니다.</p>    <h2>작업 시작 및 중지 추적</h2>    <p>또한 작업이 시작될 때 테이블에 행을 추가하고 작업이 종료되면 중지 실행 날짜를 설정하는 몇 가지 저장 프로시저가 필요합니다. <b>StartJob</b> 저장 프로시저를 사용하면 한 작업자 역할이 작업을 시작했다는 신호로 작업 실행에 대한 행을 추가하기 전에 작업이 오늘 시작되지 않았는지 확인합니다. 이 기능을 사용하면 작업을 여러 번 실행하지 않고도 여러 작업자 역할이 SQL Server 에이전트 역할을 할 수 있습니다.</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">PROCEDURE</span> StartJob (      @job_name <span class="kwrd">varchar</span>(100),      @job_id uniqueidentifier <span class="kwrd">OUTPUT</span>)  <span class="kwrd">AS</span>    <span class="kwrd">BEGIN</span> <span class="kwrd">TRANSACTION</span>    <span class="kwrd">SELECT</span>    @job_id  <span class="kwrd">FROM</span>    [jobactivity]  <span class="kwrd">WHERE</span>    DATEDIFF(d, [start_execution_date], GetDate()) = 0       <span class="kwrd">AND</span> [job_name] = @job_name    <span class="kwrd">IF</span> (@@<span class="kwrd">ROWCOUNT</span>=0)  <span class="kwrd">BEGIN</span>      <span class="rem">-- Has Not Been Started</span>      <span class="kwrd">SET</span> @job_id = NewId()      INSERT <span class="kwrd">INTO</span> [jobactivity]           ([job_id],[job_name],[start_execution_date])          <span class="kwrd">VALUES</span> (@job_id, @job_name, GetDate())  <span class="kwrd">END</span>  <span class="kwrd">ELSE</span>  <span class="kwrd">BEGIN</span>       <span class="kwrd">SET</span> @job_id = <span class="kwrd">NULL</span>  <span class="kwrd">END</span>    <span class="kwrd">COMMIT</span> <span class="kwrd">TRAN</span></pre>      <p>다른 저장 프로시저인 <b>StopJob</b>은 다음과 같습니다.</p>    <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">PROCEDURE</span> [dbo].[StopJob](      @job_id uniqueidentifier)        <span class="kwrd">AS</span>    <span class="kwrd">UPDATE</span> [jobactivity]  <span class="kwrd">SET</span> [stop_execution_date] = GetDate()  <span class="kwrd">WHERE</span> job_id = @job_id</pre>      <p>    <p>이제 새 저장 프로시저를 호출하는 일부 C#을 작업자 역할 코드에 작성해 보겠습니다.</p>    <pre class="csharpcode"><span class="kwrd">protected</span> Guid? StartJob(String jobName)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection = <span class="kwrd">new</span> SqlConnection(          ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLServerAgent&quot;</span>].              ConnectionString))      {          <span class="kwrd">try</span>          {              <span class="rem">// Open the connection</span>              sqlConnection.Open();                SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(                  <span class="str">&quot;StartJob&quot;</span>, sqlConnection);                sqlCommand.CommandType =                  System.Data.CommandType.StoredProcedure;                sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@job_name&quot;</span>, jobName);                <span class="rem">// WWB: Sql Job Id Output Parameter</span>              SqlParameter jobIdSqlParameter = <span class="kwrd">new</span>                   SqlParameter(<span class="str">&quot;@job_id&quot;</span>, SqlDbType.UniqueIdentifier);              jobIdSqlParameter.Direction = ParameterDirection.Output;              sqlCommand.Parameters.Add(jobIdSqlParameter);                sqlCommand.ExecuteNonQuery();                <span class="kwrd">if</span> (jobIdSqlParameter.Value == DBNull.Value)                  <span class="kwrd">return</span> (<span class="kwrd">null</span>);              <span class="kwrd">else</span>                  <span class="kwrd">return</span> ((Guid)jobIdSqlParameter.Value);          }          <span class="kwrd">catch</span> (SqlException)          {              <span class="rem">// WWB: SQL Exceptions Means It Is Not Started</span>              <span class="kwrd">return</span> (<span class="kwrd">null</span>);          }      }  }    <span class="kwrd">protected</span> <span class="kwrd">void</span> StopJob(Guid jobId)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection = <span class="kwrd">new</span> SqlConnection(          ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLServerAgent&quot;</span>].              ConnectionString))      {          <span class="rem">// Open the connection</span>          sqlConnection.Open();            SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(              <span class="str">&quot;StopJob&quot;</span>, sqlConnection);            sqlCommand.CommandType =              System.Data.CommandType.StoredProcedure;            sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@job_id&quot;</span>, jobId);            sqlCommand.ExecuteNonQuery();      }  }</pre>      <p>이제 작업자 역할의 Run() 메서드에 모두 연결해 보겠습니다. spTestJob 저장 프로시저는 오후 1시 직후에 하루에 한 번 실행하려고 합니다.</p>    <pre class="csharpcode"><span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Run()  {      Trace.WriteLine(<span class="str">&quot;WorkerRole1 entry point called&quot;</span>, <span class="str">&quot;Information&quot;</span>);        <span class="kwrd">while</span> (<span class="kwrd">true</span>)      {          DateTime nextExecutionTime = <span class="kwrd">new</span> DateTime(              DateTime. UtcNow.Year,               DateTime. UtcNow.Month, DateTime. UtcNow.Day,              13, 0, 0);          <span class="kwrd">if</span> (DateTime. UtcNow &gt; nextExecutionTime)          {              <span class="rem">// WWB: After 1:00 pm, Try to Get a Job Id.</span>              Guid? jobId = StartJob(<span class="str">&quot;TestJob&quot;</span>);              <span class="kwrd">if</span> (jobId.HasValue)              {                  Trace.WriteLine(<span class="str">&quot;Working&quot;</span>, <span class="str">&quot;Information&quot;</span>);                    <span class="rem">// WWB: This Method Has the Code That Execute</span>                  <span class="rem">// A Stored Procedure, The Actual Job</span>                  ExecuteTestJob();                    StopJob(jobId.Value);              }                <span class="rem">// WWB: Sleep For An Hour</span>              <span class="rem">// This Reduces The Calls To StartJob</span>              Thread.Sleep(3600000);          }          <span class="kwrd">else</span>          {              <span class="rem">// WWB: Check Every Minute</span>              Thread.Sleep(60000);          }      }  }</pre>      <p>위의 샘플에 오류 처리 코드가 없으므로 예외가 발생하면 어떻게 되나요? SQL Azure 일시적인 오류를 반환하면 어떻게 되나요? 작업자 역할이 데이터 센터의 다른 서버로 재활용되면 어떻게 되나요? 이러한 문제는 코드를 더 추가하여 이 시리즈의 3부에서 해결하려고 합니다.</p>    <h2>요약</h2>    <p>질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>'
