### YamlMime:Yaml
ms.openlocfilehash: c1a0c05065af753cd73ded3b5215b990a6163a59
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139905265"
Slug: using-explain-to-profile-slow-queries-in-azure-database-for-mysql
Title: EXPLAIN을 사용하여 Azure Database for MySQL에서 느린 쿼리 프로파일
Summary: Azure Database for MySQL은 Microsoft가 Azure에서 제공하는 PaaS(Platform as a Service) 솔루션입니다. MySQL(및 PostgreSQL)용 Azure 관리형 서비스를 사용하면 지능적이고 안전한 애플리케이션을 쉽게 빌드할 수 있습니다.
Content: >-
  <p><a href="https://azure.microsoft.com/en-us/services/mysql/">Azure Database for MySQL</a> 은 Microsoft가 Azure에서 제공하는 PaaS(Platform as a Service) 솔루션입니다. MySQL(및 <a href="https://azure.microsoft.com/en-us/services/postgresql/">PostgreSQL</a>)용 Azure 관리형 서비스를 사용하면 지능적이고 안전한 애플리케이션을 쉽게 빌드할 수 있습니다.</p>


  <p>Microsoft는 데이터베이스 성능을 최적화하기 위해 많은 작업을 수행했지만 때로는 간단한 쿼리가 전체 데이터베이스 성능에 영향을 주는 병 목이 될 수 있습니다. 다행히 MySQL은 클라이언트 쿼리를 프로파일하고 느린 쿼리의 근본 원인을 식별하는 데 도움이 되는 EXPLAIN 문 &ndash; 에 편리한 도구를 &ndash; 통합합니다. EXPLAIN 문을 사용하여 SQL 문이 실행되는 방법에 대한 정보를 가져올 수 있습니다. 이 정보를 사용하면 느리게 실행되는 쿼리와 그 이유를 프로파일할 수 있습니다.</p>


  <p>아래 출력은 EXPLAIN 문의 실행 예제를 보여 줍니다.</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT * FROM tb1 WHERE id=100\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 10.00
          Extra: Using where
  </pre>


  <p>이 예제에서 볼 수 있듯이 키 값은 NULL입니다. 즉, MySQL은 쿼리에 최적화된 인덱스를 찾을 수 없으며 전체 테이블 검색을 수행합니다. &#39;ID 열에 인덱스 추가를 통해 이 쿼리를 최적화할 수 있습니다.</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY (id);

  mysql&gt; EXPLAIN SELECT * FROM tb1 WHERE id=100\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ref
  possible_keys: id
            key: id
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  </pre>


  <p>새 EXPLAIN 문은 MySQL이 이제 인덱스를 사용하여 행 수를 1로 제한하여 검색 시간을 크게 단축한다는 것을 보여줍니다.</p>


  <h2>커버링 인덱스</h2>


  <p>포함 인덱스는 데이터 테이블에서 값 검색을 줄이기 위해 인덱스에 있는 쿼리의 모든 열로 구성됩니다. 이를 설명하기 위해 아래 GROUP BY 문을 참조하세요.</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using temporary; Using filesort
  </pre>


  <p>출력에서 볼 수 있듯이 적절한 인덱스를 사용할 수 없으므로 MySQL은 인덱스를 사용하지 않습니다. 출력에는 임시 사용도 표시됩니다&quot;. fileort&quot;를 사용하면 MySQL이 GROUP BY&quot; 절을 충족&quot;하는 임시 테이블을 만듭니다.</p>


  <p>c2&quot;에만 &quot;인덱스를 만들면 아무런 차이가 없으며 MySQL은 여전히 임시 테이블을 만들어야 합니다.</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY (c2);

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using temporary; Using filesort
  </pre>


  <p>이 경우 추가 데이터 조회를 제거하기 위해 인덱스의 c2&quot; 값을 &quot;직접 추가하여 c1&quot; 및 &quot;c2&quot; 둘 다&quot;에서 적용된 인덱스 만들기를 수행할 수 있습니다.</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY covered(c1,c2);

  mysql&gt; EXPLAIN SELECT MAX(c1), c2 FROM tb1 WHERE c2 LIKE &#39;%100&#39; GROUP BY c1\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: index
  possible_keys: covered
            key: covered
        key_len: 108
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using index
  </pre>


  <p>위의 EXPLAIN 계획에서 알 수 있듯이 이제 MySQL은 적용된 인덱스를 사용하고 임시 테이블을 만들지 않습니다.</p>


  <h2>결합된 인덱스</h2>


  <p>결합된 인덱스는 여러 열의 값으로 구성되며 인덱싱된 열의 값을 혼합하여 정렬된 행 배열로 간주할 수 있습니다. GROUP BY 문에서 유용할 수 있습니다.</p>


  <pre class="prettyprint">

  mysql&gt; EXPLAIN SELECT c1, c2 from tb1 WHERE c2 LIKE &#39;%100&#39; ORDER BY c1 DESC LIMIT 10\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 995789
       filtered: 11.11
          Extra: Using where; Using filesort
  </pre>


  <p>MySQL은 &quot;특히 많은 행을 정렬해야 하는 경우 다소 느린 파일&quot; 정렬 작업을 수행합니다. 이 쿼리를 최적화하기 위해 정렬 중인 두 열에 결합된 인덱스를 만들 수 있습니다.</p>


  <pre class="prettyprint">

  mysql&gt; ALTER TABLE tb1 ADD KEY my_sort2 (c1, c2);

  mysql&gt; EXPLAIN SELECT c1, c2 from tb1 WHERE c2 LIKE &#39;%100&#39; ORDER BY c1 DESC LIMIT 10\G

  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: tb1
     partitions: NULL
           type: index
  possible_keys: NULL
            key: my_sort2
        key_len: 108
            ref: NULL
           rows: 10
       filtered: 11.11
          Extra: Using where; Using index
  </pre>


  <p>이제 EXPLAIN 계획에는 인덱스가 이미 정렬되어 있으므로 MySQL에서 결합된 인덱스를 사용하여 추가 정렬을 방지할 수 있음을 보여 줍니다.</p>


  <h2>결론</h2>


  <p>EXPLAIN 및 다양한 유형의 인덱스를 사용하면 성능이 크게 향상될 수 있습니다. 테이블에 인덱스가 있다고 해서 반드시 MySQL이 쿼리에 사용할 수 있는 것은 아닙니다&rsquo;. 항상 EXPLAIN을 사용하여 가정의 유효성을 검사하고 인덱스를 사용하여 쿼리를 최적화해야 합니다.</p>


  <h2>추가 정보</h2>


  <ul>
      <li><a href="https://azure.microsoft.com/en-us/blog/performance-best-practices-for-using-azure-database-for-postgresql/">Azure Database for PostgreSQL 사용에 대한 성능 모범 사례</a></li>
  </ul>
