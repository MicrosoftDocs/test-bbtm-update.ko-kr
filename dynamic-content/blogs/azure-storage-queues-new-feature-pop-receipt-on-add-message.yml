### YamlMime:Yaml
ms.openlocfilehash: a251b28a71dc4587546c359b24122bcff30a8649
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139906500"
Slug: azure-storage-queues-new-feature-pop-receipt-on-add-message
Title: 'Azure Storage 큐 새 기능: 메시지 추가 Pop-Receipt'
Summary: Azure Storage 큐에서 메시지 추가 기능에 대한 Popreceipt 발표
Content: "<p><a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/versioning-for-the-azure-storage-services\">2016-05-31&rdquo; REST API 버전의 일부로&ldquo;</a>, 사용자가 일반적으로 요청한 기능인 메시지 추가 기능에 대한 팝 영수증을 도입했습니다.</p>\n\n<p>큐 서비스에 대한 팝 수신 기능은 개발자가 추가 처리를 위해 큐에 넣은 메시지를 쉽게 식별할 수 있는 유용한 도구입니다. &ldquo;2016-05-31&rdquo; 버전 이전에는 auser가 큐에서 메시지를 받을 때만&nbsp; 팝 영수증 값을 검색할 수 있습니다. 이를 간소화하기 위해 이제 사용자가 메시지를 먼저 검색할 필요 없이 메시지를 업데이트/삭제할 수 있는 메시지 배치(메시지 추가) 응답에서 팝 영수증 값을 사용할 수 있도록 합니다.</p>\n\n<p>다음은 .NET용 Azure Storage 클라이언트 라이브러리 8.0을 사용하여 이 새로운 기능을 사용하는 간단한 코드 조각입니다.</p>\n\n<pre class=\"prettyprint\">\n// create initial message\nCloudQueueMessage message = new CloudQueueMessage(&quot;<task id=\"123\" status=\"0\">&quot;);\n\n// add the message to the queue, but keep it hidden for 3 min\nqueue.AddMessage(message, null, TimeSpan.FromSeconds(180));\n//message.PopReceipt is now populated, and only this client can operate on the message until visibility timeout expires\n.\n.\n.\n// update the message (now no need to receive the message first, since we already have a PopReceipt for the message)\nmessage.SetMessageContent(&quot;<task id=\"123\" status=\"1\">&quot;);\nqueue.UpdateMessage(message, TimeSpan.FromSeconds(180), MessageUpdateFields.Content | MessageUpdateFields.Visibility);\n\n// remove the message using the PopReceipt before any other process sees it\nawait queue.DeleteMessageAsync(message.Id, message.PopReceipt);\n</task></task></pre>\n\n<p>클라우드 애플리케이션의 일반적인 문제는 비트랜잭션 리소스에서 업데이트를 조정하는 것입니다. 예를 들어 이미지 또는 비디오를 처리하는 애플리케이션은 다음을 수행할 수 있습니다.</p>\n\n<p>1.&nbsp;&nbsp; &nbsp;이미지 처리<br>\n2.&nbsp;&nbsp; &nbsp;blob에 업로드<br>\n3.&nbsp;&nbsp; &nbsp;테이블 엔터티에 메타데이터 저장</p>\n\n<p>다음 흐름을 사용하여 프로세스가 성공적으로 완료되면 큐 서비스를 사용하여 이러한 단계를 추적할 수 있습니다.</p>\n\n<p>1.&nbsp;&nbsp; &nbsp;큐 서비스에 메시지로 상태 추가<br>\n2.&nbsp;&nbsp; &nbsp;이미지 처리<br>\n3.&nbsp;&nbsp; &nbsp;Blob에 업로드<br>\n4.&nbsp;&nbsp; &nbsp;테이블 엔터티에 메타데이터 저장<br>\n5.&nbsp;&nbsp; &nbsp;모두 성공한 경우 메시지 삭제</p>\n\n<p>큐에 남아 있는 메시지는 단순히 처리에 실패한 이미지이며 정리를 위해 작업자가 사용할 수 있습니다. 5단계에서는 1단계에서 검색된 popreceipt 값으로 메시지를 삭제할 수 있으므로 위의 시나리오는 이제 메시지 추가 기능에서 popreceipt를 사용하여 더 간단해졌습니다.</p>\n\n<h2>Azure Cognitive Services에서 Face API를 사용하는 빠른 샘플</h2>\n\n<p>다음 샘플에서는 로컬 폴더에서 Blob Service로 사진을 업로드할 예정이며 Face API를 사용하여 사진에서 각 사람의&rsquo; 나이를 추정하고 테이블에 엔터티로 저장합니다. 이 프로세스는 큐에서 추적되고 완료되면 메시지가 팝 영수증 값으로 삭제됩니다. 샘플의 워크플로는 다음과 같습니다.</p>\n\n<p>1.&nbsp;&nbsp; &nbsp;testfolder에서 &lsquo;JPG 파일 찾기&rsquo;<br>\n2. 각 사진에 대해 2-7단계를 반복합니다.&nbsp;&nbsp; &nbsp;<br>\n3.&nbsp;&nbsp; &nbsp;이 사진의 처리를 나타내는 큐 메시지를 업로드. &nbsp;<br>\n4.&nbsp;&nbsp; &nbsp;Face API를 호출하여 사진에 있는 각 사용자의 나이를 예측합니다.<br>\n5.&nbsp;&nbsp; &nbsp;연령 정보를 테이블에 엔터티로 저장합니다.<br>\n6.&nbsp;&nbsp; &nbsp;하나 이상의 얼굴이 감지되면 이미지를 Blob에 업로드.<br>\n7.&nbsp;&nbsp; &nbsp;Blob 및 테이블 엔터티 작업이 모두 성공한 경우 팝 영수증을 사용하여 큐에서 메시지를 삭제합니다.</p>\n\n<pre class=\"prettyprint\">\n// Iterate over photos in &#39;testfolder&#39;\nvar images = Directory.EnumerateFiles(&quot;testfolder&quot;, &quot;*.jpg&quot;);\n\nforeach (string currentFile in images)\n{\n\n    string fileName = currentFile.Replace(&quot;testfolder\\\\&quot;, &quot;&quot;);\n\n    Console.WriteLine(&quot;Processing image {0}&quot;, fileName);\n\n    // Add a message to the queue for each photo. Note the visibility timeout\n    // as blob and table operations in the following process may take up to 180 seconds.\n    // After the 180 seconds, the message will be visible and a worker role can pick up \n    // the message from queue for cleanup. Default time to live for the message is 7 days.\n    CloudQueueMessage message = new CloudQueueMessage(fileName);\n    queue.AddMessage(message, null, TimeSpan.FromSeconds(180));\n\n    // read the file\n    using (var fileStream = File.OpenRead(currentFile))\n    {\n\n        // detect face and estimate the age\n        var faces = await faceClient.DetectAsync(fileStream, false, true, new FaceAttributeType[] { FaceAttributeType.Age });\n        Console.WriteLine(&quot; &gt; &quot; + faces.Length + &quot; face(s) detected.&quot;);\n\n        CloudBlockBlob blob = container.GetBlockBlobReference(fileName);\n\n        var tableEntity = new DynamicTableEntity(DateTime.Now.ToString(&quot;yyMMdd&quot;), fileName);\n\n        // iterate over detected faces\n        int i = 1;\n        foreach (var face in faces)\n        {\n\n            // append the age info as property in the table entity\n            tableEntity.Properties.Add(&quot;person&quot; + i.ToString(), new EntityProperty(face.FaceAttributes.Age.ToString()));\n            i++;\n\n        }\n\n        // upload the blob if a face was detected\n        if (faces.Length &gt; 0)\n            await blob.UploadFromFileAsync(currentFile);\n\n        // store the age info in the table\n        table.Execute(TableOperation.InsertOrReplace(tableEntity));\n\n        // delete the queue message with the pop receipt since previous operations completed successfully\n        await queue.DeleteMessageAsync(message.Id, message.PopReceipt);\n\n    }\n\n}\n</pre>\n\n<p><a href=\"https://github.com/Azure-Samples/storage-queue-dotnet-pop-receipt\">Github 샘플 리포지토리</a>의 전체 샘플을 확인하세요.</p>\n\n<p>언제나처럼 기능 요청이 있는 경우 아이디어를 제출하여 <a href=\"https://feedback.azure.com/forums/217298-storage\">피드백을 Azure Storage</a> 알려주세요.</p>"
