### YamlMime:Yaml
ms.openlocfilehash: 4b4c5f1e2aa8aca5fbe57e53a0ce854d833ff9b6
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139897256"
Slug: query-store-a-flight-data-recorder-for-your-database
Title: '쿼리 저장소: 데이터베이스에 대한 플라이트 데이터 레코더'
Summary: 이 게시물은 쿼리 성능 분석을 위해 쿼리 저장소 사용을 시작하는 데 도움이 됩니다.
Content: "쿼리 저장소는 SQL Server 2016의 새로운 기능이며, 이제 최신 버전의 Azure SQL Database V12에서 미리 보기로 사용할 수 있습니다. 쿼리 성능 문제 해결에 도움이 되도록 설계되었습니다.\n\n데이터베이스 크기가 커지면 성능 저하가 발생하는 것은 드문 일이 아닙니다. 쿼리 계획의 모든 변경 내용을 볼 수 없으면 회귀가 발생하는 이유와 나중에 이를 방지하기 위해 수행할 수 있는 작업을 파악하기가 어렵습니다. 문제 해결은 소중한 생산성 시간에서 몇 시간 또는 며칠이 걸릴 수 있습니다.\n\n비행기의 비행 데이터 레코더와 마찬가지로 쿼리 저장소는 모든 쿼리에 대한 자세한 기록 정보를 수집하고 제공하므로 문제를 진단하고 해결하는 시간을 줄여 성능 포렌식이 크게 간소화됩니다.\n\n수집된 데이터는 시간 창으로 구분되므로 시간이 지남에 따라 쿼리 성능이 변경되는 것을 관찰할 수 있습니다. 쿼리가 다른 계획을 생성하는 경우 쿼리 저장소를 사용하여 계획 변경 내용을 분석하고, 성능 저하 가능성을 식별하고, 쿼리 프로세서가 쿼리에 특정 계획을 사용하도록 강제할 수도 있습니다.\n\nTransact-SQL 통해 쿼리 저장소에 액세스할 수 있습니다. 수집된 데이터를 분석하고 기능을 관리하려면 SQL Server Management Studio 또는 SQL Server Data Tools 설치해야 합니다.\n\nSQL Server <strong><a href=\"https://www.microsoft.com/en-us/evalcenter/evaluate-sql-server-2016?i=1\" target=\"_blank\">2016 Management Studio Community Technology Preview 2</a></strong>를 사용하는 <strong>것이 좋습니다</strong>. 특히 쿼리 저장소용으로 설계된 새 사용자 인터페이스가 함께 제공되기 때문입니다<strong>.</strong>\n\n쿼리 성능 분석을 위해 쿼리 저장소 사용을 시작하는 방법을 살펴보겠습니다.\n<h2>1단계: 데이터베이스에 대해 쿼리 저장소 사용</h2>\n쿼리 저장소는 데이터베이스 범위 기능이므로 먼저 모니터링하려는 데이터베이스에 사용하도록 설정해야 합니다. 사용하도록 설정하면 쿼리 저장소는 수집된 데이터를 데이터베이스 스토리지 공간 내에 저장합니다. SQL Database 기능을 사용하도록 설정하려면 <strong>마스터</strong> 데이터베이스에 연결된 동안 Azure SQL Server 인스턴스에 연결하고 다음 스크립트를 실행합니다.\n<pre class=\"prettyprint\">ALTER DATABASE &lt;database_name&gt; SET QUERY_STORE = ON;</pre>\n또는 SSMS 2016 CTP2를 실행하는 경우 사용자 인터페이스에서 기능을 사용하도록 설정할 수 있습니다. 대상 데이터베이스를 마우스 오른쪽 단추로 클릭하고 속성/쿼리 저장소 탭을 클릭합니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/Query-Store-Properties.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"SSMS 쿼리 저장소 사용\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Query-Store-Properties_thumb.png\" alt=\"Query Store: flight data recorder for your database\" width=\"480\" height=\"397\" /></a>\n\n요구 사항에 맞게 조정하기 위해 다음 옵션의 기본값을 변경할 수 있습니다.\n<ul>\n <li><strong>최대 크기 MB</strong> - 쿼리 저장소가 데이터베이스 내에서 사용할 데이터 공간에 대한 제한입니다. 워크로드에서 많은 수의 다른 쿼리 또는 계획을 생성하거나 더 긴 기간 동안 쿼리 기록을 유지하려는 경우 기본값(<strong>100MB</strong>)이 충분하지 않을 수 있습니다. 디스크 크기가 제한을 초과할 때 쿼리 저장소가 \"읽기 전용\" 모드로 전환되지 않도록 현재 공간 사용량을 추적하고 구성 값을 늘립니다.</li>\n <li><strong>통계 컬렉션 간격</strong>: 런타임 데이터의 세분성 수준을 정의합니다(기본값은 <strong>1시간</strong>). 더 세분성이 필요하지만 쿼리 저장소 데이터의 크기에 직접적인 영향을 주는 경우 더 낮은 값을 사용하는 것이 좋습니다.</li>\n</ul>\n다른 옵션에 대한 자세한 내용은 쿼리 저장소에 대한 <a href=\"https://aka.ms/querystore\">MSDN 설명서를</a> 참조하세요.\n<h2>2단계: 워크로드 실행 및 데이터 분석 수행</h2>\n이 단계에서는 쿼리 저장소를 사용하여 워크로드에서 가장 많은 리소스를 사용하는 쿼리를 쉽게 식별하는 방법을 보여 줍니다.\n\nSSMS 2016 CTP2를 실행하는 경우 개체 탐색기의 데이터베이스 노드 아래에 있는 <strong>쿼리 저장소</strong> 하위 폴더에 있는 <strong>상위 리소스 사용 쿼리</strong>를 두 번 클릭합니다. 그러면 시스템에서 가장 비용이 많이 드는 쿼리에 대한 자세한 정보가 포함된 새 창이 열립니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/QDS-Top-Resource-Consuming-Qrys-Compact.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"리소스 사용량 상위 쿼리\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/QDS-Top-Resource-Consuming-Qrys-Compact_thumb.png\" alt=\"Query Store: A flight data recorder for your database\" width=\"610\" height=\"328\" /></a>\n\n사용자 인터페이스는 상위 리소스 소비 쿼리를 나타내는 막대 그래프(왼쪽), 선택한 쿼리에 대한 계획 요약(오른쪽) 및 선택한 계획에 대한 시각적 쿼리 계획(아래쪽), 이렇게 세 개의 창으로 구분되어 있습니다. <strong>구성</strong> 을 클릭하여 분석할 쿼리 수 및 관심 있는 시간 간격을 제어할 수 있습니다. 또한 다양한 리소스 소비 차원(기간, CPU, 메모리, IO, 실행 횟수)과 기준선(평균, 최소값, 최대값, 합계, 표준 편차) 간에 선택할 수 있습니다.\n\n쿼리에 대한 도구 설명은 쿼리 텍스트, 쿼리 ID(내부 식별), 평균 기간, 실행 횟수 및 다양한 계획의 수에 대한 세부 정보를 제공합니다. 오른쪽의 계획 요약을 보고 실행 기록을 분석한 후 다른 계획과 해당 런타임 통계에 대해 자세히 알아볼 수 있습니다. 아래쪽 창을 사용하여 다른 계획 셰이프를 검사하거나 나란히 렌더링된 시각적으로 비교합니다( <strong>비교</strong> 단추 사용).\n\n<strong>거래 SQL 분석</strong>\n\n2016년 CTP2 이전에 SQL Server Management Studio 실행하는 경우 Transact-SQL 스크립트를 사용하여 가장 많은 리소스를 사용하는 쿼리를 식별할 수 있습니다. <span style=\"line-height: 1.5;\">쿼리 저장소는 분석에 대해 다음 보기를 노출합니다.</span>\n<table>\n<tbody>\n<tr>\n<td width=\"274\"><strong>보기</strong></td>\n<td width=\"350\"><strong>설명</strong></td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_store_query_text </strong></td>\n<td width=\"350\">캡처된 쿼리 텍스트에 대한 정보입니다.</td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_context_settings</strong></td>\n<td width=\"350\">의미 체계에 영향을 주는 컨텍스트 설정의 다양한 런타임 조합(계획 셰이프, 언어 ID에 영향을 주는 SET 옵션, ...)</td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_store_query</strong></td>\n<td width=\"350\">쿼리 텍스트와 컨텍스트 설정의 고유한 조합</td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_store_plan</strong></td>\n<td width=\"350\">SQL Server 시스템에서 쿼리를 실행하는 데 사용하는 계획에 대한 정보입니다.</td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_store_runtime_stats_interval</strong></td>\n<td width=\"350\">쿼리 저장소에서 만든 집계 간격(시간 창)입니다.</td>\n</tr>\n<tr>\n<td width=\"274\"><strong>sys.query_store_runtime_stats</strong></td>\n<td width=\"350\">실행된 쿼리 계획에 대한 런타임 통계( 간격 단위로 집계됨)</td>\n</tr>\n</tbody>\n</table>\n다음 스크립트를 실행하여 <em>실행 후 마지막 1시간 이내에 총 기간을 기준으로 25개의 쿼리를</em> 가져옵니다.\n<pre class=\"prettyprint\">WITH AggregatedDurationLastHour\nAS\n(\n   SELECT q.query_id, SUM(count_executions * avg_duration) AS total_duration,\n   COUNT (distinct p.plan_id) AS number_of_plans\n   FROM sys.query_store_query_text AS qt JOIN sys.query_store_query AS q \n   ON qt.query_text_id = q.query_text_id\n   JOIN sys.query_store_plan AS p ON q.query_id = p.query_id\n   JOIN sys.query_store_runtime_stats AS rs ON rs.plan_id = p.plan_id\n   JOIN sys.query_store_runtime_stats_interval AS rsi \n   ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id\n   WHERE rsi.start_time &gt;= DATEADD(hour, -1, GETUTCDATE()) \n   AND rs.execution_type_desc = 'Regular'\n   GROUP BY q.query_id\n)\n,OrderedDuration\nAS\n(\n   SELECT query_id, total_duration, number_of_plans, \n   ROW_NUMBER () OVER (ORDER BY total_duration DESC, query_id) AS RN\n   FROM AggregatedDurationLastHour\n)\nSELECT qt.query_sql_text, object_name(q.object_id) AS containing_object,\ntotal_duration AS total_duration_microseconds, number_of_plans,\nCONVERT(xml, p.query_plan) AS query_plan_xml, p.is_forced_plan, p.last_compile_start_time,q.last_execution_time\nFROM OrderedDuration od JOIN sys.query_store_query AS q ON q.query_id  = od.query_id\nJOIN sys.query_store_query_text qt ON q.query_text_id = qt.query_text_id\nJOIN sys.query_store_plan p ON q.query_id = p.query_id\nWHERE OD.RN &lt;=25 ORDER BY total_duration DESC</pre>\n쿼리는 아래 그림과 같이 데이터 집합을 반환합니다. Transact-SQL 스크립트를 기반으로 추가 분석을 위해 이 결과를 직접 또는 입력으로 사용합니다. MSDN의 <a href=\"https://aka.ms/querystore\">쿼리 저장소</a>는 더 많은 예제를 제공합니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/top-25-Query-Results.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"상위 25개 리소스 사용 쿼리\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/top-25-Query-Results_thumb.png\" alt=\"Query Store: A flight data recorder for your database\" width=\"610\" height=\"135\" /></a>\n<h2>3단계: 회귀된 쿼리에 대한 성능 수정</h2>\n워크로드에 다른 계획 및 가변 성능으로 실행되는 쿼리가 포함된 경우 쿼리 저장소를 사용하여 SQL Server 향후 실행 시 항상 최적의 계획을 사용하도록 강제할 수 있습니다. 아래 그림에서는 이러한 쿼리 중 하나에 대해 실행 기록이 어떻게 표시되는지 보여 줍니다(<strong>query_id</strong> 및 <strong>plan_id</strong> 수집된 모든 쿼리 및 계획에 쿼리 저장소에 의해 할당된 영구 내부 식별자임).\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/Plan-History-Compact.-png.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"선택한 쿼리에 대한 실행 기록\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Plan-History-Compact.-png_thumb.png\" alt=\"Query Store: A flight data recorder for your database\" width=\"610\" height=\"261\" /></a>\n\n쿼리 1의 계획 요약 창은 쿼리에 두 개의 계획이 있고 계획 ID = 1이 있는 실행이 기간 측면에서 훨씬 더 낫다는 것을 명확하게 보여 줍니다. 계획 ID = 1이 선택되면 [<strong>계획 강제</strong> 적용] 단추를 클릭하여 SQL Server 항상 해당 계획을 사용하는지 확인합니다. 이제 강제 계획이 확인 표시와 함께 나타나고 계획 요약은 후속 실행에서 사용되고 있음을 보여 줍니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/Plan-forcing-compact.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"계획 강제 적용 후 실행 기록\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Plan-forcing-compact_thumb.png\" alt=\"Query Store: A flight data recorder for your database\" width=\"610\" height=\"379\" /></a>\n\n<strong>Transact-SQL 강제 사용 계획</strong>\n\n2016년 CTP2 이전에 SQL Server Management Studio 실행하는 경우 쿼리 저장소 뷰를 직접 쿼리하여 계획 회귀로 쿼리를 식별할 수 있습니다. 위의 스크립트는 여러 계획이 있는 쿼리를 반환하고 비교를 위해 모든 측정 간격에 대한 계획당 평균 기간을 포함하도록 약간 수정되었습니다.\n<pre class=\"prettyprint\">WITH AggregatedDurationLastHour\nAS\n(\n   SELECT q.query_id, SUM(count_executions * avg_duration) AS total_duration,\n   COUNT (distinct p.plan_id) AS number_of_plans\n   FROM sys.query_store_query_text AS qt JOIN sys.query_store_query AS q \n   ON qt.query_text_id = q.query_text_id\n   JOIN sys.query_store_plan AS p ON q.query_id = p.query_id\n   JOIN sys.query_store_runtime_stats AS rs ON rs.plan_id = p.plan_id\n   JOIN sys.query_store_runtime_stats_interval AS rsi \n   ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id\n   WHERE rsi.start_time &gt;= DATEADD(hour, -1, GETUTCDATE()) \n   AND rs.execution_type_desc = 'Regular'\n   GROUP BY q.query_id\n)\n,OrderedDuration\nAS\n(\n   SELECT query_id, total_duration, number_of_plans, \n   ROW_NUMBER () OVER (ORDER BY total_duration DESC, query_id) AS RN\n   FROM AggregatedDurationLastHour\n)\nSELECT qt.query_sql_text, object_name(q.object_id) AS containing_object, q.query_id,\np.plan_id,rsi.start_time as interval_start, rs.avg_duration,\nCONVERT(xml, p.query_plan) AS query_plan_xml\nFROM OrderedDuration od JOIN sys.query_store_query AS q ON q.query_id  = od.query_id\nJOIN sys.query_store_query_text AS qt ON q.query_text_id = qt.query_text_id\nJOIN sys.query_store_plan AS p ON q.query_id = p.query_id\nJOIN sys.query_store_runtime_stats AS rs ON rs.plan_id = p.plan_id\nJOIN sys.query_store_runtime_stats_interval AS rsi ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id\nWHERE rsi.start_time &gt;= DATEADD(hour, -1, GETUTCDATE())\nAND OD.RN &lt;=25 AND number_of_plans &gt; 1\nORDER BY total_duration DESC, query_id, rsi.runtime_stats_interval_id, p.plan_id</pre>\n이는 가져온 데이터 집합의 일부입니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2015/06/01/Multiple-Plans-Query-Results.png\"><img style=\"float: none; margin-left: auto; display: block; margin-right: auto;\" title=\"여러 계획이 있는 상위 리소스 사용 쿼리에 대한 쿼리 결과\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Multiple-Plans-Query-Results_thumb.png\" alt=\"Query Store: A flight data recorder for your database\" width=\"610\" height=\"135\" /></a>\n\n데이터 집합에서 성능이 다른 두 계획으로 쿼리 ID = 1이 실행되었음을 확인할 수 있습니다(또한 결과 표에서 <strong>query_plan_xml</strong> 열을 클릭하여 차이를 시각적으로 검사할 수 있습니다). 계획 ID가 1(녹색 사각형)인 계획은<em> 모든 측정 간격</em>에 대해 계획 ID =2(빨간색 사각형)보다 평균 2-3 더 나은 성능(즉<strong>, avg_duration</strong> 감소)을 표시합니다.\n\n따라서 쿼리 ID = 1에 대해 계획 ID = 1을 적용하려고 할 수 있습니다.\n<pre class=\"prettyprint\">EXEC sys.sp_query_store_force_plan @query_id = 1, @plan_id = 1;</pre>\n<h2>다음 단계</h2>\n쿼리 저장소에 대한 자세한 내용은 온라인 <a href=\"https://aka.ms/querystore\">미리 보기 설명서</a> 및 <a href=\"https://channel9.msdn.com/Shows/Data-Exposed/Query-Store-in-SQL-Server-2016\" target=\"_blank\">Channel 9 토론을</a> 확인하세요.\n\n아래에 질문과 의견을 게시하세요. 앞으로 기능을 개선하는 데 도움이 되는 피드백을 기다리고 있습니다."
