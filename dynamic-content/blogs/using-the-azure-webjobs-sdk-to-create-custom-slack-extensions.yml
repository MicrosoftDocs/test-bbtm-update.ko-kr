### YamlMime:Yaml
ms.openlocfilehash: abf873161eaa5966c99abce866474e2dd18e2aca
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903430"
Slug: using-the-azure-webjobs-sdk-to-create-custom-slack-extensions
Title: Azure WebJobs SDK를 사용하여 사용자 지정 Slack 통합 만들기
Summary: 이 블로그 게시물에서는 WebJobs 확장을 사용하여 Slack과 대화하는 방법을 살펴보겠습니다. Slack은 "실시간 메시징" API 또는 들어오는 & 나가는 웹후크를 사용하는 멋진 통합 스토리가 있는 팀을 위한 메시징 앱입니다.
Content: "<p>오늘날 개발자와 기업은 이전보다 더 많은 SaaS 환경을 사용하고 있습니다. SaaS 서비스의 많은 사용자는 이러한 SaaS 서비스의 기능을 사용자 지정하고 해당 비즈니스 애플리케이션으로 가져와야 하는 위치에 빠르게 있습니다. SaaS 서비스 확장을 가장 먼저 찾는 곳은 <a href=\"https://azure.microsoft.com/en-us/services/app-service/\">Azure App Service</a>와 같은 PaaS 서비스입니다. Azure App Service를 사용하면 엔터프라이즈급 인증 또는 민첩한 개발 작업 개발 주기와 같은 단순하면서도 중요한 기능이 기본적으로 작동합니다. Azure 및 일반적으로 Microsoft에서는 다양한 방법으로 다른 서비스와 통합할 수 있습니다. 가장 강력한 방법 중 하나는 Azure App Service WebJobs입니다.</p>\n\n<p>이 블로그 게시물에서는 WebJobs 확장을 사용하여 <a href=\"https://slack.com/\">Slack</a>과 대화하는 방법을 살펴볼&#39;있습니다. Slack은 실시간 메시징 API 또는 <a href=\"https://api.slack.com/incoming-webhooks\">들어오는</a> &amp; <a href=\"https://api.slack.com/outgoing-webhooks\">나가는</a> 웹후크를 사용하여 <a href=\"https://api.slack.com/rtm\">&quot;멋진 통합 스토리를 제공하는 팀을 위한 메시징&quot;</a> 앱입니다. WebJobs SDK를 사용하여 Slack에서 발신 및 <a href=\"https://api.slack.com/slash-commands\">&quot;슬래시 명령&quot;</a> 웹후크를 수신 대기하여 애플리케이션 내에서 프로세스를 시작할 수 있습니다. 또한 SDK 내에서 하루도 채 지나지 않아 작성한 사용자 지정 WebJobs 확장을 사용하여 Slack에 직접 메시지를 보낼 수 있습니다.</p>\n\n<p>&#39;코드에 대해 알아보겠습니다.</p>\n\n<h2 id=\"get-the-code-for-the-sample\">샘플에 대한 코드 가져오기</h2>\n\n<p>소스 코드에서 따라가려면 GitHub 리포지</a>토리를 <a href=\"https://github.com/christopheranderson/azure-webjobs-sdk-extensions-slack\"><code>azure-webjobs-sdk-extensions-slack</code> 포크하고 복제하는 것이 좋습니다. GitHub 리포지토리에서 이 샘플에 대한 NuGet 가져오는 방법도 알아볼 수 있습니다.</p>\n\n<h2 id=\"using-webjobs-to-send-message-to-slack-webhooks\">WebJobs를 사용하여 Slack WebHook에 메시지 보내기</h2>\n\n<p>Slack으로 메시지를 보내려면 인바운드 웹후크에 대한 Slack 사용자 지정 통합 메뉴에서 해당 엔드포인트를 설정한&#39;후에 들어오는 웹후크 엔드포인트에 대한 HTTP 호출만&#39;. Slack용 Azure WebJobs 확장을 사용하면 애플리케이션에 대해 수행할&#39;있는 다양한 자동화된 작업 내에서 해당 메시지의 서식을 쉽게 지정하고 Slack으로 보낼 수 있습니다. 일부 팀에서는 Slack을 사용하여 다양한 Stack Overflow 태그 및 포럼의 질문과 User Voice의 고객 피드백을 모니터링하는 데 도움을&#39;. IFTTT와 같은 서비스에서 Slack으로 데이터를 보내는 방법은 여러 가지가 있지만 일부 사용자 지정 코드를 작성해야 할 때마다 해당 코드를 호스트할 장소를 찾는 것이 어려울 수 있습니다. &#39;WebJobs에서 Slack으로 메시지를 보내는 것이 얼마나 쉬운지 살펴보겠습니다.</p>\n\n<p>프로젝트에 대한 참조를 추가한 후&#39;Azure WebJobs Extension for Slack 사용을 시작하려면 WebJobs JobHost 구성에서 사용하도록 설정해야 합니다.</p>\n\n<pre class=\"prettyprint\">\n<code>var config = new JobHostConfiguration();\nvar slackConfig = new SlackConfiguration();\n\n// These are optional and will be applied if no other value is specified.\nslackConfig.WebHookUrl = &quot;&quot;;\n// IT IS A BAD THING TO HARDCODE YOUR WEBHOOKURL, USE THE APP SETTING &quot;AzureWebJobsSlackWebHookKeyName&quot;\nslackConfig.IconEmoji = &quot;:taco:&quot;;\nslackConfig.Username = &quot;Destroy All Humans&quot;;\nslackConfig.Channel = &quot;#bots_only_no_hummies&quot;;\n\nconfig.UseSlack(slackConfig);\n\nvar host = new JobHost(config);\n// The following code ensures that the WebJob will be running continuously\nhost.RunAndBlock();\n</code></pre>\n\n<p>사용하도록 설정한&#39;WebJobs 함수 내에서 Slack 바인딩을 사용할 수 있습니다. 함수에서 Slack 바인딩 사용을 시작하는 것은 매우 간단합니다. WebJob SDK 함수에 Slack 바인딩을 추가하기만 하면 됩니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public void SimpleSlackBinding([WebHookTrigger] Message m,\n            [Slack(Text = &quot;{Text}&quot;, IconEmoji = &quot;{IconEmoji}&quot;)] SlackMessage message)\n</code></pre>\n\n<p>위의 코드 조각에서는 전역 기본 설정을 <code>text</code> <code>iconEmoji</code> 사용하여 SlackMessage를 만들고 트리거에 의해 생성된 메시지 POCO의 적절한 항목으로 과도하게 작성되는 Slack 바인딩을 추가한&#39;있습니다(이 경우 웹후크이지만 트리거일 수 있음).</p>\n\n<p><code>SlackMessage</code> 제공된 개체는 Slack으로 전송됩니다. 함수가 완료되면 콘텐츠를 JSON 본문으로 구문 분석하고 이전에 지정한 Slack 웹후크 URL에 게시합니다.</p>\n\n<p>다음은 전체 기능이 노출된 샘플을&#39;.</p>\n\n<pre class=\"prettyprint\">\n<code>public void FullSlackBinding([WebHookTrigger] Message m,\n    [Slack(Channel = &quot;{Channel}&quot;, \n            IconEmoji = &quot;{IconEmoji}&quot;, \n            IsMarkdown = false, \n            Text =&quot;{Text}&quot;, \n            Username = &quot;{Username}&quot;, \n            WebHookUrl = &quot;{WebHookUrl}&quot;)] SlackMessage message,\n    TextWriter log\n    )\n{\n    // Further customize Slack Message here. i.e. add attachments, etc.\n    // More info on the SlackMessage object on the GitHub project: https://github.com/nerdfury/Slack.Webhooks\n\n    // Continue to set/manipulate properties on the Slack Message, programatically\n    message.Text += &quot;WebJobs are Grrrreat!&quot;;\n    message.IconEmoji = &quot;:troll:&quot;;\n\n    // For example, add attachments. See the Slack API docs for more info: https://api.slack.com/docs/attachments\n    message.Attachments.Add(new SlackAttachment\n    {\n        Fallback = &quot;Required plain-text summary of the attachment.&quot;,\n        Color = &quot;#36a64f&quot;,\n        pre class=&quot;prettyprint&quot;text = &quot;Optional text that appears above the attachment block&quot;,\n        AuthorName = &quot;Bobby Tables&quot;,\n        AuthorLink = &quot;https://flickr.com/bobby/&quot;,\n        AuthorIcon = &quot;https://flickr.com/icons/bobby.jpg&quot;,\n        Title = &quot;Slack API Documentation&quot;,\n        TitleLink = &quot;https://api.slack.com/&quot;,\n        Text = &quot;Optional text that appears within the attachment&quot;,\n        Fields = new List&lt;SlackField&gt;\n        {\n            new SlackField\n            {\n                Title = &quot;Priority&quot;,\n                Value = &quot;High&quot;,\n                Short = true\n            },\n            new SlackField\n            {\n                Title = &quot;Assigned&quot;,\n                Value = &quot;Bobby&quot;,\n                Short = true\n            }\n        },\n        ImageUrl = &quot;https://my-website.com/path/to/image.jpg&quot;,\n        ThumbUrl = &quot;https://example.com/path/to/thumb.png&quot;\n    });\n}\n</code></pre>\n\n<h2 id=\"using-webjobs-to-listen-to-slack-webhooks\">WebJobs를 사용하여 Slack 웹후크 듣기</h2>\n\n<p>Slack에 메시지를 보내는 것은 좋지만 가장 멋진 시나리오 중 하나는 Slack을 사용하여 애플리케이션 내의 초기 워크플로를 사용하는 것입니다. WebJobs를 사용하여 이를 달성하기 위해 바인딩을 <code>WebHookTrigger</code> 사용할 수 있습니다. pre class=&quot;prettyprintvious&quot; 예제에서 볼 수 있듯이 서비스에서 사용할 POCO 개체를 출력하는 개체를 바인딩 <code>WebHookTrigger</code> 할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger] WebHookContext context\n</code></pre>\n\n<p>위의 코드 샘플에서는 특성을 추가하여 <code>WebHookTrigger</code> 간단한 방식으로 웹후크를 만들 수&#39;있음을 알 수 있습니다. 이 웹후크에 액세스하는 경로는 다음과 <code>https://{uid}:{pwd}@{site}/api/continuouswebjobs/{job}/passthrough/{*path}</code>같이 스타일이 지정됩니다.</p>\n\n<p>웹후크 URL을 수동으로 생성하려면 다음 토큰을 바꿔야 합니다.</p>\n\n<ul>\n <li><strong>uid</strong> : 게시 자격 증명의 사용자 ID입니다. <a href=\"https://blog.davidebbo.com/2015/05/scheduled-webjob.html\">이 블로그 게시물에 자세히 설명된 대로</a> 포털에서 게시 자격 증명을 다운로드할 수 있습니다.</li>\n <li><strong>pwd</strong> : 게시 자격 증명의 암호입니다.</li>\n <li><strong>사이트</strong> : SCM 사이트(예: myapp.scm.azurewebsites.net)</li>\n <li><strong>job</strong> : Continuous WebJob의 이름</li>\n <li><strong>path</strong> : 호출할 특정 웹후크 함수를 식별하는 경로입니다. 규칙에 따라 {ClassName}/{MethodName}이지만 특성을 통해 명시적으로 재정의 <code>WebHookTrigger</code> /지정할 수 있습니다.</li>\n</ul>\n\n<p>&#39;webhook를 듣고 <code>slack/webhook</code>싶다고 가정해 보겠습니다. 이 작업은 특성의 일부로 경로를 전달하여 수행할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context\n</code></pre>\n\n<p>전체 설명서는 <code>WebHookTrigger</code> <a href=\"https://github.com/Azure/azure-webjobs-sdk-extensions#webhooks\">WebJobs SDK 확장 GitHub 리포지토리</a>에서 찾을 수 있습니다. GitHub WebHooks 트리거의 기능과 아웃을 알아볼 수 있습니다. 다음 섹션에서는 들어오는 Slack 웹후크와 나가는 Slack 웹후크를 함께 가져오는 이 샘플을 확장할&#39;있습니다.</p>\n\n<h2 id=\"bringing-it-all-together-slack-slash-commands\">모두 함께 가져오기: Slack 슬래시 명령</h2>\n\n<p>종단 간 상황이 어떻게 생겼는지 살펴보겠습니다. 슬래시 명령을 사용하여 WebJob <code>WebHooksTrigger</code> 을 호출한 다음 Azure Storage 큐를 통해 관리하는 워크플로를 시작할 수 있습니다. 그런 다음 워크플로는 슬래시 명령이 제공하는 회신 URL에 응답할 수 있습니다. 유의해야 할 점은 현재 회신 URL이 약 5분 동안만 유효하다는 것입니다. 따라서 작업이 그보다 더 오래 실행되도록 하려면 기존 수신 웹후크를 사용해야 합니다. 이 예제에서는 두 개의 정수를 허용하는 슬래시 명령이&#39;. 하나는 작업 항목 수를 지정하고 다른 하나는 수행할 작업량을 지정합니다.</p>\n\n<p>&#39;시작 <code>WebHookTrigger</code>합니다. 수신 대기 <code>slack/webhook</code> 를 <code>WebHookTrigger</code> 원하며 attribtue를 통해 새 큐 메시지 집합을 <code>Queue</code> 출력하려고 합니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context,\n    [Queue(&quot;SlackWork&quot;)] ICollector&lt;SlackWork&gt; messages\n)\n</code></pre>\n\n<p>함수 매개 변수 및 특성을 설정하면&#39;함수 내의 busines 논리에 대해 생각해 보겠습니다. 명령 텍스트에서 두 정수를 읽고 생성하라는&#39;큐 작업 항목 수를 만들려고 합니다. 수행할 작업을 repre class=&quot;prettyprintsentsents&quot;하는 도우미 POCO 클래스를 만들&#39;있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public class SlackWork\n{\n    public int id { get; set; }\n    public string username { get; set; }\n    public int work { get; set; }\n    public string replyUrl { get; set; }\n}\n</code></pre>\n\n<p>또한 본문을 사용하기 <code>x-url-form-urlencoded</code> 때문에 Slack을 구문 분석하기 위한 도우미 함수를 만들 것이며 WebJobs는 아직 POCO로 자동 구문 분석하지&#39;않습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>private bool TryParseSlackBody(string body, out NameValueCollection nvc)\n{\n    body = body.Replace(&#39;\\n&#39;, &#39;&amp;&#39;);\n    body = body.Replace(&quot;\\r&quot;, &quot;&quot;);\n    nvc = System.Web.HttpUtility.ParseQueryString(body);\n\n    return nvc.Count &gt; 0;\n}\n</code></pre>\n\n<p>이제 함수를 작성하여 명령 텍스트를 구문 분석하고, 오류 사례를 처리하고, 큐 작업 항목을 만들 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public async Task SlackIniatedWebHook([WebHookTrigger(&quot;slack/webhook&quot;)] WebHookContext context,\n    [Queue(&quot;SlackWork&quot;)] ICollector&lt;SlackWork&gt; messages\n)\n{\n    // Try and parse the Slack Message Body with simple helper method\n    NameValueCollection nvc;\n    if(TryParseSlackBody(await context.Request.Content.ReadAsStringAsync(), out nvc))\n    {\n        Regex rgx = new Regex(&quot;(\\\\d+) (\\\\d+)&quot;);\n        Match match = rgx.Match(nvc[&quot;text&quot;]);\n        int count;\n        int work;\n        if(int.TryParse(match.Groups[1].Value, out count) &amp;&amp; int.TryParse(match.Groups[2].Value, out work))\n        {\n            for (int i = 0; i &lt; count; i++)\n            {\n                messages.Add(new SlackWork { id = i, work = work, replyUrl = nvc[&quot;response_url&quot;], username = nvc[&quot;user_name&quot;] });\n            }\n\n            // All good, quickly send an affirmative response\n            context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n            {\n                Content = new StringContent(&quot;Message received! Processing ...&quot;)\n            };\n        }\n        else\n        {\n            // Not good, quick send a negative response\n            context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n            {\n                Content = new StringContent(&quot;Incorrect format - please pass two numbers along - i.e. /cmd 2 30&quot;)\n            };\n\n            // We can stop here for the failure case\n            return;\n        }\n    }\n    else\n    {\n        // Not good, quick send a negative response\n        context.Response = new Httpre class=&quot;prettyprint&quot;sponseMessage(HttpStatusCode.Accepted)\n        {\n            Content = new StringContent(&quot;Something went wrong. :(&quot;)\n        };\n\n        // We can stop here for the failure case\n        return;\n    }\n\n\n}\n</code></pre>\n\n<p>이제 작업 항목을 처리하기 위해 새 큐 항목에서 시작할 항목이 있어야 <code>QueueTrigger</code> 합니다. 함수는 전달된 작업&quot;량(추가하기&#39;일부 임의&quot;성 요소)에 대해 절전 모드로 전환됩니다. 수행할 작업이 10보다 크면 Slack 이모<code>:tada:</code>지를 변경할&#39;있습니다. 함수 매개 변수 및 attribtues를 통해 Slack 메시지에 대한 텍스트를 만들 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>public void ProcessSlackWork([QueueTrigger(&quot;SlackWork&quot;)] SlackWork work, \n    [Slack(WebHookUrl = &quot;{replyUrl}&quot;, Text = &quot;Item: {id} finished processing {work} seconds of work.&quot;, IconEmoji = &quot;:sleepy:&quot;, Channel = &quot;@{username}&quot;)] SlackMessage slack,\n    TextWriter log\n)\n{\n    log.WriteLine($&quot;Processing id: {work.id} - working for {work.work} seconds&quot;);\n\n\n    if(work.work &gt; 10)\n    {\n        slack.IconEmoji = &quot;:tada:&quot;;\n    }\n\n    int sleepFor = (work.work + (int)(.2 * work.work * (new Random()).NextDouble())) * 1000;\n    log.WriteLine($&quot;Processing id: {work.id} - actually working for {sleepFor} seconds, because of some made up, factor of error&quot;);\n    Thread.Sleep(sleepFor);\n}\n</code></pre>\n\n<p>WebJob을 실행하고 타격 <code>localhost:3000/slack/webhook</code>하여 로컬에서 테스트할 수 있습니다. 아래와 같은 샘플 본문을 전달할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n<code>token=gIkuvaNzQIHg97ATvDxqgjtO\nteam_id=T0001\nteam_domain=example\nchannel_id=C2147483705\nchannel_name=test\nuser_id=U2147483697\nuser_name=Steve\ncommand=/cmd\ntext=3 30\nresponse_url=https://hooks.slack.com/commands/1234/5678\n</code></pre>\n\n<p>다음으로, Azure App Service에 WebJob을 배포합니다. 이를 위해 Azure.com Visual Studio <a href=\"https://azure.microsoft.com/en-us/documentation/articles/websites-dotnet-deploy-webjobs/\">통해 WebJob을 Azure에 배포하는</a> 단계를 수행할 수 있습니다.</p>\n\n<p>마지막으로&#39;슬래시 명령을 추가합니다. <a href=\"https://slack.com/apps\">Slack 앱 디렉터리</a>로 이동하고 오른쪽 위에서 구성&quot;을 클릭합니다&quot;. 여기에서 Slack 팀을 선택한 다음 사용자 지정 통합으로 이동 &quot;해야 합니다&quot;. 이 메뉴에서 슬래시 명령&quot;으로 이동하고 &quot;구성&quot; 추가를 &quot;클릭할 수 있습니다. 페이지의 단계에 따라 위의 섹션에 설명된 패턴으로 URL을 추가합니다. 원하는 키워드를 사용할 <code>/command</code>&#39;있습니다.</p>\n\n<p>이제 수행할 작업량과 작업 기간을 나타내는 두 개의 정수로 명령을 호출하여 WebJob을 호출할 수 있습니다 <code>/cmd 3 30</code>.</p>\n\n<h2 id=\"learn-more\">자세한 정보</h2>\n\n<p>자세한 내용은 다음 링크를 확인하세요.</p>\n\n<ul>\n <li><a href=\"https://azure.microsoft.com/en-us/documentation/articles/websites-webjobs-resources/\">Azure WebJobs 리소스</a></li>\n <li><a href=\"https://api.slack.com/\">Slack API 설명서</a></li>\n <li><a href=\"https://github.com/Azure/azure-webjobs-sdk-extensions\">Azure WebJobs 확장 GitHub</a></li>\n</ul>"
