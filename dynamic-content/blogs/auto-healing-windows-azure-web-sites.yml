### YamlMime:Yaml
ms.openlocfilehash: 738494efd9872bd60f36fe0718305956206e4a5a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139902778"
Slug: auto-healing-windows-azure-web-sites
Title: Azure 웹 사이트에 Windows 자동 복구
Summary: 한밤중에 웹 사이트를 다시 시작하여 해결된 문제에 대해 몇 번이나 깨어났나요? 특정 조건을 자동으로 검색하는 것이 좋지 않을 것입니다.
Content: >-
  <p style="margin: 0in 0in 0pt;">한밤중에 웹 사이트를 다시 시작하여 해결된 문제에 대해 몇 번이나 깨어났나요? 특정 조건을 자동으로 검색하고 자동으로 복구하는 것이 좋지 않을까요?</p>

  WAWS(Azure 웹 사이트)Windows 대한 최근 업데이트를 통해 이러한 질문을 해결하려고 노력했습니다. "Always ON" 기능에 대한 몇 가지 새로운 개선 사항이 있으며, 이러한 향상된 기능을 통해 웹 애플리케이션을 호스트하는 작업자 프로세스를 자동으로 재활용할 수 있습니다. 이를 "자동 복구" 기능이라고 하며 작동 방식은 다음과 같습니다.


  웹 사이트의 루트 web.config 파일에서 <strong>트리거 </strong>를 정의하고 이러한 트리거가 적중될 때 수행할 <strong>작업을</strong> 구성하기만 하면 됩니다. 대략적으로 구성 섹션에는 다음과 같은 구조가 있습니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6064.Apurva-Joshi-Auto-Heal-image1.png-550x526.png"><img class="alignnone  wp-image-132211" alt="6064.Apurva Joshi - Auto Heal - image1.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6064.Apurva-Joshi-Auto-Heal-image1.png-550x526.png" width="550" height="122" /></a>


  <strong>참고:</strong> "Always ON"과 마찬가지로 이 기능은 표준 인스턴스에서만 사용할 수 있습니다.


  시나리오별로 사용 가능한 옵션을 분석해 보겠습니다.


  (지원되는 모든 요소 및 특성에 대한 자세한 설명은 게시물의 끝에 있습니다.)

  <h4>시나리오 1 – "요청 수에 따른 재활용"</h4>

  Y 시간 동안 X개의 요청을 처리한 후 애플리케이션을 자동으로 재활용해야 하는 시나리오를 고려해 보세요. 짧은 시간 안에 엄청난 요청이 유입된 후에는 확장이 잘 되지 않는다는 것을 알고 있습니다. 이 조건을 감지하고 작업자 프로세스를 자동으로 재활용하고 이벤트를 기록하려고 합니다.


  다음 샘플 구성을 사용하여 애플리케이션에 대한 루트 web.config 파일을 편집하기만 하면 됩니다. (기존 web.config 파일이 있는 경우 기존 &lt;system.webServer&gt; 섹션 아래에 모니터링&gt; 섹션을 복사&lt;하세요.)


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7848.Apurva-Joshi-Auto-Heal-image2.png-550x526.png"><img class="alignnone  wp-image-132201" alt="7848.Apurva Joshi - Auto Heal - image2.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7848.Apurva-Joshi-Auto-Heal-image2.png-550x526.png" width="550" height="168" /></a>


  위의 구성은 <strong>10분 동안 </strong> <strong>1,000</strong><strong>개의 요청을</strong> 처리한 작업자 프로세스를 재활용합니다. 또한 웹 루트 디렉터리의 Logfiles 폴더에 있는 eventlog.xml 파일에 이벤트를 기록합니다. 이벤트를 기록하면 자동 복구된 웹 사이트의 발생을 추적하고 문제 해결 또는 근본 원인 분석을 위한 중요한 포렌식 기능을 제공할 수 있습니다. 첫 번째 요청이 들어오면 timeInterval 시계가 시작됩니다.그런 다음 발생 수를 계산하기 시작합니다.count가 timeInterval이 만료되기 전에 최대값을 초과하면 작업을 수행합니다.시간 간격이 만료되면 타이머와 개수를 <em>모두</em> 다시 설정합니다. 이러한 효과는 위의 구성을 고려할 때 다음과 같은 일이 발생할 수 있다는 것입니다.


  00:00:00 – 첫 번째 요청 도착


  00:09:59 – 998개 요청이 처리됩니다.


  00:10:00 – 타이머가 만료되고 0으로 다시 설정됩니다.


  00:10:01 – 999 요청이 처리됩니다.


  이 시나리오에서는 첫 번째 또는 두 번째 시간 동안 1,000개의 요청이 발생하지 않았으므로 아무 작업도 수행되지 않습니다.


  <strong>참고: </strong> 웹 사이트의 여러 인스턴스가 있는 경우 모든 인스턴스가 아니라 이 트리거에 도달한 인스턴스의 작업자 프로세스만 다시 시작합니다.


  eventlog.xml 파일에 기록된 이벤트의 예입니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3527.Apurva-Joshi-Auto-Heal-image3.png-550x526.png"><img class="alignnone  wp-image-132191" alt="3527.Apurva Joshi - Auto Heal - image3.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3527.Apurva-Joshi-Auto-Heal-image3.png-550x526.png" width="550" height="274" /></a>


  &nbsp;

  <h4>시나리오 2 – "느린 요청에 따른 재활용"</h4>

  애플리케이션의 성능이 저하되고 여러 페이지가 렌더링하는 데 시간이 오래 걸리는 시나리오를 고려해 보세요. 이 상황을 감지하고 작업자 프로세스를 자동으로 재활용하려고 합니다.


  다음 샘플 구성을 사용하여 애플리케이션에 대한 루트 web.config 파일을 편집하기만 하면 됩니다. (기존 web.config 파일이 있는 경우 기존 &lt;system.webServer&gt; 섹션 아래에 모니터링&gt; 섹션을 복사&lt;하세요.)


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7824.Apurva-Joshi-Auto-Heal-image4.png-550x526.png"><img class="alignnone  wp-image-132181" alt="7824.Apurva Joshi - Auto Heal - image4.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7824.Apurva-Joshi-Auto-Heal-image4.png-550x526.png" width="550" height="148" /></a>


  위의 구성은 <strong>지난 2분 </strong> 동안 <strong>20개의 요청</strong>이 <strong>45초 이상</strong> 실행된 것을 감지하면 작업자 프로세스를 재활용합니다. slowRequests에 대한 트리거는 각 요청 실행이 끝날 때 평가되므로 timeInterval 값을 timeTaken 값으로 설정하는 것이 똑같이 중요합니다.


  <strong>참고: </strong> 웹 사이트의 여러 인스턴스가 있는 경우 모든 인스턴스가 아니라 이 트리거에 도달한 인스턴스의 작업자 프로세스만 다시 시작합니다.


  eventlog.xml 파일에 기록된 이벤트의 예입니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3438.Apurva-Joshi-Auto-Heal-image5.png-550x526.png"><img class="alignnone  wp-image-132171" alt="3438.Apurva Joshi - Auto Heal - image5.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3438.Apurva-Joshi-Auto-Heal-image5.png-550x526.png" width="550" height="290" /></a>

  <h4>시나리오 3 – "HTTP 상태 코드를 기반으로 이벤트(또는 재활용) 로깅"</h4>

  웹 사이트에서 특정 HTTP 상태 코드, 하위 상태 코드 또는 win32 상태 코드를 throw하기 시작할 때 상황에 대한 알림을 받으려는 시나리오를 고려합니다. eventlog.xml 파일에서 이벤트를 재활용하거나 기록하도록 선택할 수 있습니다(웹 사이트 콘텐츠 루트의 Logfiles 폴더 내에 있음).


  다음 샘플 구성을 사용하여 애플리케이션에 대한 루트 web.config 파일을 편집하기만 하면 됩니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8741.Apurva-Joshi-Auto-Heal-image6.png-550x526.png"><img class="alignnone  wp-image-132161" alt="8741.Apurva Joshi - Auto Heal - image6.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8741.Apurva-Joshi-Auto-Heal-image6.png-550x526.png" width="550" height="135" /></a>


  위의 구성은 <strong>10개의 요청이 지난 30초 동안 100개의 </strong><strong>하위 상태 코드</strong>가 있는 <strong>500의 HTTP 상태 코드를 </strong>생성한 것을 감지하면 eventlog.xml 파일에 이벤트를 기록합니다<strong>. </strong>


  <strong>참고: </strong> 웹 사이트의 여러 인스턴스가 있는 경우 모든 인스턴스가 아니라 이 트리거에 도달한 인스턴스에 대한 이벤트만 기록합니다. 필요에 따라 이벤트를 로깅하는 대신 재활용하도록 선택할 수 있습니다. 재활용은 기본적으로 이벤트를 기록합니다.


  eventlog.xml 파일에 기록된 이벤트의 예입니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4034.Apurva-Joshi-Auto-Heal-image7.png-550x526.png"><img class="alignnone  wp-image-132151" alt="4034.Apurva Joshi - Auto Heal - image7.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4034.Apurva-Joshi-Auto-Heal-image7.png-550x526.png" width="550" height="249" /></a>

  <h4>시나리오 4 – "메모리 제한에 따라 사용자 지정 작업(또는 재활용/로깅) 수행"</h4>

  웹 사이트에서 메모리 누수 문제를 해결하고 메모리 덤프를 생성하거나 이메일 알림을 보내거나 메모리 덤프를 생성하고 프로세스를 재활용하는 등의 사용자 지정 작업을 수행하려는 시나리오를 고려합니다.


  다음 샘플 구성을 사용하여 애플리케이션에 대한 루트 web.config 파일을 편집하기만 하면 됩니다. <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4834.Apurva-Joshi-Auto-Heal-image8.png-550x526.png"><img class="alignnone  wp-image-132141" alt="4834.Apurva Joshi - Auto Heal - image8.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4834.Apurva-Joshi-Auto-Heal-image8.png-550x526.png" width="550" height="131" /></a>


  위의 구성은 작업자 프로세스가 <strong>800MB의 프라이빗 바이트에  </strong> 도달했음을 감지할 때 <strong>procdump.exe</strong> 실행하고 <strong>미니 메모리 덤프</strong>를 생성하는 사용자 지정 작업을 실행합니다. 요청이 작업자 프로세스 파이프라인으로 만들어지지 않는 http.sys(커널 드라이버)에서 오는 특정 HTTP 오류 코드에서는 자동 복구가 트리거되지 않습니다. 이러한 상태 코드의 몇 가지 예는 304, 302, 400(많은 400대이지만 전부는 아님), 503 등입니다.


  <strong>참고: </strong> 웹 사이트의 인스턴스가 여러 개 있는 경우 모든 인스턴스가 아니라 이 트리거에 도달한 인스턴스에 대한 메모리 덤프만 생성합니다. 필요에 따라 전자 메일 등을 보낼 사용자 지정 작업을 실행하도록 선택할 수 있습니다. 또한 procdump.exe 기본적으로 웹 사이트 루트(d:\home)에서 사용할 수 없습니다. 이는 웹 사이트와 함께 xcopy 배포가 필요합니다.


  작업 유형의 재활용을 위해 eventlog.xml 파일에 로그인한 이벤트의 예입니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7026.Apurva-Joshi-Auto-Heal-image9.png-550x526.png"><img class="alignnone  wp-image-132131" alt="7026.Apurva Joshi - Auto Heal - image9.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7026.Apurva-Joshi-Auto-Heal-image9.png-550x526.png" width="550" height="281" /></a>


  <strong>마지막으로</strong> 특정 페이지/URL에서 트리거를 구성하려면 FREB 모듈을 사용하고 다음 블로그에 설명된 단계를 구성할 수 있습니다.


  <a href="(WAWS)-Collecting-dumps-of-the-worker-process-(w3wpexe)-automatically-whenever-a-request-takes-a-long-time">(WAWS)-Collecting-dumps-of-the-worker-process-(w3wpexe)-automatically-whenever-a-request-takes-a-long-time</a>


  이 방법은 5-10%의 성능 적중을 가지며 FREB를 사용하도록 설정해야 합니다.


  <strong>참고</strong>: 위의 접근 방식은 표준 모드에서도 유효합니다. 공유 모드 및 FREE 모드에서 1시간 후에 FREB를 자동으로 사용하지 않도록 설정하기 때문에 적용됩니다.


  &nbsp;


  <span style="text-decoration: underline;">다음은 지원되는 구성 목록 및 해당 의미입니다. </span>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6471.forgot-1.png-550x526.png"><img class="alignnone  wp-image-132121" alt="6471.forgot 1.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6471.forgot-1.png-550x526.png" width="550" height="74" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5040.forgot-2.png-550x526.png"><img class="alignnone  wp-image-132111" alt="5040.forgot 2.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5040.forgot-2.png-550x526.png" width="550" height="270" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6675.forgot-3.png-550x526.png"><img class="alignnone  wp-image-132101" alt="6675.forgot 3.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6675.forgot-3.png-550x526.png" width="550" height="446" /></a>


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7380.forgot-4.png-550x526.png"><img class="alignnone  wp-image-132091" alt="7380.forgot 4.png-550x526" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7380.forgot-4.png-550x526.png" width="550" height="261" /></a>
