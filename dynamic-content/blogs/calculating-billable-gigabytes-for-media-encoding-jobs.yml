### YamlMime:Yaml
ms.openlocfilehash: b0f452294ebd57fd5334f2c5ff9ad2b4c8735a7c
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907258"
Slug: calculating-billable-gigabytes-for-media-encoding-jobs
Title: 미디어 인코딩 작업에 대한 청구 가능 기가바이트 계산
Summary: 이 게시물에서는 작업 및 작업 수준에서 청구 가능한 기가바이트 분석을 생성하는 데 사용할 샘플 코드를 제공하는 방법을 알아봅니다.
Content: "Media Services Azure Media Encoder Media Processor를 사용하는 작업으로 작업을 제출하면 처리된 데이터의 양에 따라 요금이 청구됩니다. Azure 청구 포털은 청구 기간 동안 처리된 총 기가바이트 값을 제공하지만 작업 또는 작업 수준에서 요금 분석을 제공하지는 않습니다. 이 블로그에서는 작업 및 작업 수준에서 청구 가능한 기가바이트 분석을 생성하는 데 사용할 수 있는 몇 가지 샘플 코드를 살펴봅니다. 또한 블로그에서는 Excel 파워 쿼리를 사용하여 샘플 코드에서 생성된 데이터를 분석하는 방법도 설명합니다.\n<h2>Storage 미디어 자산</h2>\n미디어 자산을 <a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#create_an_asset\">만들</a> 때 Media Services GUID를 생성하고 해당 GUID를 사용하여 미디어 자산 ID를 만듭니다. 미디어 자산 ID의 접두사에는 \"nb:cid:UUID:\", GUID가 옵니다. 즉, 미디어 자산 ID는 \"nb:cid:UUID:&lt;GUID&gt;\" 형식을 사용합니다. 또한 Media Services 진행하여 \"asset-&lt; 지정한 Storage 계정의 GUID&gt;\"입니다. 자산이 만들어지면 스토리지 컨테이너에 자산 파일을 업로드할 수 있습니다. 인코딩 작업을 제출하면 인코더의 출력 파일이 출력 자산과 연결된 Storage 컨테이너에 배치됩니다.\n<h2>샘플 코드</h2>\n위의 경우 제공된 샘플 코드의 작동 방식은 다음과 같습니다.\n<ul>\n <li>코드는 지정된 Media Services 계정에 대한 모든 작업을 열거합니다.</li>\n <li>각 작업에 대해 모든 태스크가 열거됩니다.</li>\n <li>완료된 작업의 경우 모든 입력 및 출력 자산이 열거됩니다.</li>\n <li>각 입력 및 출력 자산에 대해 자산과 연결된 스토리지 컨테이너의 모든 Blob이 열거되고 자산의 각 Blob 크기가 추가되어 자산 크기를 계산합니다.</li>\n <li>그런 다음, 코드는 <strong>JobId</strong>를 파티션 키로 사용하고 <strong>TaskId</strong>를 행 키로 사용하여 <strong>JobAndTaskTableEntity</strong>라는 Azure 테이블 엔터티를 만듭니다.\n<ul>\n <li>StartTime, EndTime, MediaProcessor, RunningDuration, InputAssetSize 및 OutputAssetSize와 같은 <strong>JobAndTaskTableEntity</strong> 에 대한 다른 멤버도 채워집니다.</li>\n</ul>\n</li>\n <li>그런 다음, 코드는 <strong>JobAndTaskTableEntity</strong>를 <strong>JobAndTaskMetadata</strong>라는 Azure 테이블에 씁니다.</li>\n</ul>\n&nbsp;\n\n샘플 코드의 App.Config 파일은 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\"/&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n위의 App.Config MediaAccountName&gt; 및 &lt;MediaAccountKey&gt;를 Media Services 계정 이름 및 키로 바꿉&lt;다. 또한 StorageAccountName&gt; 및 &lt;StorageAccountKey&gt;를 Media Services 계정과 연결된 스토리지 계정의 이름 및 키로 바꿉&lt;니다.\n\n샘플 코드는 다음과 같습니다.\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\nusing System.Configuration;\n\nnamespace JobAndTaskBilling\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class JobAndTaskTableEntity : TableEntity\n    {\n        public DateTime StartTime { get; set; }\n        public DateTime EndTime { get; set; }\n        public string MediaProcessor { get; set; }\n        public TimeSpan RunningDuration { get; set; }\n        public Double InputAssetSize { get; set; }\n        public Double OutputAssetSize { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        // \n        private static CloudStorageAccount _cloudStorage = null;\n        private static CloudBlobClient _blobClient = null;\n\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _taskTable = null;         \n\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                // Use the Storage Connection String from App.Config to create a CloudStorageAccount instance\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();   // Create the CloudBlobClient instance to perform Blob operations\n                _tableClient = _cloudStorage.CreateCloudTableClient(); // Create the CloudTableClient instance to perform Table operations\n\n                _taskTable = _tableClient.GetTableReference(\"JobAndTaskMetadata\"); \n                _taskTable.CreateIfNotExists();  // Create the Table if it doesn't exist\n\n                ProcessJobs();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function loops through all jobs in a Media Services account \n        /// &lt;/summary&gt;\n        static void ProcessJobs()\n        {\n            try\n            {\n                Dictionary&lt;string, string&gt; _dictMPs = GetMediaProcessors();\n\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentBatch = 0;                \n\n                while (true)\n                {\n                    // Loop through all Jobs (1000 at a time) in the Media Services account\n                    IQueryable _jobsCollectionQuery = _context.Jobs.Skip(skipSize).Take(batchSize);\n                    foreach (IJob job in _jobsCollectionQuery)\n                    {\n                        currentBatch++;\n                        Console.WriteLine(\"Processing Job Id:\" + job.Id);\n\n                        ProcessTasks(job, _dictMPs);\n                    }\n\n                    if (currentBatch == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentBatch = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }                    \n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Enumerates all the Media Processors available in the Media Services accounts and creates a dictionary with MediaProcessorId as key and MediaProcessorName as value\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static Dictionary&lt;string, string&gt; GetMediaProcessors()\n        {\n            Dictionary&lt;string, string&gt; _dictMPs = new Dictionary&lt;string, string&gt;();\n            foreach (IMediaProcessor mp in _context.MediaProcessors)\n            {\n                _dictMPs.Add(mp.Id, mp.Name);                \n            }\n\n            return _dictMPs;\n        }\n\n        /// &lt;summary&gt;\n        /// This function looks through all the tasks associated with a job\n        /// For all finished tasks, it calculates the input and output asset size and writes an entity to the JobsAndTasksMetadata table\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"job\"&gt;&lt;/param&gt;\n        static void ProcessTasks(IJob job, Dictionary&lt;string, string&gt; _dictMPs)\n        {\n            try\n            {\n                foreach (ITask task in job.Tasks)\n                {\n                    Console.WriteLine(\"Processing Task Id:\" + task.Id);\n\n                    // Loop through the HistoricalEvents associated with the Task to find Tasks that have Finished\n                    // Task.State only has the Conpleted State and based on that it is not possible to know whether the task had an error or did it finish successfully\n                    for (int i = 0; i &lt; task.HistoricalEvents.Count; i++)\n                    {\n                        if (task.HistoricalEvents[i].Code == \"Finished\")\n                        {\n                            try\n                            {\n                                JobAndTaskTableEntity tme = new JobAndTaskTableEntity();\n                                tme.PartitionKey = job.Id;\n                                tme.RowKey = task.Id;\n                                tme.StartTime = Convert.ToDateTime(task.StartTime);\n                                tme.EndTime = Convert.ToDateTime(task.EndTime);\n                                tme.MediaProcessor = _dictMPs[task.MediaProcessorId]; // Use the MediaProcessor dictionary to figure out the MediaProcessorName\n                                tme.RunningDuration = task.RunningDuration;\n                                tme.InputAssetSize = 0;\n                                tme.OutputAssetSize = 0;\n\n                                for (int j = 0; j &lt; task.InputAssets.Count; j++)\n                                {\n                                    tme.InputAssetSize += GetAssetSize(task.InputAssets[j]);\n                                }\n\n                                for (int k = 0; k &lt; task.OutputAssets.Count; k++)\n                                {\n                                    tme.OutputAssetSize += GetAssetSize(task.OutputAssets[k]);\n                                }\n\n                                TableOperation op = TableOperation.Insert(tme);\n                                _taskTable.Execute(op);\n                            }\n                            catch (Exception x)\n                            {\n                                Console.WriteLine(x.Message);\n                            }\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// Gets the size of an Asset by eumerating all the blobs in the asset container and adding the size of each blob\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_asset\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static double GetAssetSize(IAsset _asset)\n        {\n            double _assetSize = 0;\n\n            try\n            {\n                // The asset container has \"asset-\" prefixed to the Asset GUID and the Asset Id has \"nb:cid:UUID:\" prefixed to the Asset GUID\n                foreach (CloudBlockBlob _blobItem in _blobClient.ListBlobs(\"asset-\" + _asset.Id.Replace(\"nb:cid:UUID:\", \"\") + \"/\", true))\n                {\n                    _assetSize += _blobItem.Properties.Length;\n                }\n            }\n            catch (Exception ex)\n            {\n                // If the Asset is not found in storage a value of zero will be returned for the Asset Size\n                // This can happen if the Asset was deleted after the Task finished but before this sample code was run\n                Console.WriteLine(ex.Message);\n            }\n\n            return _assetSize;\n        }        \n\n    }\n}</pre>\n위의 코드에서 함수에 대한 간략한 설명은 다음과 같습니다.\n\n<strong>ProcessJobs</strong>\n\n이 함수는 제공된 Media Services 계정의 모든 작업을 반복합니다. Media Services는 작업 컬렉션의 작업 1000개를 반환합니다. 이 함수는 Skip 및 Take를 사용하여 모든 작업이 연결되었는지 확인합니다(계정에 1000개가 넘는 작업이 있는 경우).\n\n<strong>GetMediaProcessors</strong>\n\n이 함수는 제공된 Media Services 계정에서 사용할 수 있는 모든 미디어 프로세서를 반복하고 MediaProcesssorId를 키로, MediaProcessorName을 값으로 사용하여 사전을 만듭니다. 이 사전은 <strong>JobAndTaskMetadata </strong>테이블에 대한 엔터티를 작성할 때 사용됩니다.\n\n<strong>ProcessTasks</strong>\n\n이 함수는 지정된 작업과 연결된 모든 작업을 반복합니다. 그런 다음 태스크와 연결된 모든 기록 이벤트를 반복하여 작업이 실제로 성공적으로 완료되었는지 확인합니다. 이는 오류가 발생한 작업에 대한 항목 로깅을 방지하기 위한 것입니다(해당 작업은 청구할 수 없기 때문에). 완료된 작업의 경우 함수는 입력 및 출력 자산 크기도 가져오고 <strong>JobAndTaskMetadata</strong> 테이블에 대한 엔터티를 만듭니다.\n\n<strong>GetAssetSize</strong>\n\n이 함수는 스토리지 계정의 자산 컨테이너에 있는 모든 Blob을 반복하여 자산 크기를 바이트 단위로 계산합니다.\n<h2>Excel 파워 쿼리를 사용하여 데이터 분석</h2>\n위의 샘플 코드 실행이 완료되면 완료된 작업에 대한 데이터가 포함된 <strong>JobAndTaskMetadata</strong> 라는 Azure 테이블이 생성됩니다. <a href=\"https://office.microsoft.com/en-us/excel-help/introduction-to-microsoft-power-query-for-excel-HA104003940.aspx?CTT=5&amp;origin=HA104003813\">Excel 파워 쿼리</a>를 사용하여 분석을 위해 해당 데이터를 Excel 가져올 수 있습니다. 파워 쿼리에 Excel 사용한 적이 없는 경우 \"<a href=\"https://office.microsoft.com/en-us/excel/download-microsoft-power-query-for-excel-FX104018616.aspx\">Excel 위해 Microsoft 파워 쿼리 다운로드</a>\" 웹 페이지에서 다운로드할 수 있습니다. 설치되면 Excel 시작할 수 있으며 \"파워 쿼리\"라는 탭이 표시됩니다. 해당 탭을 클릭한 다음 \"다른 원본에서\" 단추를 클릭하면 아래 스크린샷과 같이 \"Windows Azure Table Storage\"라는 메뉴 항목이 표시됩니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h21_51.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h21_51\" alt=\"2014-07-06_00h21_51\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h21_51_thumb.png\" width=\"1028\" height=\"540\" border=\"0\" /></a>\n\n해당 메뉴 항목을 선택하면 다음과 같은 대화 상자가 표시됩니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h28_02.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h28_02\" alt=\"2014-07-06_00h28_02\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h28_02_thumb.png\" width=\"644\" height=\"234\" border=\"0\" /></a>\n\nStorage 계정 이름을 입력하면 다음 대화 상자가 표시됩니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h29_50.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h29_50\" alt=\"2014-07-06_00h29_50\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h29_50_thumb.png\" width=\"644\" height=\"279\" border=\"0\" /></a>\n\n계정 키를 입력하고 저장을 클릭합니다. 이제 오른쪽에 \"탐색기\"라는 창이 표시됩니다. 스토리지 계정의 모든 테이블이 나열됩니다. <strong>JobAndTaskMetadata </strong>테이블을 두 번 클릭하면 새 창이 열립니다. 해당 창의 스크린샷은 다음과 같습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_21h19_26.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_21h19_26\" alt=\"2014-07-06_21h19_26\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_21h19_26_thumb.png\" width=\"1028\" height=\"552\" border=\"0\" /></a>\n\n\"콘텐츠\"라는 레이블이 지정된 열 옆에 있는 단추를 클릭하면 다음과 같은 팝업이 표시됩니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_21h22_17.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_21h22_17\" alt=\"2014-07-06_21h22_17\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_21h22_17_thumb.png\" width=\"644\" height=\"272\" border=\"0\" /></a>\n\n[확인]을 클릭하면 모든 열이 로드됩니다. 이제 맨 위에 있는 \"닫기 적용 &amp; \" 단추를 클릭하면 전체 데이터가 워크시트에 로드됩니다.\n\n이제 \"청구 가능한 기가바이트\"라는 열을 추가하고 InputAssetSize 및 OutputAssetSize를 추가하고 합계를 1024 * 1024 * 1024로 나누는 수식을 추가할 수 있습니다(자산 크기는 바이트 단위). Media Services \"Windows Azure Media Encoder\" 미디어 프로세서로 제출된 작업에 대한 청구서만 청구되므로 나머지 행을 필터링할 수 있습니다.\n<h2>고려 사항</h2>\n마지막으로 애플리케이션에 이 샘플 코드를 사용하는 것이 좋습니다.\n<ul>\n <li>Media Services 계정에는 최대 작업 수, 자산 및 태스크 수가 제한됩니다. 이러한 내용은 \"<a href=\"https://msdn.microsoft.com/en-us/library/jj945161.aspx\">할당량 및 제한 사항</a>\" MSDN 페이지에 설명되어 있습니다. 위의 샘플 코드는 제공된 Media Services 계정에서 자산, 작업 또는 태스크가 삭제되지 않았지만 애플리케이션이 많은 작업을 제출하는 경우 유지하기 어려울 수 있다는 사실에 의존합니다. 이러한 경우 작업 및/또는 자산을 삭제하기 직전에 위의 코드에서 <strong>ProcessTasks</strong> 함수를 사용하는 것이 좋습니다.</li>\n <li>작업이 완료된 후 애플리케이션이 자산 컨테이너에서 미디어 Blob을 추가하거나 삭제하는 경우 부정확한 청구 가능 기가바이트가 표시됩니다. 이를 방지하기 위해 완료되는 즉시 지정된 작업에 대해 <strong>ProcessTasks </strong>함수를 실행하는 것이 가장 좋습니다. \"<a href=\"https://msdn.microsoft.com/en-us/library/dn261241.aspx\">작업 알림\"을</a> 사용하는 경우 작업에 대한 \"완료\" 메시지를 받으면 <strong>ProcessTasks</strong> 함수를 호출할 수 있습니다.</li>\n <li>이 블로그에 제공된 샘플 코드는 단일 스토리지 계정에 모든 자산이 있는 Media Services 계정으로 작동하도록 설계되었지만 여러 스토리지 계정으로 작업하도록 쉽게 조정할 수 있습니다.</li>\n <li>위의 코드는 InputAssetSize 및 OutputAssetSize를 바이트 단위로 작성합니다. 코드를 수정하여 크기를 기가바이트 단위로 작성하고 <strong>JobAndTaskMetadata</strong> 테이블에 다른 열을 추가하여 InputAssetSize 및 OutputAssetSize의 합계를 작성할 수도 있습니다.</li>\n <li>테이블을 지원하는 기존 <a href=\"https://blogs.msdn.com/b/windowsazurestorage/archive/2014/03/11/windows-azure-storage-explorers-2014.aspx\">Azure Storage Explorer</a> 애플리케이션 중 하나를 사용하여 <strong>JobAndTaskMetadata</strong> 테이블의 데이터를 보는 것과 Excel 사용할 수 있지만 Excel 테이블의 데이터를 추가로 분석하는 데 사용할 수 있는 피벗 테이블과 같은 몇 가지 강력한 데이터 조작 기능을 제공합니다.</li>\n <li>월간 Azure 청구서는 청구 1주년 및 계정에 적용되는 할인(볼륨 및 약정)의 기능입니다. 위의 코드를 통해 얻을 수 있는 결과를 월별 Azure 청구서와 비교하려는 경우 이를 고려해야 합니다.</li>\n <li>위의 코드의 장점은 워크시트에 로드된 데이터를 사용하여 다른 미디어 프로세서와 함께 처리되는 바이트 수를 확인할 수 있다는 것입니다.</li>\n</ul>"
