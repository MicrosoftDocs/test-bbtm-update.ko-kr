### YamlMime:Yaml
ms.openlocfilehash: f7f9986657339ae85afd7c1eaa3b4290a0f15fe7
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911301"
Slug: field-note-using-certificate-based-encryption-in-windows-azure-applications
Title: '필드 참고: Windows Azure 애플리케이션에서 Certificate-Based 암호화 사용'
Summary: 이는 Windows Azure 커뮤니티에서 실제&rdquo; 기술 정보를 공유하는 &ldquo;데 초점을 맞춘 일련의 문서 중 첫 번째입니다. &nbsp;이 문서는 월터 마이어스 III에 의해 작성되었습니다,...
Content: '<p><i>이는 Windows Azure 커뮤니티에서 실제&rdquo; 기술 정보를 공유하는 &ldquo;데 초점을 맞춘 일련의 문서 중 첫 번째입니다. &nbsp; 이 문서는 </i><a target="_blank" href="https://blogs.msdn.com/b/walterm/"><i>월터 마이어스 III</i></a><i>, 수석 컨설턴트, 마이크로 소프트 컨설팅 서비스에 의해 작성되었습니다.</i></p>  <h2>문제</h2>  <p>개발자가 대칭 키 체계를 사용하여 데이터 암호화 및 암호 해독을 선택한 <a target="_blank" href="https://azure.microsoft.com/">다양한 Windows Azure</a> 관련 게시물을 보았습니다. 중요한 시나리오는 개발자가 암호화된 데이터를 SQL Azure 저장해야 하는 경우이며, 사용자에게 표시하기 위해 Windows Azure 애플리케이션에서 암호 해독됩니다.&nbsp; 또 다른 데이터 동기화 시나리오는 온-프레미스 데이터를 SQL Azure 데이터와 동기화해야 하며, Windows Azure의 오프-프레미스 동안 암호화된 데이터와 동기화되어야 합니다.</p>  <p>개발자는 azure 스토리지를 Windows 참조하는 스토리지 키가 안전한 한 보안이 유지되는 blob으로 Windows Azure Storage에 암호화 키를 저장할 수 있지만, 개발자가 대칭 키에 액세스할 수 있어야 하며 프레미스에서 대칭 키를 무의식적으로 손상시킬 수 있으므로 이는 모범 사례가 아닙니다. 또한 Windows Azure 애플리케이션이 손상된 경우 키도 손상될 수 있습니다. 이 문서에서는 Windows Azure 애플리케이션에 대한 데이터의 인증서 기반 암호화/암호 해독을 위한 모델 및 코드를 제공합니다.</p>  <h2>솔루션</h2>  <p>먼저 몇 가지 배경을 제공하겠습니다. 인증서 기반(비대칭 키) 접근 방식을 사용하면 프라이빗 키를 보호하기 위해 &ldquo;우려&rdquo; 프로토콜을 분리하는 것이 가장 좋습니다. 따라서 IT는 Windows Azure 애플리케이션에서 사용할 서비스 인증서로 Windows Azure 관리 포털에 업로드되는 프라이빗 키가 있는 인증서를 담당합니다(Azure 애플리케이션을 Windows 사용할 수 있는 서비스 인증서는 해당 호스티드 서비스에 업로드되어야 합니다). 개발자에게는 애플리케이션 배포 시 개발 머신에서만 사용할 수 있는 공개 키가 제공됩니다. 개발 패브릭에서 테스트할 때 개발자는 IIS7을 사용하여 자체 인증을 통해 만든 인증서를 사용해야 합니다. 배포할 때 암호화/암호 해독 코드의 지문을 Windows Azure에 업로드된 서비스 인증서로 바꾸고 서비스 인증서의 공개 키를 애플리케이션으로 배포하기만 하면 됩니다.</p>  <p>개발자는 애플리케이션을 사용하여 공개 키를 배포해야 하므로 Windows Azure에서 역할 인스턴스를 스핀업할 때 서비스 정의의 지문을 업로드된 서비스 인증서와 일치시키고 프라이빗 키를 역할 인스턴스에 배포합니다. 프라이빗 키는 의도적으로 .pfx 형식으로 내보낼 수 없으므로&rsquo; RDC 연결을 통해 역할 인스턴스로 프라이빗 키를 가져올 수 없습니다.</p>  <h2>솔루션 구현</h2>  <p>이제 약간의 이론을&rsquo; 다루었으므로 개념이 구체적으로 입증된 것을 보기 위해 이 단계를 살펴보겠습니다. 이 솔루션은 인증서 관리에 Visual Studio 제공된 기능을 사용합니다.</p>  <p>아직 진행하지 않은&rsquo; 경우 개인 인증서 저장소에 공개 키 인증서를 설치합니다. 현재 사용자 저장소 대신 로컬 컴퓨터를 사용하므로 코드는 Windows Azure에서 인증서를 배포할 위치와 일치합니다. 인증서를 보려면 현재 사용자 저장소로 이동하여 certmgr.msc를 시작할 수&rsquo; 없습니다. mmc.exe 시작하고 파일 | 선택해야 합니다. 스냅인&hellip; 메뉴 항목 추가/제거, 인증서 스냅인 추가 및 컴퓨터 계정을 선택하여 아래 스냅샷과 같이 로컬 컴퓨터 인증서를 확인합니다.</p>  <p>&nbsp;<img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6355.FieldNotes1.png" alt="" border="0" height="312" width="381"></p>  <p>따라서 이제 인증서 콘솔은 다음과 같이 표시됩니다.</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3225.FieldNote2.png" alt="" border="0" height="276" width="383">&nbsp;</p>  <p>&rsquo;이제 애플리케이션을 배포하기 전에 2010년 Visual Studio 어떻게 표시되는지 살펴본 다음, Windows Azure 역할 인스턴스에서 인증서 콘솔이 어떻게 보이는지 살펴보겠습니다. 다음은 웹 역할의 속성 페이지를 선택하고 인증서 탭을 선택한 스크린샷입니다. 위의 스크린샷에서 강조 표시된 인증서를 추가하고 EncryptDecrypt로 이름을 바꿨습니다. 저장소 위치는 LocalMachine이고 스토어 이름은 내 이름으로, 원하는 것입니다.</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7457.FieldNote3.png" alt="" border="0" height="300" width="386"></p>  <p>여기에 인증서를 추가했으면 이제 ServiceDefinition.csdef 파일로 이동하여 아래와 유사하게 표시됩니다. 또한 ServiceConfiguration.cscfg 파일에서 지문과 함께 항목을 찾을 수 있습니다.</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2185.FieldNote4.png" alt="" border="0" height="302" width="388"></p>  <p>애플리케이션을 배포한 후 모든 인스턴스에 대한 RDC(원격 데스크톱 연결)를 설정할 수 있습니다(애플리케이션을 게시할 때 RDC를 구성한 것으로 가정).&nbsp; 위와 동일한 방식으로 mmc.exe 시작하고 로컬 컴퓨터와 현재 사용자 모두에 대한 인증서 스냅인을 추가합니다.&nbsp; RDC 창은 아래와 유사합니다.</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7367.FieldNote5.png" alt="" border="0" height="321" width="391"></p>  <p>인증서는 로컬 컴퓨터 개인 인증서 저장소에 설치되지만 현재 사용자 개인 저장소에는 설치되지 않았습니다. 서비스 인증서를 호스팅된 서비스에 업로드하고 역할에 대한 인증서를 구성하여 Windows Azure가 인증서 저장소에 인증서를 설치하게 한 조합입니다. 이제 인증서를 마우스 오른쪽 단추로 클릭하고 위에서 설명한 대로 내보내려고 하면 아래와 같이 프라이빗 키를 내보낼 수 없다는 것을 알 수 있습니다.</p>  <p><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0383.FieldNote6.png" alt="" border="0" height="308" width="394"></p>  <p>이제 데이터의 암호화/암호 해독에 사용할 인증서가 어떻게 처리되는지 알고 있습니다. &rsquo;다음에는 작업을 수행할 암호화/암호 해독 루틴을 살펴보겠습니다.</p>  <p>public static 클래스 X509CertificateHelper</p>  <p>{</p>  <p>public static X509Certificate2 LoadCertificate(StoreName storeName, StoreLocation</p>  <p>storeLocation, 문자열 지문)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 다음 코드는 키 저장소에서 인증서를 가져옵니다.</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Store store = new X509Store(storeName, storeLocation);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 저장소. Open(OpenFlags.ReadOnly);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate2Collection certCollection =</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 저장소. Certificates.Find(X509FindType.FindByThumbprint,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 지문, false);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate2Enumerator 열거자 = certCollection.GetEnumerator();</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate2 cert = null;</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while(열거자입니다. MoveNext())</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cert = 열거자입니다. 현재,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 반환 인증서;</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static byte[] Encrypt(byte[] plainData, bool fOAEP,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate2 인증서)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (plainData == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("plainData");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (certificate == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("certificate");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (RSACryptoServiceProvider provider = new RSACryptoServiceProvider())</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 공급자. FromXmlString(GetPublicKey(certificate));</p>  <p>공개 키를 사용하여 암호화합니다.</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 반환 공급자입니다. Encrypt(plainData, fOAEP);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static byte[] Decrypt(byte[] encryptedData, bool fOAEP,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate2 인증서)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(encryptedData == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("encryptedData");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (certificate == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("certificate");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using(RSACryptoServiceProvider provider = (RSACryptoServiceProvider)</p>  <p>인증서. PrivateKey)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 프라이빗 키를 사용하여 암호를 해독합니다.</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 반환 공급자입니다. Decrypt(encryptedData, fOAEP);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static string GetPublicKey(X509Certificate2 certificate)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (certificate == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("certificate");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 인증서를 반환합니다. PublicKey.Key.ToXmlString(false);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static string GetXmlKeyPair(X509Certificate2 certificate)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (certificate == null)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentNullException("certificate");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!certificate. HasPrivateKey)</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw 새 ArgumentException("인증서에 PK가 없습니다.");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 다른</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 인증서를 반환합니다. PrivateKey.ToXmlString(true);</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>  <p>}</p>  <p>위의 암호화 및 암호 해독 루틴에서 암호화에 대한 공개 키를 가져와야 하지만 암호 해독에 대한 프라이빗 키를 가져와야 합니다. PKI(공개 키 인프라)를 사용하면 공개 키가 있는 모든 사용자가 암호화를 수행할 수 있지만 프라이빗 키를 가진 사용자만 암호화된 문자열의 암호를 해독할 수 있는 권한이 있기 때문에 이 의미가 있습니다. 주목할 만한 차이점은 키를 가져올 때 암호화 루틴에서 볼 수 있듯이 공개 키를 XML로 내보낼 수 있지만, 인증서는 이전에 학습한 Windows Azure에서 내보낼 수 없는 프라이빗 키 집합으로 배포되므로 암호 해독 루틴에서 XML로 프라이빗 키를 내보낼 수&rsquo; 없습니다.</p>  <p>&rsquo;이제 위에서 X509 암호화/암호 해독 도우미 클래스를 사용하여 문자열을 암호화하고 문자열의 암호를 해독하기 위해 작성한 일부 코드를 살펴보겠습니다.</p>  <p>string myText = "Encrypt me.";</p>  <p>X509Certificate2 인증서 = X509CertificateHelper.LoadCertificate(</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StoreName.My,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StoreLocation.LocalMachine,</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "D3E6F7F969546ED620A255794CAB31D8C07E9F31");</p>  <p>if (certificate == null)</p>  <p>{</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Certificate is null.");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>  <p>}</p>  <p>byte[] encoded = System.Text.UTF8Encoding.UTF8.GetBytes(myText)</p>  <p>byte[] encrypted;</p>  <p>byte[] 암호 해독됨;</p>  <p>다음을 시도해 보세요.</p>  <p>{</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encrypted = X509CertificateHelper.Encrypt(encoded, true, certificate);</p>  <p>}</p>  <p>catch(Exception ee)</p>  <p>{</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Encrypt failed with error: " + ee. Message + "&lt;br&gt;");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>  <p>}</p>  <p>다음을 시도해 보세요.</p>  <p>{</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decrypted = X509CertificateHelper.Decrypt(encrypted, true, certificate);</p>  <p>}</p>  <p>catch(예외 ed)</p>  <p>{</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("암호 해독이 오류로 실패했습니다. " + ed. Message + "&lt;br&gt;");</p>  <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p>  <p>}</p>  <p>따라서 위의 코드에서 로컬 컴퓨터의 개인 저장소를 사용하여 인증서를 로드했습니다. 내 X509 encrypt/decrypt 클래스의 LoadCertificate 메서드의 마지막 매개 변수는 역할에 대한 속성 페이지의 인증서 탭에서 가져온 지문을 보유합니다. 연습으로 ServiceConfiguration.cscfg 파일에서 이 문자열을 검색하는 코드를 작성할 수 있습니다.</p>  <p>참조:&nbsp; <a target="_blank" href=""></a></p>'
