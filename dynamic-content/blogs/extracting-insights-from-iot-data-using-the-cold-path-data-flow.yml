### YamlMime:Yaml
ms.openlocfilehash: e76d4bbf3712a7fa71e6d650c3b3bc123c7f435a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139905973"
Slug: extracting-insights-from-iot-data-using-the-cold-path-data-flow
Title: 콜드 경로 데이터 흐름을 사용하여 IoT 데이터에서 인사이트 추출
Summary: >+
  이 블로그는 Microsoft의 산업 환경 팀이 게시한 솔루션 가이드의 적용 범위를 계속합니다. 이 가이드에서는 데이터 수집, 핫 경로 처리, 콜드 경로 처리 및 분석 클라이언트와 같은 구성 요소에 대해 설명합니다. 이 블로그 게시물에서는 솔루션 가이드의 콜드 경로 처리 구성 요소를 다룹니다.

Content: "<p>이 블로그는 Microsofts&rsquo; Industry Experiences 팀이 게시한 <a href=\"https://aka.ms/manufacturingsolutionguide\" target=\"_blank\">솔루션 가이드</a>의 적용 범위를 계속합니다. 이 가이드에서는 다음 구성 요소를 다룹니다.</p>\n\n<ul>\n <li>데이터 수집</li>\n <li>핫 경로 처리</li>\n <li>콜드 경로 처리</li>\n <li>분석 클라이언트</li>\n</ul>\n\n<p>솔루션 가이드에서 IoT 애플리케이션에 대한 데이터 처리에 대한 권장 사항을 이미 설명했으며 데이터 흐름에 람다 아키텍처를 사용하는 것이 좋습니다. 데이터 경로를 반복하려면 다음을 수행합니다.</p>\n\n<ul>\n <li>일괄 처리 계층(콜드 경로)은 들어오는 모든 데이터를 원시 형식으로 저장하고 데이터에 대한 일괄 처리를 수행합니다. 이러한 처리의 결과는 일괄 처리 보기로 저장됩니다. 복잡한 분석을 실행하고, 더 긴 기간(예: 시간 또는 일)에 걸쳐 여러 원본의 데이터를 결합하고, 보고서 및 기계 학습 모델과 같은 새로운 정보를 생성하는 느린 처리 파이프라인입니다.</li>\n <li>속도 계층과 서비스 계층(웜 경로)은 실시간으로 데이터를 분석합니다. 이 계층은 정확도는 떨어지지만 짧은 대기 시간을 제공하도록 디자인되었습니다. 들어오는 메시지를 보관하고 표시하고 이러한 레코드를 분석하여 경보와 같은 단기 중요한 정보 및 작업을 생성하는 더 빠른 처리 파이프라인입니다.</li>\n</ul>\n\n<p>이 블로그 게시물에서는 솔루션 가이드의 콜드 경로 처리 구성 요소를 다룹니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/9f225d45-dcbb-4fdc-a864-550fdc3d4200.png\"><img alt=\"Cold path processing components of the solution guide\" border=\"0\" height=\"383\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/13466cad-60c0-4649-a28b-66c99bca853b.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"솔루션 가이드의 콜드 경로 처리 구성 요소\" width=\"776\"></a></p>\n\n<p>솔루션 가이드에서 Azure TSI(<a href=\"https://docs.microsoft.com/en-us/azure/time-series-insights/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">시계열 Insights</a>)를 사용하여 타이머 분석을 자세히 설명했습니다. 이 서비스는 타임스탬프 데이터에 대한 분석, 스토리지 및 시각화 서비스입니다. TSI 사용에 대한 관련 섹션을 참조하세요.</p>\n\n<p>이전 블로그 게시물에서 기억할 수 있듯이 NIST SMS 테스트 베드 엔드포인트에서 게시한 샘플 데이터를 사용하고 있습니다. 이전 게시물은 이벤트&rdquo; 및 샘플&rdquo; 데이터 레코드에 대해 별도의 Azure Event Hubs로 &ldquo;푸시된 데이터로 &ldquo;끝났습니다.</p>\n\n<p>나머지 논의를 시작하기 전에 분석&rdquo; 문제의 해결 방법은 &ldquo;각 공장, 라인, 기계 등에 종속되어 있음을 강조하고자 합니다. 데이터를 사용할 수 있어야 하며 비즈니스에 필요한 데이터여야 합니다. 데이터를 구성하기 위한 두 가지 방법을 다루겠지만 완전하지는 않으며 예제로만 사용됩니다.</p>\n\n<h2>원시 데이터 저장</h2>\n\n<p>샘플 구현에는 원시 데이터가 게시되는 Event Hubs에서 들어오는 데이터 스트림을 가져와서 Azure Storage Blob 및 테이블에 복사하는 <a href=\"https://docs.microsoft.com/en-us/azure/stream-analytics/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">기본 Azure Stream Analytics</a> 쿼리 집합이 있습니다. 예를 들어 쿼리는 다음과 같습니다.</p>\n\n<pre>\nSELECT\n     *\nINTO\n     [samplesTable]\nFROM\n     [EventHubIn]</pre>\n\n<p>한 테이블은 샘플용이고 다른 테이블은 이벤트용입니다. 사용자 지정 구성 요소에서 들어오는 데이터를 평면화할 때 다음 C# 코드 조각을 사용하여 들어오는 데이터 스트림이 있는 <a href=\"https://github.com/MSIndustryExperiences/IoTInsights/blob/master/ingest/flattenandpost/src/FlattenAndPost.cs#L235\" target=\"_blank\">시간 창에 대한 속성을</a> 추가하여 처리 파이프라인에서 데이터를 보다 쉽게 구성할 수 있도록 했습니다.</p>\n\n<pre>\nHourWindow =\n\n   new DateTime(\n       sample.timestamp.Year,\n       sample.timestamp.Month,\n       sample.timestamp.Day,\n       sample.timestamp.Hour,\n       0,\n       0),</pre>\n\n<p>이 데이터 레코드 필드는 파티션 키로 사용하기만 하면 Azure Storage 테이블에서 레코드를 구성하는 데 특히 유용합니다. 들어오는 레코드의 시퀀스 번호를 행 키로 사용하고 있습니다. 스토리지 테이블에 대한 개체 모델은 <a href=\"https://docs.microsoft.com/rest/api/storageservices/Understanding-the-Table-Service-Data-Model?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Table Service 데이터 모델 이해</a> 설명서 &ldquo; 에서 다룹니다.&rdquo; 또한 스토리지 <a href=\"https://docs.microsoft.com/rest/api/storageservices/designing-a-scalable-partitioning-strategy-for-azure-table-storage?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">테이블 디자인에 대한 권장 사항은 Azure Table Storage</a>&rdquo; 대한 확장 가능한 분할 전략 설계 설명서를 &ldquo; 참조하세요.</p>\n\n<p>ASA 작업에서 생성된 Azure Blob Storage Blob은 쉼표로 구분된 값(CSV) 형식으로 시간당 데이터의 단일 Blob으로 각 시간 동안 컨테이너로 구성됩니다. 향후 AI(인공 지능) 요구에 사용할 예정입니다.</p>\n\n<h2>Azure SQL Database 데이터 로드</h2>\n\n<p><a href=\"https://docs.microsoft.com/en-us/azure/sql-database/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">레코드를 Azure SQL Database</a> 증분 로드하는 기본 방법을 설명하고 나중에 새 집계 및 요약 데이터를 만들기 위해 레코드를 추가로 처리하기 위한 잠재적인 방법에 대해 설명합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ce89cb16-8404-46ac-b93a-42c6ce00d3d3.png\"><img alt=\"Loading data into Azure SQL Database\" border=\"0\" height=\"315\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/20d64a10-91d4-4195-8041-814ca2d764f8.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure SQL Database 데이터 로드\" width=\"709\"></a></p>\n\n<p>목표는 데이터가 데이터 저장소로 이동하는 방법을 보여주고 이에 유용한 기술을 보여 주는 베어본 접근 방식을 제공하는 것입니다. 모든 분석 솔루션은 컨텍스트 및 요구 사항에 크게 의존하지만 관련 Azure 서비스를 보여 주는 기본 메커니즘을 제공하려고 합니다.</p>\n\n<p>ADF(<a href=\"https://docs.microsoft.com/en-us/azure/data-factory/?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">Azure Data Factory</a>)는 자동화된 데이터 파이프라인에서 데이터 스토리지, 이동 및 처리 서비스를 구성하는 클라우드 통합 서비스입니다. 스토리지 테이블을 원본으로 사용하여 테이블을 증분 로드하는 방법을 보여 주는 간단한 ADF 파이프라인이 있습니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c30c821e-0a86-4787-8591-807a9158da9f.png\"><img alt=\"Azure Data Factory\" border=\"0\" height=\"128\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ea67bd9f-c961-4f44-b443-56b67dee68a9.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Azure Data Factory\" width=\"496\"></a></p>\n\n<p>파이프라인에는 SQL Database 대해 다음 쿼리를 수행하는 조회 작업이 있습니다.</p>\n\n<pre>\nselect\n     CONVERT(\n         char(30),\n         case when  max(SampleTimestamp) is null then &#39;1/1/2010 12:00:00 AM&#39;\n             else max(SampleTimestamp) end, 126) as LastLoad\nfrom [Samples]</pre>\n\n<p>CONVERT 함수 126에 사용되는 스타일은 스토리지 테이블에서 파티션 키 값의 문자열 표현과 일치하는 yyyy-mm-ddThh:mi:ss.mmm&rdquo;으로 &ldquo;형식이 지정될 타임스탬프 값을 나타냅니다. 쿼리는 SQL 데이터베이스로 전송된 마지막 레코드를 반환합니다. 그런 다음, 해당 값을 다음 작업으로 전달하여 테이블 스토리지를 쿼리하여 새 레코드를 검색할 수 있습니다.</p>\n\n<p>&ldquo;다음은 조회 작업의 반환된 값(LastLoad&rdquo;의 &ldquo;값)을 사용하고 원본에 대해 다음 테이블 쿼리를 만드는 데이터&rdquo; 복사 작업입니다. 스토리지 <a href=\"https://docs.microsoft.com/rest/api/storageservices/querying-tables-and-entities?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">테이블 쿼리에 대한 자세한 내용은 테이블 및 엔터티</a> 쿼리를 참조하세요.</p>\n\n<pre>\nSampleTimestamp gt datetime&#39;@{formatDateTime(activity(&#39;LookupSamples&#39;).output.FirstRow.LastLoad, &#39;yyyy-MM-ddThh:mm:ss.fffZ&#39;)}&#39;</pre>\n\n<p>나중에 이 작업은 스토리지 테이블 열(속성)을 SQL Database 테이블 열에 매핑합니다. 이 파이프라인은 15분마다 실행되도록 예약되므로 대상 SQL Database 테이블을 증분 방식으로 로드합니다.</p>\n\n<h3>처리 예제</h3>\n\n<p>원시 데이터를 추가로 처리하는 것은 실제 요구 사항에 따라 달라집니다. 이 섹션에서는 기능을 시연하기 위해 데이터를 처리하고 구성하는 두 가지 잠재적 접근 방식을 설명합니다.</p>\n\n<p>먼저 수집한 데이터를 보고 세부 정보를 검색해 보겠습니다&rsquo;. 샘플 테이블의 원시 데이터는 이름/값 쌍 형식입니다. 첫 번째 쿼리는 각 컴퓨터에서 기록한 다양한 샘플 형식을 제공합니다.</p>\n\n<pre>\nSELECT DeviceName, ComponentName, SampleName, COUNT(SampleSequence) AS SampleCount\nFROM Samples\nGROUP BY DeviceName, ComponentName, SampleName \nORDER BY DeviceName ASC, ComponentName ASC, SampleName ASC, SampleCount DESC</pre>\n\n<p>8대의 컴퓨터가 있으며 각 컴퓨터가 서로 다른 샘플 형식 집합을 보내는 것을 관찰합니다. 다음은 이전 쿼리의 부분 결과입니다. Microsoft Excel 결과를 좀 더 분석하여 샘플의 상대적 개수를 파악했습니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fc87e5c4-5a4d-4a19-8f61-a9c76f4c2728.png\"><img alt=\"Analysis of results in Microsoft Excel to give an idea of the relative counts of the samples.\" border=\"0\" height=\"521\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/45436e58-6c7c-4983-91f3-4578df0bd2f8.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"Microsoft Excel 결과를 분석하여 샘플의 상대적 개수를 파악합니다.\" width=\"471\"></a></p>\n\n<p>결과를 집계하고 요약하는 가장 좋은 방법은 컴퓨터별로 결과를 구성하는 것입니다(예: 컴퓨터 &mdash; 당 원시 데이터 테이블).</p>\n\n<p>여기서 개념을 보여 주는 단계별로 진행하겠습니다. 일부 독자는 확실히 일부 쿼리를 구현하는 더 최적화 된 방법을 찾을 수 있지만, 여기에 우리의 목표는 개념을 보여 명확한 예제를 제공하는 것입니다.</p>\n\n<p>다음과 같이 이름/값 쌍에 있는 원시 데이터를 먼저 변환하여 데이터를 추가로 처리할 수 있습니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bc6eca08-c921-4e63-afde-62a393dc0f1a.png\"><img alt=\"You may also process the data by first transposing the raw data, which is in name value pairs\" border=\"0\" height=\"490\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f308259f-20f3-478b-b9bb-3a1e1b755950.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"이름 값 쌍에 있는 원시 데이터를 먼저 트랜스페이징하여 데이터를 처리할 수도 있습니다.\" width=\"911\"></a></p>\n\n<p>다음 쿼리를 사용하여 새 테이블을 만들고 전체 행을 바꿉니다. 이 쿼리는 구성 요소를 구분하지 않고 컴퓨터 전체를 볼 수 있다고 가정합니다.</p>\n\n<pre>\n; WITH Machine08SamplesTransposed AS\n(\n     SELECT * FROM\n     (\n         SELECT  SampleTimestamp, sampleName, CAST(sampleValue AS NUMERIC(20,3)) AS sampleValueNumeric\n         FROM Samples\n         WHERE\n             DeviceName = &#39;Machine08&#39; and ISNUMERIC(sampleValue) != 0\n     ) AS S\n    \n     PIVOT(\n         MAX(sampleValueNumeric)\n         FOR SampleName IN ([S2temp],\n             [Stemp],\n             [Zabs],\n             [Zfrt],\n             [S2load],\n             [Cfrt],\n             [total_time],\n             [Xabs],\n             [Xload],\n             [Fact],\n             [Cload],\n             [cut_time],\n             [Zload],\n             [S2rpm],\n             [Srpm],\n             [auto_time],\n             [Cdeg],\n             [Xfrt],\n             [S1load])\n         ) AS PivotTable\n         )\n\nSELECT * INTO Machine08Samples \nFROM Machine08SamplesTransposed</pre>\n\n<p>이 쿼리를 매개 변수가 있는 저장 프로시저로 이동하여 로드된 최신 행만 가져오도록 원시 테이블을 쿼리하고 SELECT * INTO&rdquo;&hellip;&ldquo;를 INSERT * INTO로 수정하여 &ldquo;ADF 파이프라인으로 &hellip;&rdquo;가져올 수 있습니다. SQL 데이터베이스 리소스를 효율적으로 사용하려면 저장 프로시저를 최대한 사용하는 것이 좋습니다.</p>\n\n<p>결과 테이블은 다음과 같습니다(간결하게 하기 위해 일부 열이 제거됨).</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b246babc-605f-40d3-8dbb-3016a6476971.png\"><img alt=\"Results table\" border=\"0\" height=\"421\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8fb80e03-e7d7-425a-8120-d017fd6909fd.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"결과 테이블\" width=\"997\"></a></p>\n\n<p>이 중간 데이터 집합을 처리하는 한 가지 방법은 아래와 같이 마지막으로 받은 값에서 샘플의 null 값을 채우는 것입니다.</p>\n\n<p>모든 비즈니스 사례 및 모든 샘플 값에 대해 이 솔루션을 권장하지 않는다는 점을 강조해야 합니다. 이 방법은 함께 의미 있는 값에 적합합니다. 예를 들어 특정 경우 팩트(실제 경로 피드 속도) 및 Zfrt(Z 축 피드 속도)를 그룹화하면 적합할 수 있습니다. 그러나 다른 경우 Xabs(X축의 절대 위치)와 이러한 방식으로 그룹화된 한 레코드의 Zfrt는 의미가 없을 수 있습니다. 샘플 값의 그룹화는 비즈니스 요구 사항에 따라 사례별로 수행해야 합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4169c0f4-2f28-401f-a9ab-46d526447a93.png\"><img alt=\"Grouping of the sample values\" border=\"0\" height=\"230\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/17a037b4-74df-4116-86fc-1e777aeac7ca.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"샘플 값 그룹화\" width=\"1204\"></a></p>\n\n<p>또는 다른 방법은 개별 레코드를 시간 버킷에 넣고 해당 그룹에 집계 함수를 적용하는 것입니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/069ce023-fd36-4ed6-8bcf-b553d8b53c77.png\"><img alt=\"Another way is to put the individual records into time buckets, and apply an aggregate function in that group.\" border=\"0\" height=\"230\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/3eb7217d-9628-4886-a47a-4fcfdb68bdb2.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"또 다른 방법은 개별 레코드를 시간 버킷에 넣고 해당 그룹에 집계 함수를 적용하는 것입니다.\" width=\"1200\"></a></p>\n\n<p>첫 번째 옵션을 달성하기 위한 작은 예를 살펴보겠습니다&rsquo;. 앞의 예제에서는 t1에서 V1.1을 받았고 t2에서 V2.2를 받았습니다. t1s, V1.1을 사용하여 t2에 대한 Sample1 값을 입력하려고 합니다.</p>\n\n<pre>\n;WITH NonNullRank AS\n(\n     SELECT SampleTimestamp, S2temp,  cnt = COUNT(s2temp) OVER (ORDER BY SampleTimestamp)\n     FROM Machine08Samples\n),\n\nWindowsWithNoValues AS\n(\n     SELECT SampleTimestamp, S2temp, \nr = ROW_NUMBER() OVER (PARTITION BY cnt ORDER BY SampleTimestamp ASC) - 1\n     FROM NonNullRank\n)\n\nSELECT SampleTimestamp, S2temp,\nS2tempWithValues= ISNULL(S2temp, LAG(S2temp, r) OVER (ORDER BY SampleTimestamp ASC))\nFROM WindowsWithNoValues</pre>\n\n<p>위의 쿼리를 해부할 때 첫 번째 CTE(공통 테이블 식) NonNullRank은 수신된 데이터 레코드 중 S2temp 샘플 값의 null이 아닌 값의 순위를 제공합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ab986b60-a7be-4d80-a9bb-969d903354eb.png\"><img alt=\"Common table expression (CTE)\" border=\"0\" height=\"400\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bd73cc2c-6154-4114-9185-28ab570d2a64.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"CTE(Common Table Expression)\" width=\"274\"></a></p>\n\n<p>두 번째 CTE인 WindowsWithNoValues는 수신된 값이 맨 위에 있고 창(열 r) 내의 null 값 순서가 포함된 샘플 창을 제공합니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/da8cdee9-c909-4f2f-8bb8-7fcd34cde4cb.png\"><img alt=\"The second CTE, Windows With No Values\" border=\"0\" height=\"404\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c439ec81-74de-452f-895e-dad121f50916.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"값이 없는 Windows 두 번째 CTE\" width=\"273\"></a></p>\n\n<p>종료 쿼리는 창 맨 위에서 현재 행으로 수신된 값을 가져와 LAG 분석 함수를 사용하여 null 값을 채웁니다.</p>\n\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ce884a16-fd62-4dee-a7dd-d70cd294714b.png\"><img alt=\"The concluding query fills in the null values using the LAG analytic function.\" border=\"0\" height=\"401\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/732e4486-499f-4705-8ae7-d66712214b9a.png\" style=\"margin: 0px auto; border: 0px currentcolor; border-image: none; float: none; display: block; background-image: none;\" title=\"종료 쿼리는 LAG 분석 함수를 사용하여 null 값을 채웁니다.\" width=\"350\"></a></p>\n\n<p>앞에서 언급한 두 번째 옵션은 수신된 값을 그룹화하고 그룹 내에서 집계 함수를 적용하는 것입니다.</p>\n\n<pre>\n;WITH With30SecondBuckets AS\n(\n     SELECT *,\n(dateadd(second,(datediff\n(second,&#39;2010-1-1&#39;,[SampleTimestamp])/(30))*(30),&#39;2010-1-1&#39;))\nAS  [SampleTimestamp30Seconds]\n     FROM Machine08Samples\n)\n\nSELECT SampleTimestamp30Seconds, AVG(S2Temp)\nFROM With30SecondBuckets GROUP BY SampleTimestamp30Seconds\nORDER BY SampleTimestamp30Seconds</pre>\n\n<p>이러한 쿼리를 저장 프로시저에 배치하여 분석 솔루션에서 사용하는 데 필요한 새 집계 및 요약 테이블을 생성할 수 있습니다.</p>\n\n<p>여기서 열기 인수를 다시 한 번 반복하고 싶습니다. 분석 문제에 대한 해결 방법은 사용 가능한 데이터와 비즈니스에 필요한 사항에 따라 달라집니다. 단일 솔루션은 없지만 Azure는 지정된 솔루션을 구현하기 위한 많은 기술 옵션을 제공합니다.</p>\n\n<h2>다음 단계</h2>\n\n<ul>\n <li>다른 예제에 대해 Spark 작업 및 주문형 Azure HDInsight 연결된 서비스를 사용하여 클라우드에서 데이터를 변환하기 위한 ADF <a href=\"https://docs.microsoft.com/en-us/azure/data-factory/tutorial-transform-data-spark-portal?WT.mc_id=iotinsightsblog-blog-ercenk\" target=\"_blank\">자습서</a> 를 완료합니다.</li>\n <li><a href=\"https://aka.ms/manufacturingsolutionguide\" target=\"_blank\">솔루션 가이드</a>에서 IoT 데이터에서 인사이트를 추출하기 위한 더 큰 그림을 가져옵니다.</li>\n</ul>"
