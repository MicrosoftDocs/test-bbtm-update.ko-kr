### YamlMime:Yaml
ms.openlocfilehash: 91a9a4f6083bd6c4aa90719ae29e52e95e9028f7
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139899807"
Slug: i-miss-you-sql-server-agent-part-3
Title: '에이전트를 SQL Server 그리워요: 3부'
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 현재 SQL Azure SQL Server 에이전트의 개념이 없습니다. 이 블로그 시리즈에서는 경량 대체를 만들려고 합니다...'
Content: '<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>현재 SQL Azure SQL Server 에이전트의 개념이 없습니다. 이 블로그 시리즈에서는 Windows Azure 작업자 역할을 사용하여 경량 대체를 만들려고 합니다. 시리즈의 첫 번째 블로그 게시물에서 Windows Azure 작업자 역할이 SQL Server 에이전트와 어떻게 비교되는지 알아보고 Visual Studio 및 일부 코드를 시작했습니다. 두 번째 블로그 게시물에서는 하루에 한 번만 작업을 실행하는 작업자 역할을 코딩하는 방법을 설명했습니다. 이 시리즈의 세 번째 게시물에서는 Windows Azure 작업자 역할에 대한 오류 처리에 대해 자세히 알아보겠습니다.</p>  <h2>오류 처리</h2>  <p>다중 스레드 애플리케이션을 코딩할 때(예: 두 번째 블로그 게시물의 예제와 같이) 한 번 성공적으로 수행하려는 경우 오류 사례를 처리하는 것이 매우 중요합니다. 코드는 실제로 완료되었는지 또는 오류가 있었고 다시 시작해야 하는지 알고 있어야 합니다. 작업을 완료하기 전에 작업자 역할을 재활용하면 어떻게 되나요? 또는 작업자 역할이 예외를 throw합니까? 아니면 SQL Azure 일시적인 오류가 발생합니까? 예제 코드에서 이러한 상황에서 작업이 완료되지 않으면 데이터베이스에 시작 실행 날짜가 있지만 종료 실행 날짜가 없고 완료하려는 작업자 역할이 없는 행이 있습니다. 기본적으로 <b>StopJob</b> 저장 프로시저를 호출하지 않고 <b>StartJob</b> 저장 프로시저를 호출합니다. 작업자 역할이 작업을 처리할 때 행이 동일한 상태에 있다는 점에 유의해야 합니다. 두 작업 간에 작업을 수행하는 데 걸리는 시간을 서로 다르게 알려야 합니다.</p>  <h2>트랜잭션</h2>  <p>단일 데이터베이스의 단일 트랜잭션에서 작업을 완료할 수 있는 경우 Azure 작업자 역할 예외, Transact-SQL 오류 또는 SQL Azure 일시적인 오류에 Windows 복구할 작업 처리 시스템을 만들 수 있습니다.</p>  <p>SQL Azure 로컬 트랜잭션에 있는 작업을 완료하려고 하고(자세한 내용은 트랜잭션 블로그 게시물 참조) 클라이언트 쪽에 오류가 있는 경우 SQL Azure 대신 연결을 닫아 트랜잭션 롤백을 강제합니다. 즉, Windows Azure 작업자 역할이 어떤 이유로든 실패하는 경우(Windows Azure 오류 또는 클라이언트 쪽 예외에서) 연결이 닫히면 롤백이 발생합니다.</p>  <p>항상 다음 두 가지 결과 중 하나를 얻을 수 있습니다.</p>  <ul>   <li>작업 및 트랜잭션이 성공적으로 완료되었으며 Windows Azure 작업자 역할에서 <b>StopJob</b> 저장 프로시저를 호출할 수 있습니다. <b>StopJob</b>이 성공(나중에 설명)되도록 특별히 주의를 기울이면 하루에 한 번 추적을 성공적으로 유지할 수 있습니다.</li>    <li>Windows Azure 작업자 역할에는 연결이 닫히거나 작업 작업이 롤백되고 <b>StopJob</b>이 호출되지 않는 예외 또는 실패가 있습니다.</li> </ul>  <p>작업이 절반으로 실행되거나(SQL Azure 트랜잭션 덕분에) <b>StopJob</b>이 호출되고 트랜잭션이 롤백된 경우는 없습니다. 또한 동일한 범주에서 작업자 역할 예외 및 작업자 역할 오류를 번들로 묶어 동일한 오류 처리로 처리할 수 있음을 의미합니다.</p>  <h2>Self-Monitoring 작업자 역할</h2>  <p>우리는 경찰 작업 완료를 원하고 우리는 노동자 역할이 재활용 될 수 있다는 것을 알고 있다면, 우리는 완료되지 않은 노동자 작업을 정리해야합니다. 이 작업을 수행하는 가장 쉬운 방법은 작업이 실행될 수 있는 최대 시간을 가정하고 작업이 더 오래 실행된 데이터베이스의 모든 행을 삭제하는 것입니다. 그러나 완료되지 않았습니다. 행을 삭제하면 작업자 역할이 작업을 다시 시작하고 이번에는 오류 없이 완료되기를 바랍니다.</p>  <p>다음은 Transact-SQL 정리 코드가 한 시간 동안 실행된 모든 작업을 정리하는 것과 같습니다.</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">PROC</span> CleanUp  <span class="kwrd">AS</span>  <span class="kwrd">DELETE</span> jobactivity   <span class="kwrd">WHERE</span> stop_execution_date <span class="kwrd">IS</span> <span class="kwrd">NULL</span> <span class="kwrd">AND</span> DATEDIFF(<span class="kwrd">minute</span>,start_execution_date,GetDate()) &gt; 60 </pre>      <p>실행 중인 작업자 역할 인스턴스에서 기본 루프의 저장 프로시저 형식으로 호출됩니다.</p>    <pre class="csharpcode"><span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Run()  {      <span class="rem">// This is a sample worker implementation. Replace with your logic.</span>      Trace.WriteLine(<span class="str">&quot;WorkerRole1 entry point called&quot;</span>, <span class="str">&quot;Information&quot;</span>);        <span class="kwrd">while</span> (<span class="kwrd">true</span>)      {          <span class="rem">// WWB: Clean Up The Unfinished Jobs</span>          CleanUp();            DateTime nextExecutionTime = <span class="kwrd">new</span> DateTime(              DateTime.UtcNow.Year,              DateTime. UtcNow.Month, DateTime. UtcNow.Day,              13, 0, 0);            <span class="kwrd">if</span> (DateTime. UtcNow &gt; nextExecutionTime)          {              <span class="rem">// WWB: After 1:00 pm, Try to Get a Job Id.</span>              Guid? jobId = StartJob(<span class="str">&quot;TestJob&quot;</span>);              <span class="kwrd">if</span> (jobId.HasValue)              {                  Trace.WriteLine(<span class="str">&quot;Working&quot;</span>, <span class="str">&quot;Information&quot;</span>);                    <span class="rem">// WWB: This Method Has the Code That Execute</span>                  <span class="rem">// A Stored Procedure, The actual Job</span>                  ExecuteTestJob();                    StopJob(jobId.Value);              }                <span class="rem">// WWB: Sleep For An Hour</span>              <span class="rem">// This Reduces The Calls To StartJob</span>              Thread.Sleep(3600000);          }          <span class="kwrd">else</span>          {              <span class="rem">// WWB: Check Every Minute</span>              Thread.Sleep(60000);          }      }  }</pre>      <p>따라서 작업자 역할 인스턴스가 여러 개 있고 다른 하나는 여전히 실행 중인 작업을 정리하는 경우 작업의 실제 완료 시간이 예상보다 긴 경우 어떻게 되나요?</p>    <ul>    <li>작업 작업의 행은 정리하는 동안 잘못 작업자 역할 인스턴스에 의해 삭제됩니다.</li>      <li>다른 작업자 역할 인스턴스가 작업을 완료하고, StopJob이 호출되고, 행이 존재하지 않으므로 오류가 발생하지 않습니다.</li>      <li>그런 다음 작업이 다시 완료되어 하루에 한 번 목표를 위반합니다. 이와 같은 분산 시스템에서 하루에 한 번 보장할 수 있는 방법은 없습니다. 하루에 한 번 이상만 보장할 수 있습니다(정확히 한 번이 되도록 최선의 노력).</li>  </ul>    <p>성공하는 가장 좋은 방법은 저장 프로시저 정리에서 최대 런타임에 대한 가정이 매우 관대하도록 하는 것입니다.</p>    <p>또한 시간에 매우 주의해야 합니다. 하루 중 너무 늦게 작업을 시작하고 최대 런타임에 대한 가정이 너무 길면 작업이 실패할 경우 작업을 완료하는 데 남은 시간이 없을 수 있습니다. 예를 들어 오후 11시부터 45분 정도 걸리는 작업이 있는 경우 <b>CleanUp</b> 저장 프로시저가 행을 제거해야 하므로 작업을 다시 처리할 시간이 부족합니다.</p>    <h2>SQL Azure 일시적인 오류</h2>    <p>SQL Azure 일시적인 오류는 SQL Azure 장애 조치(failover)가 발생할 때 발생하는 오류이지만 잠시 후 동일한 호출은 오류가 발생하지 않습니다. 자세한 내용은 이 블로그 게시물에서 확인할 수 있습니다. 작업이 성공적으로 완료된 경우 <b>StopJob</b> 저장 프로시저를 성공적으로 호출하는 것이 매우 중요합니다. 이러한 이유로 <b>StopJob</b> 저장 프로시저를 호출할 때 블로그 게시물에 설명된 재시도 시나리오를 수행해야 합니다. 오류로 인해 Windows Azure 작업자 역할 인스턴스가 재활용되고 정리 후 작업이 다시 실행되므로 SQL Azure 다른 모든 쿼리에서 일시적인 오류를 확인할 필요가 없습니다.</p>    <h2>오류 보고</h2>    <p>이러한 블로그 게시물은 몇 가지 오류 처리 및 재시도 시나리오를 다루었습니다. 그러나 오류 보고에 대해 이야기하지 않았습니다. 작업이 실패한 시기를 아는 것이 좋지 않을까요? 행을 정리해야 하는 경우 Windows Azure Diagnostics를 사용하여 이 작업을 수행할 수 있습니다. 자세한 내용은 여기를 참조<a href="https://msdn.microsoft.com/en-us/library/ee758705.aspx">하세요</a>.</p>    <h2>요약</h2>    <p>이 시리즈를 교정하고 모든 조각이 어떻게 함께 진행되어야 하는지에 대한 아이디어를 준 스티브 마르크스에게 감사드립니다. 여기에서 Azure에 초점을 맞춘 그의 Windows 블로그를 찾을 수 있으며 여기에서 트위터에서 그를 찾을 수 <a href="https://twitter.com/smarx">있습니다</a>. </p>    <p>이 블로그 시리즈는 SQL Server 에이전트의 모든 기능을 대체하려고 하지 않습니다. 내 목표는 Windows Azure 작업자 역할을 사용하여 기본 SQL Server 에이전트 기능을 복제할 수 있음을 보여 주는 간단한 코드를 보여 주는 것이었습니다.</p>    <p>동일한 작업을 수행할 수 있는 더 나은 방법이 있나요? 아래의 의견에 게시합니다. 질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>'
