### YamlMime:Yaml
ms.openlocfilehash: cb8a61e9a6308f1fa6480c9acdd387bd12fa6622
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901453"
Slug: api-versioning-with-azure-api-management
Title: Azure API Management를 사용하여 API 버전 관리
Summary: 'HTTP API를 빌드하는 개발자와 통신할 때 버전 관리의 주제가 정기적으로 제공됩니다. 빠른 웹 검색은 주제에 대한 지침을 홍보하는 수백 개의 문서를 공개합니다. '
Content: >-
  <p>HTTP API를 빌드하는 개발자와 통신할 때 버전 관리의 주제가 정기적으로 제공됩니다. 빠른 웹 검색은 주제에 대한 지침을 홍보하는 수백 개의 문서를 공개합니다. 안타깝게도 이러한 &quot;모범 사례&quot; 중 상당수에는 모순되는 정보가 포함되어 있습니다. 예를 들어 첫 번째 릴리스에서 URL에 v1을 항상 포함해야 하는 경우도 있습니다. 다른 사람들은 이것이 정말 나쁜 생각이라고 말합니다. 우리 팀이 직면한 과제는 접근 방식에 관계없이 모든 개발자에게 도움이 될 수 있는 버전 관리 기능을 구축하는 방법이었습니다.</p>


  <p>다양한 버전 식별 메커니즘을 지원하는 것이 매우 쉽다는 것을 빠르게 발견했습니다. 실제 과제는 변경 사항을 새 버전으로 배포해야 하는 경우와 그렇지 않은 경우를 아는 것입니다. 개발자를 방해하지 않는 방식으로 호환성이 손상되지 않는 변경 내용과 호환성이 손상되지 않는 변경 내용을 모두 지원해야 했습니다. 그러나 우리가 그렇게 말할 때 우리는 무엇을 의미합니까?</p>


  <h2>호환성이 손상되는 변경이란?</h2>


  <p>호환성이 손상되는 <i>변경</i>이라는 용어를 사용하지 않고 몇 분 이상 API 버전 관리와 관련된 대화를 나누는 것은 거의 불가능할&#39;. 모두가 호환성이 손상되는 변화의 결과를 이해하지만, 호환성이 손상되는 변화에 대한 합의에 도달하려고 노력하는 것은 훨씬 더 어렵습니다. 대부분의 개발자는 선호하는 프로그래밍 언어에서 호환성이 손상되는 변경에 대한 정의를 전달하는 경향이 있습니다. 해당 공간 내에는 일반적으로 컴파일러 또는 런타임 엔진에서 정의되는 인터페이스를 중단&quot;시킬 항목을 &quot;정의하는 일관된 규칙 집합이 있습니다. 그러나 HTTP API는 도구가 표준화된 규칙 집합을 적용하지 못하도록 경계를 넘습니다. 개발자가 HTTP API를 관리하는 데 도움이 되도록 소프트웨어 구성 요소 세계에서 차용한 <i>호환성이 손상되는 변경</i>의 개념에 의존하는 것은 문제가 있는 것처럼 보였습니다.</p>


  <h2>HTTP API가 다릅니다.</h2>


  <p>HTTP API가 구성 요소 API와 다르게 동작하는 두 가지 주요 이유가 있습니다.</p>


  <ul>
      <li>클라이언트 코드는 이를 중단시킬 내용을 지시합니다.</li>
      <li>API 공급자는 변경 내용이 옵트인(opt-in) 또는 투명한지 여부를 선택합니다.</li>
  </ul>


  <h2>HTTP 클라이언트 컨트롤 결합</h2>


  <p>HTTP API를 사용하면 운영 체제, 언어, 컴파일러, 라이브러리가 서로 다른 매우 다양한 시스템 간에 호출할 수 있습니다. API 공급자는 소비자가 API 응답을 해석하는 데 사용할 수 있는 도구를 제어할 수 없습니다. 이러한 도구의 변경 허용 오차도 매우 다양합니다. API 공급자가 HTTP 응답을 변경하는 경우 클라이언트 중단은 전적으로 클라이언트&#39;선택한 도구에 따라 달라집니다. JSON이 최근 몇 년 동안 XML을 크게 대체한 이유 중 하나는 JSON 공간의 대부분의 도구가 특히 XML 도구와 비교하여 데이터 구조 변경에 매우 관대하게 접근하기 때문입니다. 이 무차별 허용 오차는 성능 비용이 발생하지만 성능에 민감한 시나리오에서 Protobuf, Thrift 및 Bond와 같은 이진 형식으로 다시 이동하는 것을 보는 이유 중 하나입니다.</p>


  <h2>API 공급자 제어 타이밍</h2>


  <p>재사용 가능한 소프트웨어 구성 요소는 일반적으로 패키지 관리자를 통해 배포됩니다. 소프트웨어 구성 요소를 사용하는 클라이언트는 패치 업데이트로 식별되더라도 새 버전의 구성 요소를 명시적으로 옵트인해야 합니다. HTTP API를 사용하면 그렇게 할 필요가&#39;. API 공급자는 API를 업데이트할 수 있으며 응답에 대한 변경 내용은 클라이언트 소비자에게 즉시 영향을 줍니다. 그러나 경로 세그먼트의 버전 번호와 같은 예상 요청 메시지에서 특정 종류의 버전 식별자를 업데이트하면 API 공급자는 클라이언트가 준비가 되면 변경에 옵트인할 수 있습니다. Azure API Management를 사용하면 기존 API 정의를 가져와서 새 버전을 만들 수 있습니다. 새 버전은 경로, 쿼리 문자열 또는 HTTP 헤더의 식별자를 통해 요청 메시지에서 식별됩니다.</p>


  <p>잠재적으로 모든 클라이언트가 변경 허용 오차가 다르다는 것을 받아들인다면, 이는 배포하는 모든 변경 내용이 클라이언트 중단을 방지하기 위해 옵트인(opt-in)되어야 한다는 것을 의미합니까? 그렇지 않을 것입니다. 핵심은 API 소비자와 함께 명시적으로 기대치를 설정하는 것입니다.</p>


  <h2>명시적이어야 합니다.</h2>


  <p>소비자는 옵트인할 수 있는 API 변경 유형과 투명하게 적응해야 하는 변경 유형을 알아야 합니다. 예를 들어 대부분의 API는 클라이언트가 개체를 구문 분석하지 못한 채 JSON 개체에 새 속성을 추가할 수 있을 것으로 예상합니다. 클라이언트는 단순히 새 속성을 무시하거나 값을 왕복할 수 있습니다. 그러나 이러한 기대는 일반적으로 사용되는 도구의 기본 동작을 기반으로 합니다. 장기적인 상호 운용성을 보장하기 위해 명시적으로 문서화해야 합니다.</p>


  <h2>수정 버전에서는 투명한 업데이트를 사용할 수 있습니다.</h2>


  <p>투명한 업데이트 배포를 관리하기 위해 Azure API Management는 API 정의 버전을 만드는 기능과는 다른 두 번째 기능을 도입하고 있습니다. 이제 API 정의의 수정 버전을 만들고 독립적으로 변경할 수 있습니다. Azure API Management에 정의된 모든 API 및 API 버전에는 수정 버전 집합이 있을 수 있습니다. 주요 차이점은 수정 버전이 하나만 <i>현재</i> 버전으로 간주되고 모든 수정 버전이 동일한 공용 URL(및 사용된 경우 버전 식별자)을 공유한다는 것입니다. 새 수정 버전을 <i>현재</i> 버전으로 표시하면 소비자에게 변경 내용을 투명하게 배포할 수 있습니다. 이전 수정 버전으로 롤백하는 것은 <i>다시 현재</i> 버전으로 표시하는 것만큼 간단합니다.</p>


  <p>API 게시자가 현재가 아닌 수정 버전을 테스트하고 디버그할 수 있도록 하려면 URL에서 특수 행렬 매개 변수를 사용할 수 있습니다. 예를 들어 API에 두 개의 수정 버전이 있고 rev=1이 현재 수정 버전으로 간주되는 경우 다음 URL을 사용하여 rev=2를 테스트할 수 있습니다.</p>


  <p>GET https://example.org/api;rev=2/customers</p>


  <h2>변화에 대한 다른 관점</h2>


  <p>HTTP API의 변경 관리는 결코 쉽지 않습니다. 그러나 변경에 대해 다른 관점을 취함으로써 Azure API Management 버전 및 수정 버전 기능을 사용하면 모든 관점의 개발자를 위해 변경 내용을 더 간단하게 관리할 수 있습니다. API 소비자는 다양한 유형의 변경 내용에 대한 배달 메커니즘에 대해 명시적으로 설명함으로써 중단되지 않는 클라이언트를 배포하는 데 자신감을 가질 수 있으며, API 공급자는 클라이언트를 중단하지 않는 변경을 자신할 수 있습니다.</p>
