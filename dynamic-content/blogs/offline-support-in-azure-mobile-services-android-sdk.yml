### YamlMime:Yaml
ms.openlocfilehash: 0f20b6fc329fe43187647c48bbface2d2f7f9c6e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139908813"
Slug: offline-support-in-azure-mobile-services-android-sdk
Title: Azure Mobile Services Android SDK의 오프라인 지원
Summary: 최신 버전의 Android용 Azure Mobile Services SDK는 미래(비동기 작업) 및 오프라인(연결이 끊긴 애플리케이션)에 대한 지원을 추가했습니다. 이 게시물에서는 포털에서 다운로드한 샘플 애플리케이션(할 일 목록)을 오프라인으로 사용하도록 설정하는 데 필요한 단계를 안내하여 오프라인 기능을 안내합니다. 앱에 필요한 기능에 대해 살펴보겠습니다.
Content: >-
  <a href="https://azure.microsoft.com/blog/2014/08/04/futures-support-and-breaking-changes-in-azure-mobile-services-android-sdk/">마지막 게시물</a>에서 선물에 대한 지원을 도입한 Azure Mobile Services 대한 Android SDK의 새로운(알파) 버전에 대해 이야기했습니다. 이 게시물에서 이제 Android SDK가 관리형 및 iOS와 기능 패리티에 있도록 오프라인 지원을 추가했다고 간략하게 언급했습니다. 이 게시물에서는 Todo 앱을 오프라인으로 사용하도록 설정하는 데 필요한 단계를 안내하고 앱에서 필요에 따라 각 기능에 대해 이야기함으로써 오프라인 지원에 대해 자세히 살펴보겠습니다.


  <b>TL;DR</b>: 게시물은 Azure Mobile Services <a href="https://aka.ms/Iajk6q">Android SDK의 새 버전</a>에서 릴리스된 기능을 사용하여 Azure Portal에서 다운로드한 빠른 시작 애플리케이션을 오프라인으로 사용하도록 업데이트하는 방법을 보여 줍니다. 샘플 리포지토리에서 이 게시물의 예제에 <a title="https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807" href="https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807">대한 전체 코드를 보고 기본 리포지</a> 토리 <a href="https://github.com/Azure/azure-mobile-services/tree/android">의 Android 분기</a>에서 SDK 원본을 확인할 수도 있습니다.

  <h2>초기 설정</h2>

  연습을 시작하려면 포털에서 다운로드할 수 있는 빠른 시작 애플리케이션을 사용하겠습니다. 새 모바일 서비스를 만듭니다. 이 예제에서는 Visual Studio 사용할 필요 없이 설정할 수 있는 node.js 백 엔드를 사용하겠습니다.


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/001-CreateMobileService.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="001-CreateMobileService" alt="001-CreateMobileService" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/001-CreateMobileService_thumb.png" width="484" height="375" border="0" /></a>


  서비스가 만들어지면 Android 플랫폼을 선택한 다음, "TodoItem 테이블 만들기"를 선택한 다음, 시작 프로젝트를 컴퓨터에 다운로드합니다.


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/002-DownloadTodoApp.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="002-DownloadTodoApp" alt="002-DownloadTodoApp" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/002-DownloadTodoApp_thumb.png" width="440" height="484" border="0" /></a>


  Eclipse에서 프로젝트를 열면 시작할 준비가 된 것입니다.

  <h2>빠른 시작 앱 업데이트</h2>

  여기에서 미리 보는 오프라인 지원에는 몇 가지 좋은 기능이 있습니다. 그 중 하나는 Azure의 테이블에 로컬 변경 내용을 푸시할 때 발생할 수 있는 충돌을 해결하는 기능입니다. 예를 들어 두 휴대폰에서 동일한 앱을 실행하고 두 휴대폰에서 <em>동일한</em> 항목을 로컬로 변경한 경우 변경 내용을 서버에 다시 푸시할 준비가 되면 그 중 하나가 충돌하여 실패합니다. SDK를 사용하면 코드를 통해 이러한 충돌을 처리하고 충돌이 있는 항목으로 수행할 작업을 결정할 수 있습니다.


  그러나 항목에 대해 수행할 수 있는 유일한 작업은 완료로 표시하는 것뿐이므로 현재 빠른 시작에는 충돌이 발생할 수 있는 경우가 많지 않습니다. 사실, 한 클라이언트에서 항목을 완료로 표시한 다음 다른 클라이언트에서 동일한 작업을 수행할 수 있지만 기술적으로는 충돌이지만(프레임워크에서 플래그를 지정합니다) 너무 흥미롭지 않습니다. 그런 다음, 할 일 항목의 전체 편집을 허용하여 더 흥미로울 수 있도록 빠른 시작을 변경해 보겠습니다.


  다운로드할 수 있는 코드에서 항목을 편집할 수 있도록 앱을 업데이트한 것을 확인할 수 있습니다. 내가 그랬던 것과 동일한 단계를 수행하려면 <a href="#Appendix">이 게시물의 끝에 부록으로</a> 갈 수 있습니다.

  <h2>SDK 업데이트</h2>

  애플리케이션에서 오프라인 지원을 추가하기 위해 가장 먼저 해야 할 일은 이를 지원하는 Mobile Services Android SDK 버전을 가져오는 것입니다. 미리 보기 기능으로 출시했으므로 공식 다운로드 위치에 있지 않습니다. 지금은 로컬로 <a title="https://aka.ms/Iajk6qhttps://aka.ms/Iajk6q" href="https://aka.ms/Iajk6q"></a> 이동하여 다운로드할 수 있습니다. 다운로드되면 mobileservices-2.0.0-alpha.jar 및 guava-17.0.jar 파일을 추출하고 프로젝트의 libs 폴더에 복사합니다. SDK의 이전 버전(이 블로그, mobileservices-1.1.5.jar 작성 시)을 제거하고 Eclipse에서 libs 폴더의 내용을 새로 고칩니다.


  이제 프로젝트에 많은 오류가 발생합니다. <a href="https://azure.microsoft.com/blog/2014/08/04/futures-support-and-breaking-changes-in-azure-mobile-services-android-sdk/">이전 게시물에</a> 나열된 호환성이 손상되는 변경으로 인해 발생합니다. 대부분 ToDoActivity.java에 있지만 대부분은 다른 패키지로 이동한 클래스와 관련이 있습니다. Eclipse에서 파일을 선택한 후 "원본" 메뉴(Ctrl+Shift+O)에서 "가져오기 구성"을 선택하면 대부분 수정됩니다. 나머지 항목을 해결하려면 클래스 선언 앞에 다음 가져오기를 추가합니다.

  <pre class="prettyprint">import static com.microsoft.windowsazure.mobileservices.table.query.QueryOperations.*;</pre>

  그리고 미래를 사용하여 인터페이스에 대한 새 계약을 준수하기 위한 진행률을 나타내는 데 사용되는 서비스 필터를 업데이트합니다.

  <pre class="prettyprint">private class ProgressFilter implements ServiceFilter {

      @Override
      public ListenableFuture&lt;ServiceFilterResponse&gt; handleRequest(
              ServiceFilterRequest request, NextServiceFilterCallback next) {

          runOnUiThread(new Runnable() {

              @Override
              public void run() {
                  if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.VISIBLE);
              }
          });

          ListenableFuture&lt;ServiceFilterResponse&gt; result = next.onNext(request);

          Futures.addCallback(result, new FutureCallback&lt;ServiceFilterResponse&gt;() {
              @Override
              public void onFailure(Throwable exc) {
                  dismissProgressBar();
              }

              @Override
              public void onSuccess(ServiceFilterResponse resp) {
                  dismissProgressBar();
              }

              private void dismissProgressBar() {
                  runOnUiThread(new Runnable() {

                      @Override
                      public void run() {
                          if (mProgressBar != null) mProgressBar.setVisibility(ProgressBar.GONE);
                      }
                  });
              }
          });

          return result;
      }
  }</pre>

  이제 앱은 최신 SDK를 사용하며, 이제 이전과 마찬가지로 계속 작동해야 합니다.

  <h2>새(선물 기반) API를 사용하도록 모바일 서비스 호출 업데이트</h2>

  오프라인을 사용하도록 설정하기 전에 수행해야 하는 한 가지 단계는 이 릴리스에 도입된 새로운 미래 기반 API를 사용하도록 테이블 작업을 변경하는 것입니다. 오프라인으로 사용되는 클래스에는 콜백 기반 메서드가 없으므로 완전히 연결된 애플리케이션에서 가끔 연결된 애플리케이션으로 쉽게 전환할 수 있습니다. 작업을 백그라운드 스레드에 포함할 수 있는 작업을 시작하고 작업 결과를 얻게 되면 UI 구성 요소를 변경해야 하는 경우 호출을 기본(UI) 스레드에 다시 게시해야 합니다. 예를 들어 메서드는 <code>addItem</code> 다음과 같이 다시 작성됩니다.

  <pre class="prettyprint">public void addItem(View view) {
      if (mClient == null) {
          return;
      }

      // Create a new item
      final ToDoItem item = new ToDoItem();

      item.setText(mTextNewToDo.getText().toString());
      item.setComplete(false);

      // Insert the new item
      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  mToDoTable.insert(item).get();
                  if (!item.isComplete()) {
                      runOnUiThread(new Runnable() {
                          public void run() {
                              mAdapter.add(item);
                          }
                      });
                  }
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();

      mTextNewToDo.setText("");
  }</pre>

  업데이트 메서드는 다음과 유사합니다.

  <pre class="prettyprint">private void updateItem(final ToDoItem item) {
      if (mClient == null) {
          return;
      }

      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  mToDoTable.update(item).get();
                  runOnUiThread(new Runnable() {
                      public void run() {
                          if (item.isComplete()) {
                              mAdapter.remove(item);
                          }
                          refreshItemsFromTable();
                      }
                  });
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();
  }</pre>

  마지막으로 테이블에서 항목을 검색하려는 경우 동일한 작업을 수행해야 합니다.

  <pre class="prettyprint">private void refreshItemsFromTable() {

      // Get the items that weren't marked as completed and add them in the
      // adapter
      new AsyncTask&lt;Void, Void, Void&gt;() {

          @Override
          protected Void doInBackground(Void... params) {
              try {
                  final MobileServiceList&lt;ToDoItem&gt; result = mToDoTable.where().field("complete").eq(false).execute().get();
                  runOnUiThread(new Runnable() {

                      @Override
                      public void run() {
                          mAdapter.clear();

                          for (ToDoItem item : result) {
                              mAdapter.add(item);
                          }
                      }
                  });
              } catch (Exception exception) {
                  createAndShowDialog(exception, "Error");
              }
              return null;
          }
      }.execute();
  }</pre>

  이 시점에서 애플리케이션을 다시 실행할 수 있어야 하며 이전과 마찬가지로 계속 작동해야 합니다.

  <h2>테이블에서 동기화 테이블로</h2>

  이제 앱을 오프라인으로 만들 준비가 되었습니다. 가장 먼저 해야 할 일은 테이블에 액세스하는 데 사용하는 클래스를 변경하는 것입니다. 또는 새 클래스를 <code>MobileServiceJsonTable</code>사용하는 <code>MobileServiceTable&lt;E&gt;</code> 대신 새 클래스를 <code>MobileServiceJsonSyncTable</code> 사용합니다<code>MobileServiceSyncTable&lt;E&gt;</code>. 다른 플랫폼과 마찬가지로 동기화 테이블은 기본적으로 로컬로 변경한 내용을 해당 "원격" 테이블에 푸시하는 방법과 원격 테이블에서 로컬로 "끌어오기"를 수행하는 방법을 "알고 있는" 로컬 테이블입니다. 변경 내용 추적은 동기화 컨텍스트를 통해 수행되며, 로컬로 항목을 저장하는 데 사용되는 로컬 저장소를 사용하여 초기화해야 합니다. Mobile Services SDK는 SQLite 데이터베이스를 기반으로 저장소의 구현을 제공하며 이 게시물에 사용합니다.


  먼저 로컬 저장소의 초기화를 처리하겠습니다. 메서드에서 <code>onCreate</code> 인스턴스를 만든 후 다음 줄을 추가합니다 <code>MobileServiceClient</code> .

  <pre class="prettyprint">SQLiteLocalStore localStore = new SQLiteLocalStore(mClient.getContext(), "ToDoItem", null, 1);

  SimpleSyncHandler handler = new SimpleSyncHandler();

  MobileServiceSyncContext syncContext = mClient.getSyncContext();


  Map&lt;String, ColumnDataType&gt; tableDefinition = new HashMap&lt;String, ColumnDataType&gt;();

  tableDefinition.put("id", ColumnDataType.String);

  tableDefinition.put("text", ColumnDataType.String);

  tableDefinition.put("complete", ColumnDataType.Boolean);


  localStore.defineTable("ToDoItem", tableDefinition);

  syncContext.initialize(localStore, handler).get();</pre>

  마지막 몇 줄은 로컬 테이블에 액세스하거나(저장소에서 정의) 컨텍스트를 초기화할 때 예외를 throw할 수 있으므로 예외 처리기도 업데이트하여 처리해야 합니다.

  <pre class="prettyprint">} catch (MalformedURLException e) {
      createAndShowDialog(new Exception("There was an error creating the Mobile Service. Verify the URL"), "Error");
  } catch (Exception e) {
      Throwable t = e;
      while (t.getCause() != null) {
          t = t.getCause();
      }
      createAndShowDialog(new Exception("Unknown error: " + t.getMessage()), "Error");
  }</pre>

  컨텍스트가 초기화되었으므로 주 작업의 필드 형식 <code>mToDoTable</code> 을 변경합니다<code>MobileServiceSyncTable&lt;ToDoItem&gt;</code>.<code>MobileServiceTable&lt;ToDoItem&gt;</code> 메서드에서 <code>onCreate</code> 메서드를 사용하도록 해당 필드의 초기화를 변경합니다 <code>getSyncTable</code> . 우리가 변경해야 할 또 다른 것이 있습니다. 로컬 테이블에서 읽을 때 쿼리를 전달해야 하며 "일반" 테이블에서 쿼리 개체를 가져올 수 있습니다. 따라서 새 프라이빗 필드를 정의합니다.

  <pre class="prettyprint">/**
   * The query used to pull data from the remote server
   */
  private Query mPullQuery;</pre>

  메서드에서 <code>onCreate</code> 초기화합니다.

  <pre class="prettyprint">// Saves the query which will be used for reading data

  mPullQuery = mClient.getTable(ToDoItem.class).where().field("complete").eq(false);</pre>

  그리고 해당 쿼리를 사용하도록 refreshItemsFromTable 메서드의 코드를 업데이트합니다.

  <pre class="prettyprint">final MobileServiceList&lt;ToDoItem&gt; result = mToDoTable.read(mPullQuery).get();</pre>

  이제 앱을 실행할 수 있으며 완전히 오프라인으로 실행됩니다.

  <h2>끌어서 밀기</h2>

  이전에 앱을 실행한 경우 이상한 것을 발견했을 수 있습니다. 이전에 앱에 표시되었던 항목은 목록에 더 이상 표시되지 않습니다. 문제는 현재 로컬(동기화) 테이블과 통신하고 있지만 서버 쪽과 동기화를 수행하지 않는다는 것입니다. 따라서 이 코드를 처음 실행하는 경우 빈(로컬) 테이블에 대해 실행됩니다. 수행해야 할 일은 동기화 테이블에 서버에서 기존 데이터를 가져오도록 지시하고 서버 쪽에 로컬로 변경한 내용을 푸시하는 것입니다.


  빠른 시작 앱에는 해당 논리인 새로 고침 메뉴 항목(앱의 오른쪽 위 모서리에 있음)을 구현할 수 있는 좋은 위치가 있습니다. 다른 앱에는 데이터를 동기화해야 하는 경우에 대한 요구 사항이 다를 수 있지만 데모용으로 사용자가 명시적으로 요청하게 됩니다. 메서드에서 <code>onOptionsItemSelected</code> 새 백그라운드 작업을 시작하고 해당 위치에서 먼저 동기화 컨텍스트를 사용하여 로컬 저장소에 적용된 모든 변경 내용을 푸시하고 나중에 동기화 테이블을 통해 로컬 테이블로 이동하려는 모든 데이터를 끌어옵니다.

  <pre class="prettyprint">public boolean onOptionsItemSelected(MenuItem item) {
      if (item.getItemId() == R.id.menu_refresh) {
          new AsyncTask&lt;Void, Void, Void&gt;() {

              @Override
              protected Void doInBackground(Void... params) {
                  try {
                      mClient.getSyncContext().push().get();
                      mToDoTable.pull(mPullQuery).get();
                      refreshItemsFromTable();
                  } catch (Exception exception) {
                      createAndShowDialog(exception, "Error");
                  }
                  return null;
              }

          }.execute();
      }

      return true;
  }</pre>

  이제 앱을 실행하고 새로 고침 단추를 탭하면 서버의 모든 항목이 표시됩니다. 이 시점에서 디바이스에서 네트워킹을 끄고 계속 변경할 수 있어야 합니다. 앱이 제대로 작동합니다. 변경 내용을 서버와 동기화할 때 네트워크를 다시 켜고 '새로 고침' 단추를 다시 탭합니다.


  한 가지 주의해야 할 사항은 로컬 저장소에 보류 중인 변경 내용이 있는 경우 끌어오기 작업이 먼저 해당 변경 내용을 서버에 푸시합니다(동일한 행에 변경 내용이 있는 경우 푸시 작업이 실패하고 애플리케이션이 충돌을 적절하게 처리할 수 있도록). 즉, 위의 코드에서 푸시 호출이 반드시 필요한 것은 아니지만 코드가 수행하는 작업을 명시하는 것이 항상 좋은 사례라고 생각합니다.

  <h2>충돌 처리</h2>

  데이터를 오프라인으로 처리하는 것이 좋지만 푸시 작업이 실행될 때 충돌이 발생하면 어떻게 되나요? 지금까지 <code>ToDoItem</code> 앱이 작성되었으므로 클래스는 버전 열을 저장하지 않으므로 서버 데이터의 이전 변경 내용을 무시하고 서버 데이터(기본적으로 "클라이언트 우선" 충돌 해결 정책)를 덮어씁니다. 그러나 우리가 그보다 똑똑할 수 있다면. 먼저 <a href="https://blogs.msdn.com/b/carlosfigueira/archive/2013/11/23/new-tables-in-azure-mobile-services-string-id-system-properties-and-optimistic-concurrency.aspx">낙관적 동시성이</a> 적용되고 업데이트가 항목 버전에 조건부가 되도록 버전을 추가해 보겠습니다. 클래스에서 <code>ToDoItem</code> 다음 멤버를 추가합니다.

  <pre class="prettyprint">/**
   * The version of the item in the database
   */
  @com.google.gson.annotations.SerializedName("__version")

  private String mVersion;


  /**
   * Gets the version of the item in the database
   *
   * @return the version of the item in the database
   */
  public String getVersion() {
      return mVersion;
  }


  /**
   * Sets the version of the item in the database
   *
   * @param mVersion the version of the item in the database
   */
  public void setVersion(String mVersion) {
      this.mVersion = mVersion;
  }</pre>

  그리고 메서드 로컬 테이블을 <code>onCreate</code> 정의할 때 새 열을 추가합니다.

  <pre class="prettyprint">tableDefinition.put("__version", ColumnDataType.String);</pre>

  이제 Fiddler 또는 Postmon과 같은 도구를 사용하여 항목을 편집하고 애플리케이션에서 동일한 항목을 편집하거나 두 개의 다른 디바이스/에뮬레이터에서 동일한 항목을 편집하는 경우 푸시하려고 하면 오류가 발생합니다. 그러나 아래와 같이 사용자 지정 동기화 처리기를 구현하여 해당 오류를 처리하고 자체 충돌 해결 정책을 구현할 수 있습니다.

  <pre class="prettyprint">private class ConflictResolvingSyncHandler implements MobileServiceSyncHandler {

      @Override
      public JsonObject executeTableOperation(
              RemoteTableOperationProcessor processor, TableOperation operation)
              throws MobileServiceSyncHandlerException {

          MobileServicePreconditionFailedExceptionBase ex = null;
          JsonObject result = null;
          try {
              result = operation.accept(processor);
          } catch (MobileServicePreconditionFailedExceptionBase e) {
              ex = e;
          } catch (Throwable e) {
              ex = (MobileServicePreconditionFailedExceptionBase) e.getCause();
          }

          if (ex != null) {
              // A conflict was detected; let's force the server to "win"
              // by discarding the client version of the item
              // Other policies could be used, such as prompt the user for
              // which version to maintain.
              JsonObject serverItem = ex.getValue();

              if (serverItem == null) {
                  // Item not returned in the exception, retrieving it from the server
                  try {
                      serverItem = mClient.getTable(operation.getTableName()).lookUp(operation.getItemId()).get();
                  } catch (Exception e) {
                      throw new MobileServiceSyncHandlerException(e);
                  }
              }

              result = serverItem;
          }

          return result;
      }

      @Override
      public void onPushComplete(MobileServicePushCompletionResult result)
              throws MobileServiceSyncHandlerException {
      }
  }</pre>

  이제 앱을 실행하고 충돌이 발생하면 자동으로 처리됩니다.

  <h2>요약</h2>

  이제 네이티브 iOS 애플리케이션에 대한 오프라인 지원을 추가하고 있으며, 관리되는 SDK와 마찬가지로 미리 보기 형식으로 릴리스합니다. Azure Mobile Services 대한 SDK를 계속 개선할 수 있도록 여러분의 의견을 진심으로 감사드립니다. 평소와 같이 <a href="https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile">MSDN 포럼</a> 또는 트위터를 <a href="https://twitter.com/azuremobile">@AzureMobile</a>통해이 게시물에 의견 / 제안 / 질문을 남겨주세요.


  이 게시물에 사용된 코드를 다운로드하려면 샘플 리포지토리의 GitHub 모바일 서비스 <a href="https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/Android/blog20140807">샘플 리포지토리</a>에서 다운로드할 수 있습니다. 그리고 Android용 Azure Mobile Service SDK 버전 2.0 알파를 가져올 수 있습니다<a title="</a>https://aka.ms/Iajk6q" href="https://aka.ms/Iajk6q">https://aka.ms/Iajk6q. 이러한 용감한 영혼 중 하나인 경우 <a href="https://github.com/Azure/azure-mobile-services/tree/android">azure-mobile-services 리포지토리의 Android 분기</a>에서 전체 클라이언트 SDK를 통해 이동하면 됩니다.

  <h2><a name="Appendix"></a>부록: ToDoItem 프로젝트를 업데이트하여 게시 준비</h2>

  항목을 편집할 수 있도록 포털에서 다운로드한 기존 ToDo 목록 앱을 변경하는 데 필요한 단계는 다음과 같습니다.

  <h3>새 활동 추가</h3>

  새 화면에서 항목 편집을 처리하므로 프로젝트에 새 활동을 추가하겠습니다. Eclipse에서 프로젝트 아이콘을 마우스 오른쪽 단추로 클릭하고 "새로 만들기" –&gt; "기타"를 선택한 다음, Android 노드를 사용하고 "Android 작업" -&gt; "빈 작업"을 선택합니다.


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A001-CreateNewActivity.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A001-CreateNewActivity" alt="A001-CreateNewActivity" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A001-CreateNewActivity_thumb.png" width="480" height="367" border="0" /></a>


  새 작업 이름을 EditToDoActivity로 지정한 다음 마침을 클릭합니다.


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A002-NameNewActivity.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A002-NameNewActivity" alt="A002-NameNewActivity" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A002-NameNewActivity_thumb.png" width="480" height="412" border="0" /></a>


  이제 작업을 구성할 준비가 되었습니다. 문자열 파일(res/values/strings.xml)을 열고 지역화 경고를 방지하기 위해 변경해 보겠습니다.

  <ul>
   <li>"hello_world" 문자열 값 제거</li>
   <li>"title_activity_edit_to_do" 값을 "EditToDoActivity"에서 "ToDo 항목 편집"으로 변경합니다.</li>
   <li>다음 새 문자열을 추가합니다.
  <ul>
   <li>&lt;string name="label_item_text"&gt;Item&lt;/string&gt;</li>
   <li>&lt;string name="label_complete"&gt;Complete&lt;/string&gt;</li>
   <li>&lt;string name="button_item_edit_done"&gt;Done&lt;/string&gt;</li>
  </ul>

  </li>

  </ul>

  이제 새 활동 레이아웃을 열고 기본적으로 제공되는 텍스트 보기를 제거한 다음 편집할 항목의 텍스트가 포함된 편집 텍스트(@+id/textBoxEditItem, hint:@string/title_activity_edit_to_do) 및 항목의 전체 상태가 포함된 확인란(@+id/checkBoxItemComplete; text:@string/label_complete) 및 편집의 끝을 알리는 단추(@+id/buttonDoneEditing; text:@string/button_item_edit_done)를 추가합니다. 아래 이미지는 해당 레이아웃을 구현하는 방법을 보여줍니다. 또한 항목 텍스트(text:@string/label_item_text)에 대한 레이블이 있는 선택적 텍스트 뷰를 추가하여 좀 더 사용자에게 친숙하게 만듭니다.


  <a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/A003-NewActivityLayout.png"><img style="padding-top: 0px; padding-left: 0px; padding-right: 0px; border: 0px;" title="A003-NewActivityLayout" alt="A003-NewActivityLayout" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/A003-NewActivityLayout_thumb.png" width="219" height="360" border="0" /></a>


  이제 기존 확인란을 제거하고 대신 텍스트 보기(@+id/todoItemText)로 바꿔 테이블의 행 서식 파일(res/layout/row_list_to_do.xml)을 변경합니다. 기본 활동에서는 항목만 표시하고 항목을 클릭하면 편집할 수 있도록 새 활동으로 전환합니다.


  이제 코드에 연결합니다. EditToDoActivity.java 파일(src/com.example.your-project-name 아래)을 열고 해당 내용을 아래 코드로 바꿉니다.

  <pre class="prettyprint">public class EditToDoActivity extends Activity {

      protected static final String ITEM_TEXT_KEY = "com.example.blog20140807.item_text";
      protected static final String ITEM_COMPLETE_KEY = "com.example.blog20140807.item_complete";

      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_edit_to_do);

          Bundle extras = getIntent().getExtras();
          String itemText = extras.getString(ITEM_TEXT_KEY);
          boolean itemComplete = extras.getBoolean(ITEM_COMPLETE_KEY);

          final EditText itemTextBox = (EditText)findViewById(R.id.textBoxEditItem);
          itemTextBox.setText(itemText);
          final CheckBox completeCheckbox = (CheckBox)findViewById(R.id.checkBoxItemComplete);
          completeCheckbox.setChecked(itemComplete);

          Button btnDone = (Button)findViewById(R.id.buttonDoneEditing);
          btnDone.setOnClickListener(new View.OnClickListener() {

              @Override
              public void onClick(View v) {
                  Intent i = new Intent();
                  i.putExtra(ITEM_TEXT_KEY, itemTextBox.getText().toString());
                  i.putExtra(ITEM_COMPLETE_KEY, completeCheckbox.isChecked());
                  setResult(RESULT_OK, i);
                  finish();
              }
          });
      }
  }</pre>

  <h3></h3>

  <h3>새 작업을 사용하도록 코드 업데이트</h3>

  이제 어댑터 코드(src/com.example.your-project-name/ToDoItemAdapter.java)를 열고 getView 구현을 아래와 같이 바꿉니다.

  <pre class="prettyprint">@Override

  public View getView(int position, View convertView, ViewGroup parent) {
      View row = convertView;

      final ToDoItem currentItem = getItem(position);

      if (row == null) {
          LayoutInflater inflater = ((Activity) mContext).getLayoutInflater();
          row = inflater.inflate(mLayoutResourceId, parent, false);
      }

      row.setTag(currentItem);
      final TextView textView = (TextView) row.findViewById(R.id.todoItemText);
      textView.setText(currentItem.getText());

      return row;
  }</pre>

  기본 작업(src/com.example.your-project-name/ToDoActivity.java)으로 이동해 보겠습니다. 먼저 public <code>checkItem</code> 메서드를 제거하고 아래에 표시된 새 <code>updateItem</code> 메서드로 바꿉니다(이제 항목을 완료로 표시하는 것 이외에 변경할 수 있기 때문에).

  <pre class="prettyprint">private void updateItem(ToDoItem item) {
      if (mClient == null) {
          return;
      }

      mToDoTable.update(item, new TableOperationCallback&lt;ToDoItem&gt;() {

          public void onCompleted(ToDoItem entity, Exception exception, ServiceFilterResponse response) {
              if (exception == null) {
                  if (entity.isComplete()) {
                      mAdapter.remove(entity);
                  }

                  refreshItemsFromTable();
              } else {
                  createAndShowDialog(exception, "Error");
              }
          }

      });
  }</pre>

  이제 편집 중인 항목을 추적하는 필드와 편집 활동에 태그를 지정하는 필드를 클래스에 추가해 보겠습니다.

  <pre class="prettyprint">/**
   * The position of the item which is being edited
   */
  private int mEditedItemPosition = -1;


  private static final int EDIT_ACTIVITY_REQUEST_CODE = 1234;</pre>

  그리고 활동 점프 코드로 시작할 수 있습니다. 편집 작업으로 이동하려면 메서드의 코드를 <code>onCreate</code> 변경하여 항목을 표시하는 목록에 추가 <code>OnItemClickListener</code> 합니다. 처리기에서 새 <code>Intent</code>항목을 만들고 편집 중인 항목에 대한 정보(다른 활동에서 검색될 항목)를 추가하고 해당 작업을 시작합니다.

  <pre class="prettyprint">// Create an adapter to bind the items with the view

  mAdapter = new ToDoItemAdapter(this, R.layout.row_list_to_do);

  ListView listViewToDo = (ListView) findViewById(R.id.listViewToDo);

  final ListView listViewToDo = (ListView) findViewById(R.id.listViewToDo);

  listViewToDo.setAdapter(mAdapter);


  listViewToDo.setOnItemClickListener(new OnItemClickListener() {

      @Override
      public void onItemClick(AdapterView&lt;?&gt; parent, View view,
              int position, long id) {
          Intent i = new Intent(getApplicationContext(), EditToDoActivity.class);
          mEditedItemPosition = position;
          ToDoItem item = mAdapter.getItem(position);
          i.putExtra(EditToDoActivity.ITEM_COMPLETE_KEY, item.isComplete());
          i.putExtra(EditToDoActivity.ITEM_TEXT_KEY, item.getText());
          startActivityForResult(i, EDIT_ACTIVITY_REQUEST_CODE);
      }
  });


  // Load the items from the Mobile Service

  refreshItemsFromTable();</pre>

  마지막으로 메서드를 재정의 <code>onActivityResult</code> 하고 구현에서 새 작업에서 결과가 나온 경우 항목에 변경 내용이 있는지 확인하고, 변경 내용이 있는 경우 메서드를 호출 <code>updateItem</code> 하여 변경 내용을 유지합니다.

  <pre class="prettyprint">@Override

  protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
      if (requestCode == EDIT_ACTIVITY_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK &amp;&amp; mEditedItemPosition &gt;= 0) {
          ToDoItem item = mAdapter.getItem(mEditedItemPosition);
          String text = intent.getExtras().getString(EditToDoActivity.ITEM_TEXT_KEY);
          boolean complete = intent.getExtras().getBoolean(EditToDoActivity.ITEM_COMPLETE_KEY);

          if (!item.getText().equals(text) || item.isComplete() != complete) {
              item.setText(text);
              item.setComplete(complete);
              updateItem(item);
          }
      }
  }</pre>

  그리고 우리는 준비로 끝났습니다. 빠른 시작은 편집을 허용하도록 업데이트되었으며 이 게시물에 설명된 대로 오프라인 지원을 추가할 준비가 되었습니다.
