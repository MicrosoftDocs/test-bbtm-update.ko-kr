### YamlMime:Yaml
ms.openlocfilehash: d7f025a53fcac8c403219ff201be37af32fa184a
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139908260"
Slug: new-article-best-practices-for-performance-improvements-using-service-bus-brokered-messaging
Title: '새 문서: Service Bus 조정된 메시징을 사용하는 성능 향상을 위한 모범 사례'
Summary: 이 게시물에서는 Service Bus 조정된 메시징 기능을 사용하여 최상의 성능을 얻을 수 있는 방법을 설명합니다. MSDN의 전체 문서에서 자세한 내용을 확인할 수 있습니다.  Service Bus 클라이언트 사용...
Content: '<p>이 게시물에서는 Service Bus 조정된 메시징 기능을 사용하여 최상의 성능을 얻을 수 있는 방법을 설명합니다. MSDN의 <a target="_blank" href="https://msdn.microsoft.com/en-us/library/hh528527.aspx">전체 문서에서</a> 자세한 내용을 확인할 수 있습니다.</p>  <h2>Service Bus 클라이언트 프로토콜 사용</h2>  <p>Service Bus Service Bus 클라이언트 프로토콜 및 HTTP를 지원합니다. Service Bus 클라이언트 프로토콜은 메시지 팩터리에 있는 한 Service Bus 서비스에 대한 연결을 유지 관리하므로 더 효율적입니다. 또한 일괄 처리와 프리페치도 구현합니다. Service Bus 클라이언트 프로토콜은 .NET 관리형 API를 사용하여 .NET 애플리케이션에 사용할 수 있습니다. 가능하면 Service Bus 클라이언트 프로토콜을 통해 Service Bus 연결합니다.</p>  <h2>팩터리 및 클라이언트 다시 사용</h2>  <p><a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.queueclient.aspx">QueueClient</a> 또는 <a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagesender.aspx">MessageSender</a>와 같은 Service Bus 클라이언트 개체는 <a target="_blank" href="https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagingfactory.aspx">MessagingFactory를</a> 통해 생성되며, 이 개체는 연결의 내부 관리도 제공합니다. Service Bus 클라이언트 프로토콜을 사용하는 경우 메시지를 보낸 후 메시지 팩터리와 큐, 토픽 및 구독 클라이언트를 닫은 다음 다음 메시지를 보낼 때 다시 만들지 않도록 합니다. 대신 팩터리와 클라이언트를 여러 작업에 사용합니다. 메시징 팩터리를 닫으면 Service Bus 대한 연결이 삭제됩니다. 연결 설정은 비용이 많이 드는 작업입니다.</p>  <h2>동시 작업 사용</h2>  <p>작업(보내기, 받기, 삭제 등)을 수행하는 데는 일정 시간이 걸립니다. 이번에는 Service Bus 서비스의 작업 처리와 요청 대기 시간 및 회신이 포함됩니다. 시간당 작업 수를 늘리려면 작업을 동시에 실행해야 합니다. 클라이언트와 Service Bus 네임스페이스를 호스트하는 데이터 센터 간의 데이터 교환 대기 시간이 큰 경우 특히 그렇습니다.</p>  <p>여러 작업을 동시에 실행하는 작업은 여러 가지 방법으로 수행할 수 있습니다.</p>  <p>비동기 작업. 비동기 작업을 수행하여 클라이언트 파이프라인 작업을 수행합니다. 다음 요청은 이전 요청이 완료되기 전에 시작됩니다.</p>  <p>여러 공장. 동일한 팩터리에서 만든 모든 클라이언트(보낸 사람 및 수신자)는 하나의 TCP 연결을 공유합니다. 최대 메시지 처리량은 이 TCO 연결을 통과할 수 있는 작업의 수로 제한됩니다. 단일 팩터리로 얻을 수 있는 처리량은 TCP 왕복 시간과 메시지 크기에 따라 크게 달라집니다.</p>  <h2>클라이언트 쪽 일괄 처리 사용</h2>  <p>클라이언트 쪽 일괄 처리를 사용하면 큐/토픽 클라이언트가 여러 송신 작업을 단일 요청으로 일괄 처리할 수 있습니다. 또한 큐/구독 클라이언트가 여러 완료 요청을 단일 요청으로 일괄 처리할 수 있습니다. 기본적으로 클라이언트는 20ms의 배치 간격을 사용합니다. 메시징 팩터리를 만들기 전에 MessagingFactorySettings.NetMessagingTransportSettings.BatchFlushInterval을 설정하여 일괄 처리 간격을 변경할 수 있습니다. 이 설정은이 이 팩터리에서 만든 모든 클라이언트에 영향을 줍니다.</p>  <p><span style="background-color: #ffffff; color: #33cccc;">MessagingFactorySettings</span> mfs = <span style="color: #3366ff;">new</span> <span style="color: #33cccc;">MessagingFactorySettings</span>();</p>  <p>Mfs. TokenProvider = tokenProvider;</p>  <p>Mfs. NetMessagingTransportSettings.BatchFlushInterval = <span style="color: #33cccc;">TimeSpan.FromSeconds</span>(0.05);</p>  <p><span style="color: #33cccc;">MessagingFactory</span> messagingFactory = <span style="color: #33cccc;">MessagingFactory</span>. Create(namespaceUri, mfs);</p>  <p>처리량이 낮고 대기 시간이 짧은 시나리오의 경우 일괄 처리를 사용하지 않도록 설정하려고 합니다. 이렇게 하려면 일괄 처리 플러시 간격을 0으로 설정합니다. 처리량이 높은 시나리오의 경우 일괄 처리 간격을 50ms로 늘림 여러 발신기를 사용할 경우 일괄 처리 간격을 100ms로 높입니다.</p>  <p>일괄 처리는 비동기 Send 및 Complete 작업에만 사용할 수 있습니다. 동기 작업은 Service Bus 서비스에 즉시 보내집니다. 피킹 또는 수신 작업에는 일괄 처리가 발생하지 않으며 클라이언트 간에 일괄 처리가 발생하지 않습니다.</p>  <h2>일괄 처리된 저장소 액세스 사용</h2>  <p>큐/토픽/구독의 처리량을 늘리기 위해 Service Bus 서비스는 내부 저장소에 쓸 때 여러 메시지를 일괄 처리합니다. 큐 또는 토픽에 설정된 경우 저장소에 메시지를 쓰는 작업이 일괄 처리됩니다. 큐 또는 구독에 설정된 경우 저장소에서 메시지를 삭제하는 작업이 일괄 처리됩니다. 일괄 처리 방식 저장소 액세스는 Send 및 Complete 작업에만 적용되며 수신 작업에는 적용되지 않습니다.</p>  <p>새 큐, 토픽 또는 구독을 만들 때 일괄 처리 간격이 20ms인 일괄 처리된 저장소 액세스를 사용하도록 설정합니다. 처리량이 낮고 대기 시간이 짧은 시나리오의 경우 <span style="color: #33cccc;">QueueDescription</span>을 설정하여 일괄 처리된 저장소 액세스를 사용하지 않도록 설정하려고 합니다. 엔터티를 만들기 전에 EnableBatchedOperations를 <span style="color: #3366ff;">false</span> 로 설정합니다.</p>  <p><span style="color: #33cccc;">QueueDescription</span> qd = <span style="color: #3366ff;">new</span> QueueDescription();</p>  <p>Qd. EnableBatchedOperations = <span style="color: #3366ff;">false</span>;</p>  <p><span style="color: #33cccc;">Queue</span> q = namespaceManager.CreateQueue(qd);</p>  <h2>프리페치 사용</h2>  <p>프리페치하면 큐/구독 클라이언트가 수신 작업을 수행할 때 서비스에서 추가 메시지를 로드합니다. 클라이언트는 이러한 메시지를 로컬 캐시에 저장합니다. <span style="color: #33cccc;">QueueClient</span>입니다. PrefetchCount 및 <span style="color: #33cccc;">SubscriptionClient</span>. PrefetchCount 값은 프리페치할 수 있는 메시지 수를 지정합니다. 프리페치를 사용할 수 있는 각 클라이언트는 각각의 캐시를 유지합니다. 캐시는 클라이언트 사이에서 공유되지 않습니다.</p>  <p>Service Bus 프리페치된 메시지를 잠그므로 다른 수신자가 프리페치된 메시지를 받을 수 없습니다. 잠금이 만료되기 전에 수신자가 메시지를 완료하지 못하면 다른 수신자가 메시지를 사용할 수 있게 됩니다. 프리페치된 메시지의 복사본은 캐시에 남아 있습니다. 수신자는 만료된 캐시된 메시지 복사본을 완료하려고 할 때 예외를 받습니다.</p>  <p>만료된 메시지의 사용을 방지하려면 캐시 크기가 잠금 시간 제한 간격 내에서 클라이언트에서 사용할 수 있는 메시지 수보다 작아야 합니다. 기본 잠금 만료 시간으로 60초를 사용하는 경우 적절한 SubscriptionClient.PrefetchCount 값은 모든 팩터리 수신자의 최대 처리 속도x20입니다. 예를 들어 팩터리에서 3개의 수신기를 만들고 각 수신기가 초당 최대 10개의 메시지를 처리할 수 있는 경우 프리페치 수는 *20310* = 600을 초과하지 않아야 합니다.</p>  <p>기본적으로 QueueClient.PrefetchCount는 서비스에서 추가 메시지를 페치하지 않음을 의미하는 0으로 설정되어 있습니다. 수신자가 높은 속도로 메시지를 사용하는 경우 프리페치를 사용하도록 설정합니다. 대기 시간이 짧은 시나리오에서는 단일 클라이언트가 큐 또는 구독의 메시지를 사용하는 경우 프리페치를 사용하도록 설정합니다. 여러 클라이언트를 사용하는 경우 프리페치 수를 0으로 설정합니다. 이렇게 하면 첫 번째 클라이언트가 여전히 첫 번째 메시지를 처리하는 동안 두 번째 클라이언트가 두 번째 메시지를 받을 수 있습니다.</p>  <p>MSDN에 대한 <a target="_blank" href="https://msdn.microsoft.com/en-us/library/hh528527.aspx">전체 문서를</a> 읽어보세요.</p>'
