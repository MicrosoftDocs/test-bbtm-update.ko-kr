### YamlMime:Yaml
ms.openlocfilehash: 87a5328600c0ba1f848d53fcfcdb305fe7347f05
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907829"
Slug: disabling-arrs-instance-affinity-in-windows-azure-web-sites
Title: Windows Azure 웹 사이트에서 ARR의 인스턴스 선호도 비활성화
Summary: Windows Azure Websites에서 웹 사이트의 여러 인스턴스를 설정하는 것은 웹 사이트를 스케일 아웃하는 훌륭한 방법이며, Azure는 애플리케이션 요청 라우팅 IIS 확장을 매우 활용합니다.
Content: >-
  Windows Azure Websites에서 웹 사이트의 여러 인스턴스를 설정하는 것은 웹 사이트를 확장하는 훌륭한 방법이며, Azure는 <a href="https://www.iis.net/learn/extensions/planning-for-arr" target="_blank">애플리케이션 요청 라우팅</a> IIS 확장을 사용하여 활성 인스턴스 간에 연결 사용자를 배포합니다. ARR은 후속 요청 시 통신하는 서버 인스턴스를 알 수 있는 특별한 쿠키( <strong>선호도 쿠키</strong>라고 함)를 제공하여 사용자를 연결하도록 영리하게 추적합니다. 이렇게 하면 클라이언트가 특정 서버 인스턴스와 세션을 설정하면 세션이 활성 상태인 한 동일한 서버와 계속 통신하게 됩니다. 이는 세션에 민감한 애플리케이션(즉, 상태 비정상 애플리케이션) - 세션별 데이터가 서버에서 다른 서버로 자체적으로 이동되지 않기 때문입니다. 애플리케이션은 이 작업을 수행하도록 설계할 수 있지만(일반적으로 해당 데이터를 SQL 같은 공유 스토리지에 저장) 대부분의 경우 지정된 서버에 연결된 모든 사용자를 유지하려고 합니다. 사용자가 다른 서버로 이동하면 새 세션이 시작되고 애플리케이션에서 사용하던 세션 데이터가 사라집니다(예: 쇼핑 카트의 콘텐츠). 이 프로세스에 대한 간략한 설명은 다음과 같습니다.

  <ol>
   <li>클라이언트가 Azure 웹 사이트 웹 사이트에 연결</li>
   <li>ARR은 프런트 엔드 Azure 서버에서 실행되고 요청을 받습니다.</li>
   <li>ARR은 요청이 이동해야 하는 사용 가능한 인스턴스 중 어느 것을 결정합니다.</li>
   <li>ARR은 선택한 서버에 요청을 전달하고 <strong>ARRAffinity</strong> 쿠키를 만들어 요청에 연결합니다.</li>
   <li>응답은 <strong>ARRAffinity</strong> 쿠키를 들고 클라이언트로 돌아갑니다.</li>
   <li>클라이언트가 요청을 받으면 나중에 사용할 쿠키를 저장합니다(브라우저는 서버에서 수신하는 쿠키에 대해 이 작업을 수행하도록 설계됨).</li>
   <li>클라이언트가 후속 요청을 제출하면 쿠키가 포함됩니다.</li>
   <li>ARR이 요청을 받으면 쿠키가 표시되고 디코딩됩니다.</li>
   <li>디코딩된 쿠키는 이전에 사용된 인스턴스의 이름을 보유하므로 ARR은 풀에서 요청을 선택하지 않고 동일한 인스턴스로 전달합니다.</li>
   <li>동일한 항목(7-9단계)은 사용자가 브라우저를 닫을 때까지 동일한 사이트에 대한 모든 후속 요청에 대해 반복되며, 이때 쿠키가 지워집니다.</li>
  </ol>

  <div><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/02/8407.blogpicture.png-550x0.png"><img class="alignnone size-medium wp-image-133941" alt="8407.blogpicture.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/8407.blogpicture.png-550x0-400x369.png" width="400" height="369" /></a></div>

  <div>


  그러나 선호도를 유지하는 것이 바람직하지 않은 경우가 있습니다. 예를 들어 일부 사용자는 브라우저를 닫지 않고 오랜 시간 동안 연결 상태를 유지합니다. 이 경우 선호도 쿠키는 브라우저에 유지되며 사용자가 몇 시간, 며칠 이상 지속될 수 있는 기간 동안 서버에 연결됩니다(이론적으로는 무기한). 컴퓨터를 켜고 브라우저를 열어 두는 것은 드문 일이 아니며, 많은 사람들(특히 회사 컴퓨터)이 항상 그렇게 합니다. 현실 세계에서, 이것은 균형이 떨어지는 인스턴스 당 사용자의 분포로 이어집니다 (슈퍼마켓의 일부 레지스터 뒤에있는 라인이 단일 고객에 의해 호깅 될 수있는 방법과 약간 유사하며, 다른 사람들은 평소보다 더 많은 줄을 서서 기다리고 있습니다).


  애플리케이션 및 애플리케이션에 따라 서버에 연결된 사용자에 대해 다소 신경을 쓸 수 있습니다. 이것이 거의 또는 전혀 중요하지 않고 이 선호도를 사용하지 않도록 설정하고 더 나은 부하 분산을 선택하는 경우 이를 제어할 수 있는 기능을 도입했습니다.


  선호도는 선호도 쿠키에 의해 제어되므로 선호도를 사용하지 않도록 설정하기 위해 Azure에서 쿠키를 제공하지 않도록 하기만 하면 됩니다. 그렇지 않은 경우 사용자의 후속 요청은 "new"로 처리되고 " 해당" 서버로 라우팅하는 대신 ARR은 일반적인 부하 분산 동작을 사용하여 요청을 최상의 서버로 라우팅합니다.


  선호도 쿠키의 모양은 다음과 같습니다.


  </div>

  <div><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5773.bp2_.png-550x0.png"><img class="alignnone size-full wp-image-133931" alt="5773.bp2.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5773.bp2_.png-550x0.png" width="550" height="143" /></a></div>

  <div>


  선호도를 사용하지 않도록 설정하는 작업은 다음 두 가지 방법으로 수행할 수 있습니다.

  <ol>
   <li>애플리케이션에서</li>
   <li>사이트 구성에서</li>
  </ol>

  애플리케이션에서 이 동작을 제어하려면 애플리케이션 요청 라우터에 선호도 쿠키를 제거하도록 지시하는 특수 HTTP 헤더를 보내는 코드를 작성해야 합니다. 이 헤더는 <strong>Arr-Disable-Session-Affinity</strong>이며 true로 설정하면 ARR에서 쿠키를 제거합니다. 예를 들어 애플리케이션 코드와 비슷한 줄을 추가할 수 있습니다.

  <table border="1" cellspacing="0" cellpadding="0">

  <tbody>

  <tr>

  <td valign="top" width="623">헤더. Add("Arr-Disable-Session-Affinity", "True");</td>

  </tr>

  </tbody>

  </table>

  </div>

  <div>


  * 이 예제는 C#을 위한 것이지만 다른 언어나 플랫폼에서 쉽게 수행할 수 있습니다.


  애플리케이션 코드에서 이를 설정하는 것은 선호도를 대부분 유지하고 특정 애플리케이션 페이지에서만 다시 설정하려는 상황에 적합합니다. 그러나 완전히 사용하지 않도록 설정하려는 경우 IIS 자체가 해당 헤더를 직접 삽입하도록 하여 ARR이 항상 쿠키를 제거하도록 할 수 있습니다. 이 작업은 <strong>web.config</strong><strong>customHeaders</strong> 구성 섹션을 사용하여 수행됩니다. web.config 다음을 추가하고 사이트의 루트에 업로드하기만 하면 됩니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6765.bp3_.JPG-550x0.jpg"><img class="alignnone size-full wp-image-133921" alt="6765.bp3.JPG-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/6765.bp3_.JPG-550x0.jpg" width="550" height="166" /></a>


  하지만 <strong>web.config</strong> 구성은 중요하며 형식이 잘못된 파일은 사이트가 제대로 작동하지 않도록 할 수 있습니다. 이전에 <strong>web.config</strong> 파일로 작업할 기회가 없었던 경우 <a href="https://www.iis.net/learn/get-started/planning-your-iis-architecture/the-configuration-system-in-iis-7" target="_blank">이 시작 가이드를 읽어</a>보세요.


  <strong><span style="text-decoration: underline;">문제 해결</span></strong>


  이를 구현하려는 경우 작동을 확인하고 문제를 해결하는 방법을 궁금해할 수 있습니다. ARR 선호도 쿠키는 일반적으로 모든 Azure 웹 사이트 웹 사이트의 <sup>첫 번째</sup> 응답에 포함되며, 이후에는 클라이언트에서 보낸 모든 요청과 서버에서 받은 응답에 포함됩니다. 작동 중인 항목을 확인하려면 여러 HTTP 문제 해결 및 진단 도구를 사용할 수 있습니다. 다음은 가장 인기 있는 옵션의 목록입니다.

  <ol>
   <li>Fiddler</li>
   <li>HTTPWatc</li>
   <li>네트워크 모니터</li>
   <li>WireShark</li>
   <li>방화 범</li>
  </ol>

  다른 여러 도구에 대한 정보는 여기에서 확인할 수 <a href="https://oreilly.com/server-administration/excerpts/9780596522315/performance-tools.html" target="_blank">있습니다</a>. 목록의 <sup>첫 번째</sup> 인 Fiddler는 모든 브라우저와 상호 작용할 수 있으며 무료로 사용할 수 있기 때문에 가장 인기있는 중 하나입니다. Fiddler가 설치되면 찾아보는 모든 URL을 기록합니다. 그런 다음 검사기 탭을 클릭하여 요청 또는 응답을 클릭하여 세부 정보를 볼 수 있습니다. 예를 들어 아래에서는 서버에서 Set-Cookie 헤더를 사용하여 보낸 선호도 쿠키를 표시하는 HTTP 헤더 탭을 볼 수 있습니다.


  <a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5140.bp4_.png-550x0.png"><img class="alignnone size-full wp-image-133911" alt="5140.bp4.png-550x0" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5140.bp4_.png-550x0.png" width="550" height="225" /></a>


  <strong>Arr-Disable-Session-Affinity</strong> 헤더를 추가하여 선호도 쿠키를 사용하지 않도록 설정하는 경우 ARR은 쿠키를 설정하지 않지만 <strong>Arr-Disable-Session-Affinity</strong> 헤더 자체도 제거하므로 프로세스가 올바르게 작동하는 경우 둘 다 표시되지 않습니다. 쿠키와 헤더가 모두 표시되면 헤더를 설정하는 방식에 문제가 있음을 의미합니다. 헤더 이름 또는 해당 값의 텍스트에 오류가 발생할 수 있습니다. 헤더가 아닌 쿠키가 표시되는 경우 이는 Web.config 대한 변경 내용이 잘못되었거나 헤더 삽입 코드가 작동하지 않음을 의미하며 관련 없는 다른 헤더를 추가하여 확인하려고 시도할 수 있습니다. 일반적으로 코드보다 web.config 헤더를 설정하는 것이 더 쉽기 때문에 의심의 여지가 있는 경우 조사 노출 영역을 줄이기 위해 헤더를 단순화하여 시작해야 합니다.


  닫을 때 선호도를 사용하지 않도록 설정하는 것은 가볍게 고려해야 할 것이 아니라는 점을 언급해야 합니다. 정적 콘텐츠의 경우 거의 문제가 되지 않지만 애플리케이션을 실행 중이고 한 서버에서 다른 서버로 이동하는 사용자를 처리하도록 설계되지 않은 경우 잘 끝나지 않을 수 있습니다. 선호도가 불균형으로 이어진 시나리오의 경우 이 새로운 기능이 좋은 소식으로 다가올 것입니다.


  </div>
