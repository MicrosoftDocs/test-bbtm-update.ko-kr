### YamlMime:Yaml
ms.openlocfilehash: 4a3fdefdf71cad3c401933e0e7bf7ecc1243cf60
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139900895"
Slug: scaling-a-multi-tenant-application-with-azure-documentdb-2
Title: Azure DocumentDB를 사용하여 다중 테넌트 애플리케이션 크기 조정
Summary: Azure DocumentDB를 사용하여 다중 테넌트 애플리케이션을 디자인하려면 어떻게 해야 하나요? 문서 컬렉션이란 무엇이며 대규모 다중 테넌트 SaaS 애플리케이션을 빌드할 때 어떻게 사용하나요? 이 게시물은 이러한 일반적인 질문에 대답하기 시작합니다.
Content: >-
  <h5>테넌트 배치 및 부하 분산에 대한 모범 사례</h5>


  <h2>소개</h2>


  <p align="justify">자주 묻는 질문은 &ldquo;<a href="https://azure.microsoft.com/en-us/services/documentdb/">Azure DocumentDB</a>를 기반으로 다중 테넌트 애플리케이션을 디자인하는 방법입니다.&rdquo; 이 질문에 대한 많은 답변이 있으며 가장 좋은 대답은 애플리케이션&rsquo; 특정 시나리오에 따라 달라집니다.</p>


  <p align="justify">높은 수준에서 테넌트 규모에 따라 데이터베이스 또는 컬렉션별로 분할하도록 선택할 수 있습니다. 테넌트 데이터가 더 작고 테넌트 번호가 더 높은 &ndash; 경우 애플리케이션에 필요한 전체 리소스를 줄이기 위해 동일한 컬렉션에 여러 테넌트에 대한 데이터를 저장하는 것이 좋습니다. 문서의 속성으로 테넌트 식별 및 필터 쿼리를 실행하여 테넌트별 데이터를 검색할 수 있습니다. DocumentDB&rsquo; 사용자 <a href="https://msdn.microsoft.com/en-us/library/dn783368.aspx">및 권한을</a> 사용하여 테넌트 데이터를 격리하고 권한 부여 키를 통해 리소스 수준에서 액세스를 제한할 수도 있습니다.</p>


  <p align="justify">테넌트가 더 크거나 전용 리소스가 필요하거나 추가 격리가 필요한 경우 테넌트에 전용 컬렉션 또는 데이터베이스를 할당할 수 있습니다. 두 경우 모두 DocumentDB는 애플리케이션&rsquo; 데이터 저장소를 확장할 때 운영 부담의 상당 부분을 처리합니다.</p>


  <p align="justify">이 문서에서는 애플리케이션&rsquo; 요구 사항에 맞게 멋진 디자인으로 안내하는 데 도움이 되는 개념과 전략에 대해 설명합니다.</p>


  <h2>컬렉션이란?</h2>


  <p align="justify">데이터 분할에 대해 자세히 알아보기 전에 컬렉션의 내용과 컬렉션이 무엇인지&rsquo; 이해하는 것이 중요합니다.</p>


  <p align="justify">이미 알고 있듯이 컬렉션은 JSON 문서의 컨테이너입니다. 컬렉션은 쿼리 및 트랜잭션을 실행하기 위한 파티션 및 경계의 DocumentDBs&rsquo; 단위이기도 합니다. 각 컬렉션은 예약된 양의 처리량을 제공합니다. 스토리지 및 처리량 측면에서 더 많은 컬렉션을 추가하고 문서를 배포하여 애플리케이션을 확장할 수 있습니다.</p>


  <p align="justify">컬렉션이 테이블이 <em>아니라</em> 는 것을 이해하는 것이 절대적으로 중요합니다. 컬렉션은 스키마를 적용 <em>하지</em> 않습니다. 즉, 동일한 컬렉션에 서로 다른 스키마가 있는 다양한 유형의 문서를 저장할 수 있습니다. 문서에 형식&rdquo; 특성을 추가하여 다양한 유형의 엔터티를 &ldquo;추적할 수 있습니다.</p>


  <p align="justify">다른 문서 데이터베이스와 달리 더 큰 규모와 성능을 달성하기 위해 많은 컬렉션을 보유하는 것은 아무 문제가 없습니다. 그러나 비용 절감 관점에서 컬렉션을 다시 사용하려고 할 수 있습니다.</p>


  <h2>DocumentDB를 사용하여 분할</h2>


  <p align="justify">데이터를 &ndash; 분할이라고 하는 개념을 수평적으로 분할하여 DocumentDB 애플리케이션에 대해 거의 무한 규모(스토리지 및 처리량)를 달성할 수 있습니다.</p>


  <p align="justify">분할은 대규모 웹 애플리케이션의 높은 확장성을 달성하기 위한 표준 애플리케이션 패턴입니다. 트랜잭션의 이점이 필요한 애플리케이션의 경우 애플리케이션은 각 파티션이 트랜잭션 도메인(즉, 컬렉션)에 맞게 충분히 작은 키에 따라 데이터를 신중하게 분할해야 합니다. 분할된 애플리케이션은 데이터가 여러 파티션 또는 트랜잭션 도메인에 분산되어 있고 파티션을 선택하고 분할 키에 따라 상호 작용하는 논리가 필요하다는 것을 알고 있어야 합니다.</p>


  <p><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/shard-example.png"><img alt="shard-example" border="0" height="478" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/shard-example_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none;" title="shard-example" width="480"></a></p>


  <p align="center"><i>데이터베이스 및 컬렉션에 분할된 DocumentDB 애플리케이션입니다.</i></p>


  <h2>분할 범위</h2>


  <p align="justify">분할은 일반적으로 애플리케이션의 추가 데이터 관리 논리를 포함하기 때문에 여러 트랜잭션 도메인에서 분할할지 여부를 결정하는 것은 애플리케이션 &ndash; 의 규모에 따라 달라집니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/resourcemodel.png"><img alt="resourcemodel" border="0" height="382" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/resourcemodel_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="resourcemodel" width="480"></a></p>


  <p align="center"><i>데이터베이스 계정의 계층적 리소스 모델</i></p>


  <p align="justify">&rsquo;DocumentDBs&rsquo; 리소스 모델 및 데이터를 분할할 수 있는 다양한 범위를 자세히 살펴보겠습니다.</p>


  <p align="justify">모든 테넌트를 단일 컬렉션에 배치 - 일반적으로 모든 테넌트의 총 리소스 사용량이 단일 컬렉션의 스토리지 및 처리량 제한 내에 있을 때마다 대부분의 애플리케이션 &ndash; 에 좋은 시작점입니다.</p>


  <p align="justify">문서 내에 테넌트 속성을 추가하고 모든 쿼리에 테넌트 필터를 적용하여 애플리케이션 수준에서 보안을 적용할 수 있습니다(예: SELECT * FROM 컬렉션 c WHERE c.userId = &ldquo;Andrew&rdquo;). 각 테넌트에 대한 사용자를 만들고, 테넌트 데이터에 권한을 할당하고, 사용자 권한 부여 키를 통해&rsquo; 테넌트 데이터를 쿼리하여 DocumentDB 수준에서도 보안을 적용할 수 있습니다.</p>


  <p align="justify">단일 컬렉션 내에 테넌트 데이터를 저장하는 주요 이점은 복잡성을 줄이고, 애플리케이션 데이터에서 트랜잭션 지원을 보장하며, 스토리지의 재무 비용을 최소화하는 것입니다.</p>


  <p align="justify">테넌트를 여러 컬렉션에 배치합니다. 애플리케이션에 단일 컬렉션 &ndash; 이 처리할 수 있는 것보다 더 많은 스토리지 또는 처리량 용량이 필요한 경우 여러 컬렉션에서 데이터를 분할할 수 있습니다. 다행히 데이터베이스 크기와 컬렉션 수에 제한을 설정할 필요가 없습니다. DocumentDB를 사용하면 애플리케이션이 증가함에 따라 컬렉션 및 용량을 동적으로 추가할 수 있습니다. 그러나 애플리케이션이 테넌트 데이터를 분할하고 요청을 라우팅하는&rsquo; 방법을 결정해야 합니다. 여기서는 잠시 후에 논의합니다.</p>


  <p align="justify">리소스 용량 증가 외에도, 여러 컬렉션에서 데이터를 분할하는 이점은 덜 조밀한 컬렉션에 배치하여 소규모 테넌트보다 더 큰 테넌트에 더 많은 리소스를 할당할 수 있다는 점입니다(예: 전용 처리량이 필요한 테넌트를 자체 컬렉션에 배치할 수 있음).</p>


  <p align="justify">여러 데이터베이스 &ndash; 에 테넌트를 배치하는 대부분의 경우 데이터베이스에 테넌트를 배치하는 것은 컬렉션에 테넌트를 배치하는 것과 매우 유사합니다. 위의 리소스 모델 다이어그램에 표시된 것처럼 DocumentDB 컬렉션과 데이터베이스 간의 주요 차이점은 사용자와 사용 권한의 범위가 데이터베이스 수준에서 지정된다는 것입니다. 즉, 각 데이터베이스에는 특정 컬렉션 및 문서를 격리하는 데 사용할 수 있는 고유한 사용자 및 권한 &ndash; 집합이 있습니다.</p>


  <p align="justify">데이터베이스별로 테넌트를 분할하면 테넌트에 매우 큰 사용자 및 권한 집합이 필요한 시나리오에서 사용자 및 권한 관리를 간소화할 수 있습니다. 테넌트가 데이터베이스에 의해 분할되고 테넌트가 애플리케이션 &ndash; 을 떠나는 경우 테넌트&rsquo; 데이터는 사용자 및 권한과 함께 데이터베이스를 삭제하기만 하면 모두 함께 삭제될 수 있습니다.</p>


  <p align="justify">마찬가지로 여러 데이터베이스 계정에 테넌트 배치는 데이터베이스 계정에 &ndash; 테넌트 배치는 데이터베이스 전체에 테넌트 배치와 매우 유사합니다. 데이터베이스 계정과 데이터베이스 간의 주요 차이점은 마스터/보조 키, DNS 엔드포인트 및 청구 범위가 데이터베이스 계정 수준에서 지정된다는 것입니다.</p>


  <p align="justify">데이터베이스 계정으로 테넌트 분할을 사용하면 테넌트가 자체 데이터베이스 계정 키에 액세스해야 하는 시나리오에서 테넌트 간의 격리를 유지할 수 있습니다(예: 테넌트에는 고유한 컬렉션 및 사용자 집합을 만들고 삭제하고 관리하는 기능이 필요함).</p>


  <h2>일반적인 분할 패턴</h2>


  <p align="justify">여러 트랜잭션 도메인에서 데이터를 분할하는 경우&rsquo; 애플리케이션은 데이터를 분할하고 요청을 올바른 파티션으로 라우팅하기 위해 일종의 추론이 필요합니다. 데이터 분할에 대한 몇 가지 일반적인 추론은 다음과 같습니다.</p>


  <h3>범위 분할</h3>


  <p align="justify">파티션은 분할 키가 특정 범위 내에 있는지 여부에 따라 할당됩니다. 예를 들어 타임스탬프 또는 지리별로 데이터를 분할할 수 있습니다(예: 우편 번호는 30000에서 39999 사이).</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/partition-range.png"><img alt="partition-range" border="0" height="117" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/partition-range_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="partition-range" width="500"></a></p>


  <p align="center"><i>월별 범위 분할</i></p>


  <h3>조회 분할</h3>


  <p>파티션은 파티션에 매핑되는 불연속 값의 조회 디렉터리에 따라 할당됩니다. 일반적으로 어떤 데이터가 어떤 파티션에 저장되어 있는지 추적하는 조회 맵을 만들어 구현됩니다. 조회 결과를 캐시하여 여러 왕복을 방지할 수 있습니다. 예를 들어 사용자별 데이터를 분할할 수 있습니다(예: 파티션 G에는 Harry, Ron 및 Hermione이 포함되고 파티션 S에는 드라코, 빈센트 및 그레고리가 포함됨) 또는 국가(예: 파티션 스칸디나비아에는 노르웨이, 덴마크 및 스웨덴이 포함됨)가 있습니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/partition-dictionary.png"><img alt="partition-dictionary" border="0" height="199" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/partition-dictionary_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="partition-dictionary" width="524"></a></p>


  <p align="center"><i>조회 분할</i></p>


  <h4>해시 분할</h4>


  <p>파티션은 해시 함수 &ndash; 의 값을 기반으로 하여 n개의 파티션에 균등하게 분산할 수 있습니다. 예를 들어 테넌트 %3의 해시 코드로 데이터를 분할하여 3개의 파티션에 테넌트를 균등하게 분산하는 것이 있습니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/partition-hash.png"><img alt="partition-hash" border="0" height="146" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/partition-hash_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="partition-hash" width="500"></a></p>


  <p align="center"><i>해시 분할</i></p>


  <p align="justify">그렇다면 어떤 분할 전략이 적합한가요? 범위 분할은 일반적으로 날짜 컨텍스트에서 유용합니다. 파티션의 노후화에 대한 쉽고 자연스러운 메커니즘을 제공하기 때문입니다. 반면 조회 분할을 사용하면 순서가 지정되지 않고 관련이 없는 데이터 집합을 자연스럽게 그룹화하고 구성할 수 있습니다(예: 조직 또는 지역별 주별 테넌트 그룹화). 해시 분할은 특정 그룹의 데이터 양을 예측하고 수동으로 분산하기 어렵거나 범위 분할로 인해 데이터가 바람직하지 않은 클러스터링될 때 부하 분산에 매우 유용합니다.</p>


  <p align="justify">&rsquo;하나의 분할 전략만 선택할 필요가 없습니다. 이러한 전략의 복합은 시나리오 &ndash; 에 따라 유용할 수 있습니다. 예를 들어 복합 범위 조회 분할은 범위 분할의 관리 효율성과 조회 분할의 명시적 제어를 모두 제공할 수 있습니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/partition-composite.png"><img alt="partition-composite" border="0" height="148" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/partition-composite_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="partition-composite" width="500"></a></p>


  <p align="center"><i>복합 Range-Lookup 분할</i></p>


  <h3>Fan-Out 작업</h3>


  <p>여러 트랜잭션 도메인의 데이터에서 작동하는 일반적인 방법은 애플리케이션이 각 파티션을 병렬로 쿼리한 다음 결과를 통합하는 팬아웃 쿼리를 실행하는 것입니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/fanout.png"><img alt="fanout" border="0" height="283" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/fanout_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="팬아웃" width="500"></a></p>


  <p align="center"><i>팬아웃 쿼리</i></p>


  <p align="justify">기본 아키텍처 결정은 팬아웃이 발생하는 경우입니다. 뉴스 피드 집계 타임라인을 예로 들 수&rsquo; 있습니다. 팬아웃을 위한 몇 가지 일반적인 전략은 다음과 같습니다.</p>


  <p align="justify">쓰기<em> &ndash; </em>에 대한 Fan-Out 여기서는 읽기에 대한 계산을 피하고 대부분의 쓰기 처리를 수행하여 읽기 시간 액세스를 매우 빠르고 쉽게 만드는 것입니다. 타임라인이 Twitter &ndash; 와 유사한 경우 원본 피드 집합의 사용자별 집계를 거의 영구적이고 추가 전용인 경우 좋은 결정일 수 있습니다. 들어오는 이벤트가 기록되면 원본 피드에 저장되고 각 타임라인에 대해 복사본이 포함된 레코드가 만들어집니다.</p>


  <p align="justify">읽기 &ndash; 에 대한 Fan-Out 타임라인이 피드가 일시적이고 동적 기능(예: 실시간 개인 정보 보호 검사 및 콘텐츠 조정)을 지원해야 하는 Facebook &ndash; 과 유사한 경우 좋은 결정일 수 있습니다. 이벤트가 기록되면 원본 피드에만 저장됩니다. 사용자가 개별 타임라인을 요청할 때마다 시스템 팬아웃은 사용자에게 가시성이 있는 모든 원본 피드를 읽고 피드를 함께 집계합니다.</p>


  <h2>Storage 및 처리량 관리</h2>


  <p align="justify">파티션이 채워지고 리소스가 부족해지면 데이터를 다른 파티션으로 분산하거나 다시 배포해야 합니다. 이는 외부 테넌트가 예상보다 많은 스토리지 및/또는 처리량을 사용하거나 애플리케이션이 단순히 기존 파티션을 능가하는 경우에 발생할 수 있습니다. 애플리케이션 실패 가능성을 방지하기 위해 리소스를 사용하는 속도에 따라 적절한 임계값(예: 사용된 스토리지의 80%)을 모니터링하고 선택하려고 합니다.</p>


  <p align="center"><a href="https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/26/spillover.png"><img alt="spillover" border="0" height="135" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/spillover_thumb.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px;" title="스필오버(spillover)" width="300"></a></p>


  <p align="center"><i>서비스 중단을 방지하기 위해 데이터를 분산/다시 배포하기 전에 충분한 헤드룸을 유지 관리합니다.</i></p>


  <p align="justify">스토리지 제약 조건을 극복하는 한 가지 전략은 들어오는 데이터를 새 컬렉션으로 유출하는 것입니다. 예를 들어 컬렉션이 매우 임시적인 데이터를 저장하고 월 또는 날짜별로 분할되는 경우 스필오버가 잘 작동할 수 있습니다. 이러한 맥락에서 오래된 컬렉션은 나이가 들고 부실해짐에 따라 정리하거나 보관하는 것을 고려할 수도 있습니다. &rsquo;컬렉션이 트랜잭션 및 쿼리의 경계임을 명심해야 합니다. 컬렉션 간에 데이터를 처리하는 경우 읽기 또는 쓰기를 팬아웃해야 할 수 있습니다.</p>


  <p align="justify">스토리지 및/또는 처리량 제약 조건을 극복하기 위한 또 다른 전략은 테넌트 데이터를 다시 배포하는 것입니다. 예를 들어 다른 컬렉션보다 훨씬 더 많은 처리량을 사용하는 외부 테넌트를 이동할 수 있습니다. 특정 테넌트에 대한 서비스 중단을 방지하기 위해 마이그레이션 프로세스 중에 읽기 및/또는 쓰기를 팬아웃할 수 있습니다.</p>


  <h2>결론</h2>


  <p align="justify">DocumentDB는 분할된 데이터베이스 계정에 Health &amp; Fitness 환경(웹 및 모바일)에 대한 사용자 데이터를 저장하는 MSN을 포함하여 Microsoft 내에서 다양한 다중 테넌트 시나리오에 맞게 크기를 조정하는 것으로 입증되었습니다. 이 사용 사례에 대한 <a href="https://azure.microsoft.com/blog/2014/10/09/azure-documentdb-profile-of-msn-health-and-fitness-2/">블로그 게시물을</a> 확인하세요!</p>


  <p align="justify">대부분의 경우 애플리케이션에 대한 디자인은 해당 시나리오 및 데이터 액세스 패턴에 크게 좌우됩니다. 이 문서가 올바른 방향으로 안내하는 좋은 출발점이 되기를 바랍니다.</p>


  <p align="justify">DocumentDB를 <a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-create-account/">시작하는</a> 방법 또는 자세한 내용은 <a href="https://azure.microsoft.com/en-us/documentation/services/documentdb/">웹 사이트를</a> 확인하세요.</p>


  <p align="justify">일반적으로 Microsoft Azure 다중 테넌트 애플리케이션을 개발하는 방법에 대한 자세한 내용은 이 훌륭한 <a href="https://msdn.microsoft.com/en-us/library/ff966499.aspx">MSDN 문서를</a> 확인하세요.</p>
