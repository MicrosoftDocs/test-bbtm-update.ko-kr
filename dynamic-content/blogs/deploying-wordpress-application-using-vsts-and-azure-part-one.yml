### YamlMime:Yaml
ms.openlocfilehash: 8ccef03ef2cf0011a39852217839fa57ec0ccde0
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139906483"
Slug: deploying-wordpress-application-using-vsts-and-azure-part-one
Title: Visual Studio Team Services 및 Azure를 사용하여 WordPress 애플리케이션 배포 - 1부
Summary: 이 게시물은 두 블로그 게시물의 첫 번째 부분으로, Azure WebApp for Containers 및 Azure Database for MySQL로 작업하는 Dockerize 사용자 지정 WordPress 웹 사이트를 배포하기 위해 VSTS를 사용하여 CI/CD 파이프라인을 설정하는 방법을 설명합니다.
Content: >-
  <p>이 게시물은 두 블로그 게시물의 첫 번째 부분으로, Azure WebApp for Containers 및 Azure Database for MySQL로 작업하는 dockerize 사용자 지정 WordPress 웹 사이트를 배포하기 위해 VSTS(Visual Studio Team Services)를 사용하여 CI/CD 파이프라인을 설정하는 방법을 설명합니다.</p>


  <h2>동기 부여</h2>


  <p>WordPress CI/CD 파이프라인을 빌드하는 주된 동기는 WordPress가 다양한 환경 간에 쉽게 수정할 수 있도록 동적 구성을 지원하는 데 제한이 있다는 사실입니다. 일부 값은 WordPress MySQL 데이터베이스에서 하드 코딩됩니다. 이러한 제한으로 인해 시간이 오래 걸리는 작업이 발생하여 빠르고 자주 배포하는 기능이 제한됩니다.</p>


  <h2>아이디어</h2>


  <p>로컬, 개발, 테스트 및 프로덕션의 네 가지 환경이 있습니다. 로컬 환경은 Docker 이미지를 로컬로 실행하고, 필요한 변경 내용을 커밋하고, 작업을 완료한 후 마스터 분기에 코드를 푸시하는 개발자를 위한 환경입니다. 푸시 작업은 새 Docker 이미지를 빌드하고 Azure Container Registry에 푸시하는 CI 프로세스를 시작합니다. 이 Docker 이미지의 기본 이미지는 Docker 허브의 WordPress 이미지입니다. dockerfile의 일부로 새 콘텐츠를 새 Docker 이미지로 복사하기 위한 복사 작업이 실행됩니다.</p>


  <p>CI 프로세스가 완료되면 CD 프로세스가 자동으로 시작되며, WordPress DB로 Azure Database for MySQL을 사용하면 각 환경에 별도의 데이터베이스가 있습니다. 하드 코딩된 값 DB를 업데이트하기 위해 이전 환경에서 SQL 스크립트 파일로 DB 내보내기를 수행합니다. 찾기 &amp; 바꾸기를 실행하면 새 SQL 파일이 다음 환경 DB로 복원됩니다. 또한 이 프로세스의 일부로 로깅 및 모니터링을 위해 <a href="https://github.com/Microsoft/ApplicationInsights-WordPress" target="_blank">Azure Application Insights WordPress 플러그 인</a>을 사용합니다.</p>


  <h2>필수 조건</h2>


  <ul>
   <li>다음 서비스를 <a href="https://azure.microsoft.com/en-us/free/" target="_blank">사용하여 Azure 계정을 만듭니</a>다.

   <ul>
    <li>Azure Container Registry의 한 인스턴스.</li>
    <li>5개의 빈 DB가 있는 Azure Database for MySQL의 한 인스턴스입니다.</li>
    <li>각 환경의 컨테이너용 Azure WebApp 인스턴스 3개: 개발, 테스트, 프로덕션, 슬롯 스테이징 1개.</li>
    <li>각 환경에 대한 애플리케이션 Insights 인스턴스 4개( 로컬, 개발, 테스트, 프로덕션)</li>
   </ul>
   </li>
   <li>Visual Studio Marketplace에서 설치된 docker Integration 확장을 사용하여 <a href="https://go.microsoft.com/fwlink/?LinkId=307137" target="_blank">VSTS 계정을 엽니다</a>. 아직 Visual Studio Team Services 계정이 없는&rsquo; 경우 지금 엽니다.</li>
  </ul>


  <p><strong>&rsquo;VSTS에서 ARM 배포 작업을 사용하여 위의 모든 Azure 리소스를 만들 수 있습니다.</strong></p>


  <h2>코드 구조</h2>


  <p><a href="https://github.com/yaprigal/WordPressVSTS" target="_blank">샘플 소스 코드를</a> 찾고, 새 VSTS 프로젝트를 만들고, 이 프로젝트의 마스터 분기에 코드를 업로드할 수 있습니다.</p>


  <p>코드 리포지토리 구조는 다음과 같습니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b029f13a-557b-4643-85fb-90e393dc14f9.png"><img alt="image" border="0" height="137" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bd82c3a3-708f-49f3-b2e3-41ed47e3c86a.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="이미지" width="624"></a></p>


  <ul>
   <li><strong>Html 폴더</strong> &ndash; 샘플 WordPress 파일입니다.</li>
   <li><strong>Db 폴더</strong> &ndash; Azure Database for MySQL로 복원해야 하는 샘플 WordPress 스크립트 DB 파일(이 블로그에서 WordPress5000이라고 함).</li>
   <li><strong>Application-insights 폴더</strong> &ndash; 에는 Application Insights 플러그 인 폴더가 포함되어 있습니다.</li>
   <li><strong>Dockerfile</strong> &ndash; Docker 이미지를 빌드하기 위한 것입니다.</li>
  </ul>


  <p>로컬 컴퓨터에서 다음 docker 명령을 실행하여 WordPress 샘플을 로컬로 실행할 수 있습니다. Azure의 MySQL DB에 연결되며, 이 인스턴스의 방화벽 규칙에 IP를 추가해야 할 수도 있습니다.</p>


  <p>docker run -e DB_ENV_HOST=[mysql db url]:[your mysql port number] -e DB_ENV_USER=[your mysql db user name] -e DB_ENV_PASSWORD=[your mysql db password] -e DB_ENV_NAME=[your mysql database name] -p 5000:80 -d [docker image name]</p>


  <h2>VSTS &ndash; 빌드 단계</h2>


  <p>이제 새 빌드 정의를 만들겠습니다. 관련 원본 리포지토리를 선택하고 빈 템플릿을 빌드 프로세스의 기준으로 선택합니다. <strong>호스트된 Linux 미리 보기를</strong> 에이전트 큐로 선택합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/c0de364b-7457-4b8f-a159-caabc2d92446.png"><img alt="image" border="0" height="209" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/15302e8c-f9fe-40ca-bf52-6128bf0feab0.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="이미지" width="624"></a></p>


  <p>두 개의 새 Docker 작업을 추가합니다.</p>


  <p>첫 번째 Docker 작업은 다음 값을 <strong>사용하여 이미지를 빌드</strong> 하는 것입니다.</p>


  <ul>
   <li>Container Registry 유형 &ndash; Azure Container Registry.</li>
   <li>Azure 구독 &ndash; 은 관련 Azure 구독을 선택합니다.</li>
   <li>Azure Container Registry는 &ndash; 관련 Azure Container Registry를 선택합니다.</li>
   <li>작업 &ndash; 이미지를 빌드합니다.</li>
   <li>Docker 파일 &ndash; 은 리포지토리에서 dockerfile을 선택합니다.</li>
   <li><strong>기본 빌드 컨텍스트 사용</strong> 옵션을 선택합니다.</li>
   <li>이미지 이름 &ndash; [이미지 이름, 모든 문자는 소문자여야 합니다]: $(Build.BuildId).</li>
   <li><strong>이미지 이름 한정</strong> 옵션을 선택합니다.</li>
  </ul>


  <p>두 번째 Docker 작업은 <strong>이미지를 푸시하여</strong> 다음을 선택하는 것입니다.</p>


  <ul>
   <li>Container Registry 유형 &ndash; Azure Container Registry.</li>
   <li>Azure 구독 &ndash; 은 관련 Azure 구독을 선택합니다.</li>
   <li>Azure Container Registry는 &ndash; 관련 Azure Container Registry를 선택합니다.</li>
   <li>작업 &ndash; 이미지를 푸시합니다.</li>
   <li>이미지 이름 &ndash; 첫 번째 작업에서와 동일한 이름입니다.</li>
   <li><strong>이미지 이름 한정</strong> 옵션을 선택합니다.</li>
  </ul>


  <p><strong>트리거 탭</strong> - 에서 연속 통합을 사용하도록 설정합니다.</p>


  <p><a href="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/60c31264-1f48-4c10-8871-5daf814d9356.png"><img alt="image" border="0" height="192" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/21541374-0360-4c7f-83c6-31321a8119a4.png" style="border: 0px currentcolor; border-image: none; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="이미지" width="624"></a></p>


  <p>이제 빌드를 확인해야 합니다.</p>


  <p>프로젝트 파일 중 하나를 약간 변경하고 새 버전을 마스터 분기에 푸시해야 합니다. 새 빌드 프로세스가 시작되어야 합니다. 지금은&rsquo; 이 게시물에서 VSTS 및 docker 통합을 사용하여 새 Docker화된 사용자 지정 WordPress 이미지를 만들고 Azure Container Registry에 푸시하는 CI 프로세스를 만드는 것이 얼마나 쉬운지 알아보았습니다. 전체 CI/CD 파이프라인을 만들기 위한 여정을 계속 진행하는 2부를 계속 지켜보세요.</p>


  <h2>리소스</h2>


  <ul>
   <li><a href="https://docs.microsoft.com/en-us/vsts/build-release/" target="_blank">VSTS에서 CI/CD 시작</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/app-service/containers/" target="_blank">Azure Web App for Containers</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/container-registry/" target="_blank">Azure Container Registry</a></li>
   <li><a href="https://docs.microsoft.com/en-us/vsts/build-release/apps/containers/build" target="_blank">VSTS 컨테이너 빌드</a></li>
   <li><a href="https://docs.microsoft.com/en-us/vsts/build-release/apps/cd/deploy-docker-webapp" target="_blank">Azure Web App for Containers로 배포</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/mysql/" target="_blank">Azure Database for MySQL</a></li>
   <li><a href="https://azure.microsoft.com/en-us/services/application-insights/" target="_blank">Azure Application Insights</a></li>
  </ul>
