### YamlMime:Yaml
ms.openlocfilehash: a792914ac388fada6c52b4dadb61211b1e2c7a83
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139905544"
Slug: finding-circular-foreign-key-references
Title: 순환 외래 키 참조 찾기
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 관계형 데이터베이스의 세계에서 순환 참조는 테이블과 관련된 외세 키가 루프를 만드는 스키마 구조입니다. 원형...'
Content: "<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>관계형 데이터베이스의 세계에서 순환 참조는 테이블과 관련된 외세 키가 루프를 만드는 스키마 구조입니다. 순환 참조는 외세 키가 적용되는 두 관계형 데이터베이스를 동기화하려고 할 때 특수한 유형의 문제를 발생합니다. 이 문제로 인해 순환 참조가 포함된 데이터베이스 스키마는 데이터베이스를 동기화하고 복제할 때 사용할 수 있는 도구에서 제한됩니다. 이 문서에서는 순환 참조를 설명하고 데이터베이스에 순환 참조가 있는지 확인하기 위한 Transact-SQL 스크립트를 보여 줍니다.</p>  <h2>순환 참조란?</h2>  <p>외세 키는 데이터베이스 적용 무결성 제약 조건을 만듭니다. 이러한 제약 조건은 다른 테이블이 이를 참조하기 전에 한 테이블에 데이터 행이 있는지 확인합니다. 또한 다른 행이 참조하는 종속 행이 삭제되지 않도록 합니다. 그림 1에서는 Adventure Works 데이터베이스의 <b>Address</b> 테이블과 <b>StateProvince</b> 테이블 사이에 간단한 외래 키가 표시됩니다.</p>  <p><b>그림 1</b></p>  <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image001[4]\" border=\"0\" alt=\"clip_image001[4]\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1780.clip_5F00_image0014_5F00_thumb_5F00_193FA7C2.png\" width=\"527\" height=\"248\"></a></p>  <p>순환 참조는 외세 키가 루프를 만드는 하나 이상의 테이블입니다. 그림 2는 예제입니다.</p>  <p><b>그림 2</b></p>  <p><a href=\"\"><img style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"clip_image002[4]\" border=\"0\" alt=\"clip_image002[4]\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1777.clip_5F00_image0024_5F00_thumb_5F00_51EA51CF.png\" width=\"212\" height=\"173\"></a></p>  <p>이 경우 <b>City</b> 테이블에는 작성자 참조가 포함됩니다. 도시에 대한 설명을 쓴 저자입니다. <b>작성자</b> 테이블에는 도시에 대한 참조가 있습니다. 각 작성자가 도시에 있기 때문입니다. 그래서 먼저 온, 도시 또는 저자? 순환 참조가 있는 모든 경우 외래 키 열 중 하나는 null 값을 허용해야 합니다. 이렇게 하면 데이터를 3번의 패스에 삽입할 수 있습니다.</p>  <ol>   <li>키가 null로 설정된 nullable 외래 키가 참조하는 테이블에 삽입합니다.</li>    <li>null이 아닌 외래 키가 있는 테이블에 삽입합니다.</li>    <li>2단계에서 삽입된 행을 참조하도록 nullable 외래 키를 수정하는 업데이트입니다.</li> </ol>  <p>순환 참조는 두 개의 테이블로 제한되지 않으며, 여러 테이블을 포함할 수 있으며, 모두 하나의 큰 원으로 함께 바인딩됩니다.</p>  <h3>Self-Referencing 테이블</h3>  <p>특수한 대/소문자 순환 참조는 자체 참조 테이블입니다. 자체 기본 키를 참조하는 외래 키 열이 있는 테이블입니다. 예를 들어 직원과 상사를 추적하는 인적 자원 스키마가 있습니다. 직원 테이블에는 직원 테이블의 기본 키 열을 참조하는 boss라는 외래 키 열이 있습니다. 자체 참조 테이블에는 항상 null 허용 및 하나 이상의 null이 있는 외래 키 열이 있습니다. 위의 예에서는 상사가 없기 때문에 CEO가 될 것입니다.</p>  <h2>순환 참조를 사용하여 스키마 동기화</h2>  <p>순환 참조에 포함되지 않은 테이블은 쉽게 동기화할 수 있으며, 종속성 없이 테이블을 전체 테이블 업데이트한 다음, 외래 키 종속성으로 테이블을 업데이트합니다. 그림 1에서는 <b>StateProvince</b> 테이블, <b>주소</b> 테이블을 업데이트합니다. 이 설명은 간소화됩니다. 예를 들어 삭제는 역순으로 수행됩니다. 테이블에 순환 참조가 없는 경우 종속성 순서를 알고 있는 경우 테이블을 테이블별로 동기화할 수 있습니다.</p>  <p>테이블 행을 행별로 업데이트하고, 테이블 사이를 오가며, null 허용 외래 키를 먼저 null로 삽입한 다음, 나중에 업데이트해야 하기 때문에 테이블을 순환 참조와 동기화하는 것은 훨씬 더 어렵습니다. 다시 이것은 간단한 설명입니다. 순환 참조가 있는 경우 테이블을 직렬 순서로 업데이트할 수 없다는 점입니다.</p>  <p>순환 참조를 사용하여 테이블을 포함하는 데이터베이스를 동기화하는 방법은 몇 가지뿐입니다.</p>  <ul>   <li>원본 데이터베이스에서 데이터가 변경된 것과 동일한 직렬 순서로 데이터를 업데이트, 삽입 및 삭제하는 SQL Server 복제와 마찬가지로 트랜잭션 기반 복제를 수행합니다.</li>    <li>데이터베이스를 읽기 전용 모드로 설정하고, 검사 제약 조건 없이 동일한 기본 키를 사용하여 대상 데이터베이스에 행을 대량 복사합니다. 모든 테이블을 이동하면 원본 데이터베이스를 읽기 전용 모드에서 제거할 수 있습니다. 여기서 bcp 유틸리티를 사용하여 이 작업을 수행하는 방법에 대해 블로그를 참조하세요. </li>    <li>종속성에 따라 행별로 가능한 삽입, 업데이트 및 삭제 순서를 추론하고 대상 데이터베이스에서 행을 다시 만듭니다. 이는 데이터를 업데이트, 삽입 및 삭제하는 데 걸린 트랜잭션을 이전 버전으로 엔지니어링하는 것과 비슷합니다.</li> </ul>  <h2>순환 참조 검색</h2>  <p>아래 Transact-SQL 스크립트는 재귀 커서를 사용하여 데이터베이스 스키마에 순환 참조가 있는지 검색합니다. SQL Azure 동기화하기 전에 SQL Server 데이터베이스에서 실행하거나 SQL Azure 데이터베이스에서 실행할 수 있습니다. SQL Server Management Studio 쿼리 창에서 실행할 수 있습니다. 출력은 메시지 섹션과 같이 표시됩니다.</p>  <p>순환 참조가 있는 경우 출력은 다음과 같습니다.</p>  <pre class=\"csharpcode\">dbo.City -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City  dbo.Division -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Division  dbo.State -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.State  dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County  dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image  dbo.Location -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Location  dbo.LGroup -<span class=\"kwrd\">&gt;</span> dbo.LGroup  dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region  dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.Author  dbo.Area -<span class=\"kwrd\">&gt;</span> dbo.Author -<span class=\"kwrd\">&gt;</span> dbo.City -<span class=\"kwrd\">&gt;</span> dbo.County -<span class=\"kwrd\">&gt;</span> dbo.Region -<span class=\"kwrd\">&gt;</span> dbo.Image -<span class=\"kwrd\">&gt;</span> dbo.Area</pre>      <p>각 줄은 circle.&#160; 순환 참조를 검색하는 Transact-SQL 스크립트를 만드는 테이블의 링크 목록이 있는 순환 참조입니다. 그러나 이 페이지에서 다운로드할 수도 있습니다.&#160; 이 코드는 SQL Azure 및 SQL Server 작동합니다.</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>    <span class=\"rem\">-- WWB: Create a Temp Table Of All Relationship To Improve Overall Performance</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #TableRelationships (FK_Schema nvarchar(<span class=\"kwrd\">max</span>), FK_Table nvarchar(<span class=\"kwrd\">max</span>),      PK_Schema nvarchar(<span class=\"kwrd\">max</span>), PK_Table nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"rem\">-- WWB: Create a List Of All Tables To Check</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #TableList ([<span class=\"kwrd\">Schema</span>] nvarchar(<span class=\"kwrd\">max</span>), [<span class=\"kwrd\">Table</span>] nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"rem\">-- WWB: Fill the Table List</span>  INSERT <span class=\"kwrd\">INTO</span> #TableList ([<span class=\"kwrd\">Table</span>], [<span class=\"kwrd\">Schema</span>])  <span class=\"kwrd\">SELECT</span> TABLE_NAME, TABLE_SCHEMA  <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.TABLES   <span class=\"kwrd\">WHERE</span> Table_Type = <span class=\"str\">'BASE TABLE'</span>    <span class=\"rem\">-- WWB: Fill the RelationShip Temp Table</span>  INSERT <span class=\"kwrd\">INTO</span> #TableRelationships(FK_Schema, FK_Table, PK_Schema, PK_Table)  <span class=\"kwrd\">SELECT</span>      FK.TABLE_SCHEMA,      FK.TABLE_NAME,      PK.TABLE_SCHEMA,      PK.TABLE_NAME  <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS C        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS FK <span class=\"kwrd\">ON</span>           C.CONSTRAINT_NAME = FK.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS PK <span class=\"kwrd\">ON</span>           C.UNIQUE_CONSTRAINT_NAME = PK.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.KEY_COLUMN_USAGE CU <span class=\"kwrd\">ON</span>           C.CONSTRAINT_NAME = CU.CONSTRAINT_NAME        <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> (              <span class=\"kwrd\">SELECT</span> i1.TABLE_NAME, i2.COLUMN_NAME              <span class=\"kwrd\">FROM</span> INFORMATION_SCHEMA.TABLE_CONSTRAINTS i1              <span class=\"kwrd\">INNER</span> <span class=\"kwrd\">JOIN</span> INFORMATION_SCHEMA.KEY_COLUMN_USAGE i2 <span class=\"kwrd\">ON</span>               i1.CONSTRAINT_NAME = i2.CONSTRAINT_NAME              <span class=\"kwrd\">WHERE</span> i1.CONSTRAINT_TYPE = <span class=\"str\">'PRIMARY KEY'</span>  ) PT <span class=\"kwrd\">ON</span> PT.TABLE_NAME = PK.TABLE_NAME    <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">TABLE</span> #Stack([<span class=\"kwrd\">Schema</span>] nvarchar(<span class=\"kwrd\">max</span>), [<span class=\"kwrd\">Table</span>] nvarchar(<span class=\"kwrd\">max</span>))    <span class=\"kwrd\">GO</span>    <span class=\"rem\">-- WWB: Drop SqlAzureRecursiveFind</span>  <span class=\"kwrd\">IF</span>  <span class=\"kwrd\">EXISTS</span> (<span class=\"kwrd\">SELECT</span> * <span class=\"kwrd\">FROM</span> sys.objects <span class=\"kwrd\">WHERE</span> object_id =       OBJECT_ID(N<span class=\"str\">'[dbo].[SqlAzureRecursiveFind]'</span>) <span class=\"kwrd\">AND</span> type <span class=\"kwrd\">in</span> (N<span class=\"str\">'P'</span>, N<span class=\"str\">'PC'</span>))  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">PROCEDURE</span> [dbo].[SqlAzureRecursiveFind]    <span class=\"kwrd\">GO</span>    <span class=\"rem\">-- WWB: Create a Stored Procedure that Recursively Calls Itself</span>  <span class=\"kwrd\">CREATE</span> <span class=\"kwrd\">PROC</span> SqlAzureRecursiveFind      @BaseSchmea nvarchar(<span class=\"kwrd\">max</span>),      @BaseTable nvarchar(<span class=\"kwrd\">max</span>),      @Schmea nvarchar(<span class=\"kwrd\">max</span>),      @<span class=\"kwrd\">Table</span> nvarchar(<span class=\"kwrd\">max</span>),      @Fail nvarchar(<span class=\"kwrd\">max</span>) <span class=\"kwrd\">OUTPUT</span>  <span class=\"kwrd\">AS</span>        <span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>                      <span class=\"rem\">-- WWB: Keep Track Of the Schema and Tables We Have Checked</span>      <span class=\"rem\">-- Prevents Looping          </span>      INSERT <span class=\"kwrd\">INTO</span> #Stack([<span class=\"kwrd\">Schema</span>],[<span class=\"kwrd\">Table</span>]) <span class=\"kwrd\">VALUES</span> (@Schmea, @<span class=\"kwrd\">Table</span>)            <span class=\"kwrd\">DECLARE</span> @RelatedSchema nvarchar(<span class=\"kwrd\">max</span>)      <span class=\"kwrd\">DECLARE</span> @RelatedTable nvarchar(<span class=\"kwrd\">max</span>)            <span class=\"rem\">-- WWB: Select all tables that the input table is dependent on</span>      <span class=\"kwrd\">DECLARE</span> table_cursor <span class=\"kwrd\">CURSOR</span> <span class=\"kwrd\">LOCAL</span>  <span class=\"kwrd\">FOR</span>            <span class=\"kwrd\">SELECT</span> PK_Schema, PK_Table            <span class=\"kwrd\">FROM</span> #TableRelationships            <span class=\"kwrd\">WHERE</span> FK_Schema = @Schmea <span class=\"kwrd\">AND</span> FK_Table = @<span class=\"kwrd\">Table</span>        <span class=\"kwrd\">OPEN</span> table_cursor;        <span class=\"rem\">-- Perform the first fetch.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> table_cursor <span class=\"kwrd\">INTO</span> @RelatedSchema, @RelatedTable;        <span class=\"rem\">-- Check @@FETCH_STATUS to see if there are any more rows to fetch.</span>      <span class=\"kwrd\">WHILE</span> <span class=\"preproc\">@@FETCH_STATUS</span> = 0      <span class=\"kwrd\">BEGIN</span>                <span class=\"rem\">-- WWB: If We have Recurred To Where We Start This</span>          <span class=\"rem\">-- Is a Circular Reference</span>          <span class=\"rem\">-- Begin failing out of the recursions</span>          <span class=\"kwrd\">IF</span> (@BaseSchmea = @RelatedSchema <span class=\"kwrd\">AND</span>                   @BaseTable = @RelatedTable)              <span class=\"kwrd\">BEGIN</span>                  <span class=\"kwrd\">SET</span> @Fail = @RelatedSchema + <span class=\"str\">'.'</span> + @RelatedTable                  <span class=\"kwrd\">RETURN</span>              <span class=\"kwrd\">END</span>          <span class=\"kwrd\">ELSE</span>                      <span class=\"kwrd\">BEGIN</span>                        <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Count</span> <span class=\"kwrd\">int</span>                        <span class=\"rem\">-- WWB: Check to make sure that the dependencies are not in the stack</span>              <span class=\"rem\">-- If they are we don't need to go down this branch</span>              <span class=\"kwrd\">SELECT</span>    @<span class=\"kwrd\">Count</span> = <span class=\"kwrd\">COUNT</span>(1)              <span class=\"kwrd\">FROM</span>    #Stack                  <span class=\"kwrd\">WHERE</span>    #Stack.[<span class=\"kwrd\">Schema</span>] = @RelatedSchema <span class=\"kwrd\">AND</span>                   #Stack.[<span class=\"kwrd\">Table</span>] = @RelatedTable                        <span class=\"kwrd\">IF</span> (@<span class=\"kwrd\">Count</span>=0)               <span class=\"kwrd\">BEGIN</span>                  <span class=\"rem\">-- WWB: Recurse</span>                  <span class=\"kwrd\">EXECUTE</span> SqlAzureRecursiveFind @BaseSchmea,                       @BaseTable,                       @RelatedSchema, @RelatedTable, @Fail <span class=\"kwrd\">OUTPUT</span>                  <span class=\"kwrd\">IF</span> (LEN(@Fail) &gt; 0)                  <span class=\"kwrd\">BEGIN</span>                      <span class=\"rem\">-- WWB: If the Call Fails, Build the Output Up</span>                      <span class=\"kwrd\">SET</span> @Fail = @RelatedSchema + <span class=\"str\">'.'</span> + @RelatedTable                           + <span class=\"str\">' -&gt; '</span> + @Fail                      <span class=\"kwrd\">RETURN</span>                  <span class=\"kwrd\">END</span>              <span class=\"kwrd\">END</span>         <span class=\"kwrd\">END</span>                      <span class=\"rem\">-- This is executed as long as the previous fetch succeeds.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> table_cursor <span class=\"kwrd\">INTO</span> @RelatedSchema, @RelatedTable;      <span class=\"kwrd\">END</span>        <span class=\"kwrd\">CLOSE</span> table_cursor;      <span class=\"kwrd\">DEALLOCATE</span> table_cursor;        <span class=\"kwrd\">GO</span>        <span class=\"kwrd\">SET</span> NOCOUNT <span class=\"kwrd\">ON</span>    <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Schema</span> nvarchar(<span class=\"kwrd\">max</span>)  <span class=\"kwrd\">DECLARE</span> @<span class=\"kwrd\">Table</span> nvarchar(<span class=\"kwrd\">max</span>)  <span class=\"kwrd\">DECLARE</span> @Fail nvarchar(<span class=\"kwrd\">max</span>)    <span class=\"rem\">-- WWB: Loop Through All the Tables In the Database Checking Each One</span>  <span class=\"kwrd\">DECLARE</span> list_cursor <span class=\"kwrd\">CURSOR</span> <span class=\"kwrd\">FOR</span>        <span class=\"kwrd\">SELECT</span> [<span class=\"kwrd\">Schema</span>], [<span class=\"kwrd\">Table</span>]        <span class=\"kwrd\">FROM</span> #TableList    <span class=\"kwrd\">OPEN</span> list_cursor;    <span class=\"rem\">-- Perform the first fetch.</span>  <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> list_cursor <span class=\"kwrd\">INTO</span> @<span class=\"kwrd\">Schema</span>, @<span class=\"kwrd\">Table</span>;    <span class=\"rem\">-- Check @@FETCH_STATUS to see if there are any more rows to fetch.</span>  <span class=\"kwrd\">WHILE</span> <span class=\"preproc\">@@FETCH_STATUS</span> = 0  <span class=\"kwrd\">BEGIN</span>        <span class=\"rem\">-- WWB: Clear the Stack (Don't you love Global Variables)</span>      <span class=\"kwrd\">DELETE</span> #Stack            <span class=\"rem\">-- WWB: Initialize the Input</span>      <span class=\"kwrd\">SET</span> @Fail = <span class=\"str\">''</span>        <span class=\"rem\">-- WWB: Check the Table</span>      <span class=\"kwrd\">EXECUTE</span> SqlAzureRecursiveFind @<span class=\"kwrd\">Schema</span>,           @<span class=\"kwrd\">Table</span>, @<span class=\"kwrd\">Schema</span>,           @<span class=\"kwrd\">Table</span>, @Fail <span class=\"kwrd\">OUTPUT</span>      <span class=\"kwrd\">IF</span> (LEN(@Fail) &gt; 0)      <span class=\"kwrd\">BEGIN</span>          <span class=\"rem\">-- WWB: Failed, Output</span>          <span class=\"kwrd\">SET</span> @Fail = @<span class=\"kwrd\">Schema</span> + <span class=\"str\">'.'</span> + @<span class=\"kwrd\">Table</span> + <span class=\"str\">' -&gt; '</span> + @Fail          <span class=\"kwrd\">PRINT</span> @Fail      <span class=\"kwrd\">END</span>                   <span class=\"rem\">-- This is executed as long as the previous fetch succeeds.</span>      <span class=\"kwrd\">FETCH</span> <span class=\"kwrd\">NEXT</span> <span class=\"kwrd\">FROM</span> list_cursor <span class=\"kwrd\">INTO</span> @<span class=\"kwrd\">Schema</span>, @<span class=\"kwrd\">Table</span>;  <span class=\"kwrd\">END</span>    <span class=\"rem\">-- WWB: Clean Up</span>  <span class=\"kwrd\">CLOSE</span> list_cursor;  <span class=\"kwrd\">DEALLOCATE</span> list_cursor;                            <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #TableRelationships  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #Stack  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">TABLE</span> #TableList  <span class=\"kwrd\">DROP</span> <span class=\"kwrd\">PROC</span> SqlAzureRecursiveFind</pre>      <h2>요약</h2>    <p>질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>"
