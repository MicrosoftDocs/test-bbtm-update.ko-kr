### YamlMime:Yaml
ms.openlocfilehash: 0c6023d7a2d0a546f5f952523e4f89e559b6d327
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139911077"
Slug: compression-for-speed-and-cost-savings
Title: 속도 및 비용 절감을 위한 압축
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] SQL Azure 현재 SQL Server 2008의 엔터프라이즈 버전과 같은 페이지 수준 또는 행 수준 압축을 지원하지 않습니다. 그러나 구현할 수 있습니다...'
Content: '<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>SQL Azure 현재 SQL Server 2008의 엔터프라이즈 버전과 같은 페이지 수준 또는 행 수준 압축을 지원하지 않습니다. 그러나 데이터 액세스 계층에서 고유한 열 수준 압축을 구현하여 압축의 성능 및 비용 절감을 활용할 수 있습니다. 이 작업을 수행하는 방법을 설명하고 이 블로그 게시물에서 몇 가지 예제 코드를 제공합니다.</p>  <p>열 수준 압축은 데이터를 데이터베이스에 쓰기 전에 압축하고 데이터베이스에서 압축을 해제하는 개념입니다. 예를 들어 <b>varchar(max)</b> 텍스트 열이 있는 대신 평균 80% 더 적은 데이터를 보유하는 압축된 텍스트의 <b>varbinary(max) </b>가 있습니다.</p>  <h2>올바른 시나리오</h2>  <p>특정 시나리오에서만 열 수준 압축이 제대로 작동합니다. 열을 압축하는 경우 다음을 고려합니다.</p>  <ul>   <li>큰 텍스트 열은 압축하는 것이 가장 좋습니다. 그들은 당신에게 가장 저축을 얻을. 압축으로 인한 이득은 압축 사전을 만드는 비용(deflate 압축을 사용한 결과)을 초과해야 합니다. 이는 반복되는 많은 양의 데이터가 있는 경우에만 발생합니다. 이 기술은 텍스트뿐만 아니라 콘텐츠에 따라 큰 xml 및 이진 데이터에도 도움이 됩니다. 예를 들어 이미지 Blob을 압축하지 않으려는 경우 일반적으로 이미 압축되어 있습니다.</li>    <li>쿼리의 WHERE 절에 표시되는 열을 압축하지 마세요. 이 기술을 사용하면 압축된 텍스트를 압축 해제하지 않고 쿼리할 수 없습니다. 또한 SSMS 통해 이러한 필드를 쿼리하거나 액세스하거나 BCP.exe 사용하여 데이터를 직접 로드할 수 없습니다.</li>    <li>애플리케이션 쪽에서 캐시할 수 있는 열을 압축하여 여러 읽기를 방지합니다. 이렇게 하면 텍스트의 압축을 풉니다.</li> </ul>  <p>예를 들어 잘 작동하는 시나리오는 제품 설명을 압축하고 설명 내에서 검색할 필요가 없고 자주 변경되지 않는 웹 기반 제품 카탈로그입니다.</p>  <h2>이점</h2>  <p>압축을 사용하면 저장하는 데이터의 양을 줄여 비용을 절감할 수 있습니다. 또한 SQL Azure 최대 50기가바이트 데이터베이스 크기 미만으로 유지하고 분할 개발 비용을 방지하는 데 도움이 될 수 있습니다.</p>  <p>특정 시나리오에서는 압축을 통해 클러스터형 인덱스에 대한 전체 테이블 검색을 미리 구성하는 쿼리의 속도가 향상될 수 있습니다. <a href="https://msdn.microsoft.com/en-us/library/ms178158.aspx">큰 값 데이터 형식</a>을 처리할 때 열의 데이터가 8,000바이트 미만이면 나머지 열 데이터와 함께 페이지에 저장됩니다. 8000바이트를 줄일 수 있는 경우 한 번에 더 많은 행을 페이징할 수 있으므로 테이블의 전체 테이블 검색에서 성능이 향상됩니다.</p>  <h2>테이블 수정</h2>  <p>압축된 데이터는 <b>varbinary(max</b>) 열에 저장해야 합니다. <b>nvarchar(max)</b> 열을 압축하는 경우 데이터를 압축할 추가 열을 만들어야 합니다. ALTER TABLE 명령을 사용하여 이 작업을 수행할 수 있습니다. 텍스트가 압축되면 <b>nvarchar(max)</b> 열을 삭제합니다. 다음은 SQL Azure 열을 추가하는 Transact-SQL 예제입니다.</p>  <pre class="csharpcode"><span class="kwrd">ALTER</span> <span class="kwrd">TABLE</span> Images <span class="kwrd">ADD</span> PageUriCompressed varbinary(<span class="kwrd">max</span>) <span class="kwrd">NOT</span> <span class="kwrd">NULL</span> <span class="kwrd">DEFAULT</span>(0x0)</pre>      <h4>데이터 계층</h4>    <p>다행히 .NET CLR 2.0에는 <a href="https://msdn.microsoft.com/en-us/library/system.io.compression.gzipstream.aspx"><b>GZipStream</b></a> 클래스를 사용하여 <b>System.IO.Compression</b> 네임스페이스에 기본 제공되는 몇 가지 훌륭한 압축이 있습니다. 가장 먼저 해야 할 일은 기존 행을 모두 새 열로 압축하는 데 한 번 사용할 Throw 콘솔 애플리케이션을 만드는 것입니다. 다음과 같습니다.</p>    <pre class="csharpcode"><span class="kwrd">do</span>  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLAzure&quot;</span>].ConnectionString))      {          String pageUri;          Int64 Id;            <span class="rem">// Open the connection</span>          sqlConnection.Open();            <span class="rem">// Pull One Row At A Time To Prevent Long Running</span>          <span class="rem">// Transactions</span>          SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(              <span class="str">&quot;SELECT TOP 1 ID, PageUri FROM [Images] WHERE PageUriCompressed = 0x0&quot;</span>,              sqlConnection);            <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              <span class="rem">// WWB: Exit Do Loop When There Is No More Rows</span>              <span class="kwrd">if</span> (!sqlDataReader.Read())                  <span class="kwrd">break</span>;                pageUri = (String)sqlDataReader[<span class="str">&quot;PageUri&quot;</span>];              Id = (Int64)sqlDataReader[<span class="str">&quot;ID&quot;</span>];          }            Console.Write(<span class="str">&quot;.&quot;</span>);            <span class="rem">// Compress Into the Memory Stream</span>          <span class="kwrd">using</span> (MemoryStream memoryStream = <span class="kwrd">new</span> MemoryStream())          {              <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                  CompressionMode.Compress, <span class="kwrd">true</span>))              {                  <span class="rem">// Unicode == nvarchar</span>                  Byte[] encodedPageUri = Encoding.Unicode.GetBytes(pageUri);                  gzipStream.Write(encodedPageUri, 0, encodedPageUri.Length);              }                <span class="rem">// Now Everything is compressed into the memoryStream</span>              <span class="rem">// Reset to Zero Because We Are Going To Read It</span>              memoryStream.Position = 0;                <span class="rem">// WWB: Stream for Writing</span>              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(sqlConnection,                  <span class="str">&quot;dbo&quot;</span>,                  <span class="str">&quot;Images&quot;</span>,                  <span class="str">&quot;PageUriCompressed&quot;</span>,                  <span class="str">&quot;ID&quot;</span>,                  SqlDbType.BigInt, Id))              {                  <span class="kwrd">using</span> (BinaryReader binaryReader = <span class="kwrd">new</span> BinaryReader(memoryStream))                  {                      <span class="kwrd">using</span> (BinaryWriter binaryWriter = <span class="kwrd">new</span> BinaryWriter(sqlStream))                      {                          Int32 read;                          Byte[] buffer = <span class="kwrd">new</span> Byte[1024];                          <span class="kwrd">do</span>                          {                              read = binaryReader.Read(buffer, 0, 1024);                              <span class="kwrd">if</span> (read &gt; 0)                                  binaryWriter.Write(buffer, 0, read);                            } <span class="kwrd">while</span> (read &gt; 0);                      }                  }              }          }      }  } <span class="kwrd">while</span> (<span class="kwrd">true</span>);    Console.WriteLine(<span class="str">&quot;&quot;</span>);</pre>      <p>이 코드는 이 블로그 게시물에 도입된 <b>SqlStream</b> 클래스를 사용합니다. 또한 로컬 메모리를 잘 활용하려고 시도하며 압축되는 문자열이 실제로 큰 경우 너무 많이 사용하지 않습니다. 그러나 이로 인해 SQL Azure 대한 많은 연결을 만들고 원하는 것보다 느리게 실행되는 매우 "수다스러운" 애플리케이션이 생성됩니다.</p>    <h2>평가</h2>    <p>다음 단계는 압축이 실제로 도움이 되었는지 평가하는 것입니다. 실제 데이터를 압축할 때까지 압축의 이점을 평가하기 어려울 수 있으므로 이 작업을 수행합니다. 이렇게 하려면 Transact-SQL DATALENGTH 필드를 사용하여 두 열(예: 압축 전후)을 합산합니다. 내 쿼리는 다음과 같습니다.</p>    <pre class="csharpcode"><span class="kwrd">SELECT</span> <span class="kwrd">COUNT</span>(1), <span class="kwrd">SUM</span>(DATALENGTH(PageUri)), <span class="kwrd">SUM</span>(DATALENGTH(PageUriCompressed))  <span class="kwrd">FROM</span> Images</pre>      <p>결과는 다음과 같습니다.</p>    <p><a href=""><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="clip_image001" border="0" alt="clip_image001" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1727.clip_5F00_image001_5F00_thumb.png" width="273" height="92"></a></p>    <p>이 경우 압축이 실제로 내 데이터베이스의 크기를 줄이는 것을 볼 수 있습니다. 일부 시나리오에서는 압축으로 인해 데이터가 커지는데, 일반적으로 데이터 사전이 압축의 이익을 초과하는 경우입니다. 엄지 손가락의 규칙으로, 텍스트에 효과적인 압축을 하려면 긴 텍스트 블록에서 발생하는 여러 반복 구가 필요합니다. </p>    <h2>코드 </h2>    <p>이제 열이 압축되었으므로 압축된 데이터를 읽고 압축되지 않은 데이터를 압축된 열에 쓸 수 있어야 합니다. 이 작업을 수행하는 데 도움이 되는 몇 가지 예제 코드는 다음과 같습니다.</p>    <pre class="csharpcode"><span class="kwrd">protected</span> <span class="kwrd">static</span> String Read(Int64 id)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[<span class="str">&quot;SQLAzure&quot;</span>].ConnectionString))      {          sqlConnection.Open();            SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(              <span class="str">&quot;SELECT PageUriCompressed FROM [Images] WHERE ID = @Id&quot;</span>,                  sqlConnection);            sqlCommand.Parameters.AddWithValue(<span class="str">&quot;@Id&quot;</span>, id);            <span class="kwrd">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())          {              sqlDataReader.Read();                Byte[] compressedPageUri =                   (Byte[])sqlDataReader[<span class="str">&quot;PageUriCompressed&quot;</span>];                <span class="kwrd">using</span> (MemoryStream memoryStream =                   <span class="kwrd">new</span> MemoryStream(compressedPageUri))              {                  <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                       CompressionMode.Decompress))                  {                      <span class="kwrd">using</span> (StreamReader streamReader =                          <span class="kwrd">new</span> StreamReader(gzipStream, Encoding.Unicode))                      {                          <span class="kwrd">return</span> (streamReader.ReadToEnd());                      }                  }              }          }      }  }</pre>      <p>쓰기:</p>    <pre class="csharpcode">protected <span class="kwrd">static</span> void <span class="kwrd">Write</span>(Int64 id, String pageUri)  {      <span class="kwrd">using</span> (SqlConnection sqlConnection =          <span class="kwrd">new</span> SqlConnection(              ConfigurationManager.ConnectionStrings[&quot;SQLAzure&quot;].ConnectionString))      {          // <span class="kwrd">Open</span> the <span class="kwrd">connection</span>          sqlConnection.<span class="kwrd">Open</span>();            // Compress <span class="kwrd">Into</span> the Memory Stream          <span class="kwrd">using</span> (MemoryStream memoryStream = <span class="kwrd">new</span> MemoryStream())          {              <span class="kwrd">using</span> (GZipStream gzipStream = <span class="kwrd">new</span> GZipStream(memoryStream,                  CompressionMode.Compress, <span class="kwrd">true</span>))              {                  // Unicode == nvarchar                  Byte[] encodedPageUri = Encoding.Unicode.GetBytes(pageUri);                  gzipStream.<span class="kwrd">Write</span>(encodedPageUri, 0, encodedPageUri.Length);              }                // Now Everything <span class="kwrd">is</span> compressed <span class="kwrd">into</span> the memoryStream              // Reset <span class="kwrd">to</span> Zero Because We <span class="kwrd">Are</span> Going <span class="kwrd">To</span> <span class="kwrd">Read</span> It              memoryStream.<span class="kwrd">Position</span> = 0;                // WWB: Stream <span class="kwrd">for</span> Writing              <span class="kwrd">using</span> (SqlStream sqlStream = <span class="kwrd">new</span> SqlStream(sqlConnection,                  &quot;dbo&quot;,                  &quot;Images&quot;,                  &quot;PageUriCompressed&quot;,                  &quot;ID&quot;,                  SqlDbType.BigInt, id))              {                  <span class="kwrd">using</span> (BinaryReader binaryReader = <span class="kwrd">new</span> BinaryReader(memoryStream))                  {                      <span class="kwrd">using</span> (BinaryWriter binaryWriter = <span class="kwrd">new</span> BinaryWriter(sqlStream))                      {                          Int32 <span class="kwrd">read</span>;                          Byte[] buffer = <span class="kwrd">new</span> Byte[1024];                          do                          {                              <span class="kwrd">read</span> = binaryReader.<span class="kwrd">Read</span>(buffer, 0, 1024);                              <span class="kwrd">if</span> (<span class="kwrd">read</span> &gt; 0)                                  binaryWriter.<span class="kwrd">Write</span>(buffer, 0, <span class="kwrd">read</span>);                            } <span class="kwrd">while</span> (<span class="kwrd">read</span> &gt; 0);                      }                  }              }          }      }  }</pre>      <h2>SQL 압축</h2>    <p>비교를 위해 온-프레미스 SQL Server 기본 제공되는 압축은 애플리케이션에 투명하며, 행에서 페이지로 범위가 지정되기 때문에 <b>소수점 및</b> <b>bigint</b>와 같은 훨씬 광범위한 형식의 이점을 더 큰 형식으로 얻을 수 있습니다. 즉, 페이지의 모든 열에서 압축에 반복 사전을 사용할 수 있습니다. SQL Server 2008 압축에 대한 자세한 내용은 여기를 참조<a href="https://www.microsoft.com/sqlserver/2008/en/us/compression.aspx">하세요</a>.</p>    <h2>요약</h2>    <p>당신은 같은 일을 수행하는 더 나은 방법이 있습니까? 아래의 의견에 게시합니다. 질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>'
