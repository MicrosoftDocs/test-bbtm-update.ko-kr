### YamlMime:Yaml
ms.openlocfilehash: 4d39fee3612ae49ac50c078d1b5e242fb6fccf13
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139913063"
Slug: building-more-secure-middle-tier-applications-with-azure-sql-database-using-row-level-security
Title: Row-Level 보안을 사용하여 Azure SQL Database 사용하여 더 안전한 Middle-Tier 애플리케이션 빌드
Summary: Row-Level Security를 사용하면 개발자가 데이터베이스 테이블의 행에 대한 세분화된 액세스 제어를 구현할 수 있습니다.
Content: "Azure SQL Database 대한 새로운 프로그래밍 기능인 Row-Level 보안(RLS)은 이제 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/sql-database-preview-whats-new/\">최신 버전의</a> SQL Database(V12)의 모든 데이터베이스에 대해 미리 보기로 제공됩니다. Row-Level Security를 사용하면 개발자가 데이터베이스 테이블의 행에 대한 세분화된 액세스 제어를 구현할 수 있습니다. 이렇게 하면 여러 사용자가 동일한 테이블을 공유할 때 무단 액세스를 방지할 수 있으며 다중 테넌트 애플리케이션에서 연결 필터링을 구현하는 데 도움이 될 수 있습니다. 이 게시물은 RLS를 사용하여 Azure SQL Database 사용하여 보안 중간 계층 및 다중 테넌트 애플리케이션 빌드를 시작하는 데 도움이 됩니다.\n\n고객이 판매를 추적하는 데 사용하는 3계층 전자상거래 SaaS 솔루션이 있다고 가정해 보겠습니다. 고객은 중간 계층 애플리케이션을 통해서만 판매 데이터에 액세스할 수 있으므로 효율성을 위해 데이터 계층에서 다중 테넌트 아키텍처를 채택합니다. 따라서 모든 테넌트(고객)의 판매 데이터는 동일한 데이터베이스와 테이블에 저장됩니다.\n\n<b>Dbo. 판매</b>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"96\">OrderID</td>\n<td valign=\"top\" width=\"96\">SKU</td>\n<td valign=\"top\" width=\"96\">가격</td>\n<td valign=\"top\" width=\"96\">TenantId</td>\n</tr>\n<tr>\n<td style=\"text-align: left;\" valign=\"top\" width=\"96\">1</td>\n<td valign=\"top\" width=\"96\">Book001</td>\n<td valign=\"top\" width=\"96\">10</td>\n<td valign=\"top\" width=\"96\">1</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"96\">2</td>\n<td valign=\"top\" width=\"96\">Movie001</td>\n<td valign=\"top\" width=\"96\">15</td>\n<td valign=\"top\" width=\"96\">2</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"96\">3</td>\n<td valign=\"top\" width=\"96\">Movie002</td>\n<td valign=\"top\" width=\"96\">12</td>\n<td valign=\"top\" width=\"96\">2</td>\n</tr>\n</tbody>\n</table>\n테넌트가 자신의 판매 데이터만 볼 수 있도록 하고 싶습니다. 예를 들어 테넌트 1이 로그인되는 동안 애플리케이션이 이 테이블을 쿼리할 때마다 \"WHERE TenantId = 1\" 조건자를 수동으로 추가할 수 있습니다. 그러나 이와 같이 애플리케이션에서 필터링 논리를 사용하여 쿼리를 다시 작성하는 것은 오류가 발생하기 쉬우며 코드베이스를 수정할 때마다 유지 관리하기가 어려울 수 있습니다. RLS를 사용하여 데이터베이스 자체 내에서 필터링 논리를 중앙 집중화하여 유지 관리를 간소화하고 애플리케이션을 계속 개발할 때 오류 위험을 줄일 수 있습니다.\n<h2>1단계: CONTEXT_INFO 사용하여 애플리케이션 사용자 컨텍스트 설정</h2>\n애플리케이션을 한 번만 변경합니다. 애플리케이션은 연결 풀링을 사용하고 모든 애플리케이션 사용자가 동일한 데이터베이스 로그인을 공유하기 때문에 애플리케이션은 RLS가 필터링할 행을 알 수 있도록 현재 로그인된 테넌트에 대해 데이터베이스에 알려야 합니다. 이렇게 하려면 <a href=\"https://msdn.microsoft.com/en-us/library/ms180125.aspx\">이제 SQL Database</a> V12 업데이트에서 액세스할 수 있는 연결 범위 글로벌 변수인 CONTEXT_INFO 사용합니다. SSMS 또는 SSDT에서 애플리케이션이 CONTEXT_INFO TenantId로 설정하는 데 사용할 수 있는 저장 프로시저를 T-SQL 만들어 보겠습니다.\n<pre class=\"prettyprint\">CREATE PROCEDURE sp_setContextInfoAsTenantId(@TenantId int)\nAS\nSET CONTEXT_INFO @TenantId \nGO\n</pre>\n연결을 연 후 애플리케이션은 로그인한 사용자의 TenantId를 사용하여 이 저장 프로시저를 실행하기만 하면 됩니다.\n<h2>2단계: 조건자 함수에서 액세스 논리 인코딩</h2>\n이제 행 액세스 논리에 대한 인라인 테이블 반환 함수를 만듭니다. 이 조건자 함수는 임의로 복잡할 수 있지만(예: 다른 테이블과 조인하거나 계층적 액세스 제어를 적용하기 위해 여러 매개 변수를 확인) 애플리케이션의 경우 매우 간단합니다. 모범 사례로 조건자 함수 및 보안 정책을 별도의 스키마에 배치합니다.\n<pre class=\"prettyprint\">CREATE SCHEMA rls\nGO\n \nCREATE FUNCTION rls.fn_tenantAccessPredicate(@TenantId int)\nRETURNS TABLE\nWITH SCHEMABINDING\nAS\nRETURN SELECT 1 AS fn_accessResult \nWHERE DATABASE_PRINCIPAL_ID() = DATABASE_PRINCIPAL_ID('AppUser') -- the shared application login\nAND CONVERT(int, CONVERT(varbinary(4), CONTEXT_INFO())) = @TenantId\nGO\n</pre>\n사용자가 Sales 테이블을 쿼리할 때 이 함수는 모든 행에 적용되어 TenantId가 CONTEXT_INFO 현재 값과 일치하지 않는 행을 필터링합니다(또는 애플리케이션 이외의 SQL 로그인이 데이터베이스에 직접 연결된 경우). 쿼리 최적화 프로그램은 이 함수를 Sales 테이블의 모든 SELECT, UPDATE 및 DELETE 쿼리에 위의 WHERE 조건자를 추가하는 것과 동일하게 적용됩니다.\n<h2>3단계: 보안 정책을 사용하여 테이블에 함수 바인딩</h2>\n마지막으로 Sales 테이블에서 이 함수를 필터 조건자로 바인딩하는 보안 정책을 만듭니다.\n<pre class=\"prettyprint\">CREATE SECURITY POLICY rls.tenantAccessPolicy\nADD FILTER PREDICATE rls.fn_tenantAccessPredicate(TenantId) ON dbo.Sales\nGO\n</pre>\n정말 간단하죠. 이제 행은 CONTEXT_INFO 현재 값을 기반으로 Sales 테이블의 쿼리에서 자동으로 필터링됩니다. 이를 확인하기 위해 저장 프로시저를 통해 CONTEXT_INFO 애플리케이션 설정을 시뮬레이션할 수 있습니다.\n<pre class=\"prettyprint\">EXECUTE sp_setContextInfoAsTenantId 1\nGO\nSELECT * FROM Sales\nGO\n</pre>\n테넌트 1의 행만 반환됩니다(이 경우 Book001만).\n<h2>모범 사례 및 다음 단계</h2>\nCONTEXT_INFO 통해 애플리케이션 사용자 컨텍스트를 데이터베이스에 전달하면 애플리케이션 사용자가 임의의 T-SQL(예: SQL 삽입을 통해)를 실행하여 CONTEXT_INFO 값을 변경하거나 다른 테넌트에 속한 행을 삽입할 수 없다고 가정합니다. 삽입 차단에 대한 기본 제공 지원은 이 버전의 RLS에 포함되지 않지만 트리거 또는 검사 제약 조건(향후 블로그 항목에서 설명)을 사용하거나 저장 프로시저를 통해 삽입을 제어하여 동등한 기능을 달성할 수 있습니다.\n\n또한 조건자 함수는 필요한 만큼 복잡할 수 있지만 함수 내에서 몇 개 이상의 테이블 조인을 포함하면 쿼리 성능이 저하됩니다.\n\n그렇다면 다음 단계는 무엇일까요? RLS에 대한 자세한 내용은 <a href=\"https://msdn.microsoft.com/library/dn765131.aspx\">온라인 미리 보기 설명서를 참조하세요</a>. 그렇지 않으면 아래에 질문과 의견을 게시하세요. 기능을 반복하고 진행하는 데 도움이 되는 피드백을 기다리고 있습니다.\n\n<b>전체 데모 스크립트</b>: RLS-Middle-Tier-Apps-Demo.sql은 <a href=\"https://rlssamples.codeplex.com/SourceControl/latest#RLS-Middle-Tier-Apps-Demo.sql\">여기에서</a> 찾을 수 있습니다<b>.</b>"
