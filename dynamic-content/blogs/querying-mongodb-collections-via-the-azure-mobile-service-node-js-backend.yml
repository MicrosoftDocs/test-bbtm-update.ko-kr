### YamlMime:Yaml
ms.openlocfilehash: 5fa031b24779642893374d60db5901793ce3a9c9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139897250"
Slug: querying-mongodb-collections-via-the-azure-mobile-service-node-js-backend
Title: Azure Mobile Service node.js 백 엔드를 통해 MongoDB 컬렉션 쿼리
Summary: 이전 게시물에서는 Azure Mobile Services node.js 백 엔드의 테이블을 사용하여 간단한 CRUD 작업을 위해 MongoDB 컬렉션과 통신하는 방법을 보여 줍니다. 이 게시물에서는 Mongo 데이터베이스에 대한 보다 복잡한 읽기 작업을 지원할 수 있도록 테이블 읽기 스크립트에 전달된 모든 OData 쿼리 매개 변수를 검색하는 방법을 제공합니다.
Content: "<a href=\"https://azure.microsoft.com/blog/2014/06/24/exposing-mongodb-collections-on-the-node-js-backend/\">이전 게시물</a>에서 Azure Mobile Services 테이블을 사용하여 Mongo 데이터베이스를 기본 SQL Azure 대신 스토리지 계층으로 사용하는 방법에 대해 설명했습니다. 게시물은 만들기, 업데이트, 삭제 및 간단한 읽기 작업을 구현하는 방법을 보여 주었지만 테이블 읽기 작업이 컬렉션의 항목 중 하나 또는 모두를 반환했기 때문에 쿼리 기능이 좋지 않았습니다. 이 게시물에서는 사용자가 전달한 쿼리 매개 변수를 가져올 수 있는 node.js 런타임의 문서화되지 않은 기능을 살펴보고 페이징, 정렬, 선택 및 일부 필터링에 대한 지원을 추가하여 node.js 모바일 서비스에서 MongoDB 컬렉션을 완전히(또는 대부분) 사용할 수 있도록 합니다.\n<h2>쿼리 구성 요소</h2>\nMongoDB 컬렉션을 쿼리하는 node.js 모바일 서비스를 보여 준 <a href=\"https://www.contentmaster.com/azure/using-windows-azure-mobile-services-with-a-mongodb-database/\">일부</a> 게시물이 있지만 쿼리는 사용자 지정 쿼리 문자열 매개 변수를 통해 수행되거나 코드 자체에서 하드 코딩됩니다. 그러나 클라이언트 애플리케이션에 대한 코드를 보다 자연스럽게 작성할 수 있도록 런타임에서 클라이언트가 보내는 <a href=\"https://www.odata.org/documentation/odata-version-2-0/uri-conventions\">OData 쿼리 매개 변수</a> 를 준수하는 것이 더 나은 환경입니다. 즉, 클라이언트는 다음 코드를 작성할 수 있어야 합니다.\n<pre class=\"prettyprint\">var table = client.GetTable&lt;Order&gt;();\nvar last10Orders = await table\n    .OrderByDescending(o =&gt; o.OrderDate)\n    .Take(10)\n    .ToListAsync();</pre>\n또한 Mongo 컬렉션을 쿼리할 때 런타임에서 이러한 옵션을 적용해야 합니다. 위의 코드는 HTTP 요청에 <code>/tables/order?$top=10&amp;$orderby=OrderDate desc</code>다음 쿼리 문자열을 보냅니다. 문제는 OData 쿼리 매개 변수('$'로 시작하는 매개 변수)가 읽기 스크립트의 <a href=\"https://msdn.microsoft.com/en-us/library/azure/jj554218.aspx\">요청 개체</a>에 있는 속성에 의해 <code>parameters</code> 노출되지 않는다는 것입니다. 그러나 이를 노출하는 <a href=\"https://msdn.microsoft.com/en-us/library/azure/jj613353.aspx\">쿼리 개체</a> 의 문서화되지 않은(이 블로그 게시물까지) 함수를 사용하여 읽기 작업에서 해당 함수를 검색하는 한 가지 방법이 있습니다 <code>getComponents</code>. 이를 통해 클라이언트에서 보낸 모든 OData 매개 변수(예: 건너뛰기/맨 위(페이징), 순서 지정, 선택 및 필터링)을 검색할 수 있습니다. 쿼리 구성 요소를 인쇄하도록 읽기 스크립트를 변경해 보겠습니다.\n<pre class=\"prettyprint\">function read(query, user, request) {\n    console.log(query.getComponents());\n    request.execute();\n}</pre>\n이제 위의 요청을 서버로 보내고 모바일 서비스에 대한 로그를 살펴보면 쿼리 구성 요소에서 얻을 수 있는 모든 정보가 표시됩니다.\n<pre class=\"prettyprint\">{ filters: null,\n  selections: [],\n  projection: null,\n  ordering: { OrderDate: false },\n  skip: null,\n  take: 10,\n  table: 'complexOrders',\n  context: undefined,\n  includeTotalCount: false,\n  version: 2 }</pre>\n구성 요소에는 스크립트에서 OData 쿼리 매개 변수를 읽는 데 필요한 모든 정보가 포함됩니다. 이제 사용을 시작하겠습니다.\n<h2>페이징(테이크/건너뛰기)</h2>\nMongo 컬렉션에서 여러 항목을 검색할 때의 내용을 보려면 이전 게시물로 돌아가 보겠습니다.\n<pre class=\"prettyprint\">function returnMultipleObjects(collection, query, mongoHelper, request) {\n    // TODO: look at query parameters. For now, return all items.\n    collection.find().toArray(function(err, items) {\n        if (err) {\n            console.log('error querying collection: ', err);\n            request.respond(200, { error: err });\n        } else {\n            items.forEach(function(item) {\n                mongoHelper.mongoIdToMobileServiceId(item);\n            });\n            request.respond(200, items);\n        }\n    });\n}</pre>\n<a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/collection.html#find\">collection.find 메서드</a>를 사용했으며, 쿼리 옵션 중 <code>limit</code> 에서 각각 OData 매개 변수와 <code>skip</code><code>$skip</code> 동일한 추가 매개 변수를 <code>$top</code> 사용할 수 있습니다. 또한 find 메서드에 이러한 옵션을 추가할 수 있습니다.\n<pre class=\"prettyprint\">function returnMultipleObjects(collection, query, mongoHelper, request) {\n    var findOptions = {};\n\n    var queryComponents = query.getComponents();\n\n    applyTopAndSkip(findOptions, queryComponents);\n    applyOrdering(findOptions, queryComponents);\n    applySelect(findOptions, queryComponents);\n    var findQuery = getFilterQuery(queryComponents, request);\n    if (findQuery === null) {\n        // response already sent\n        return;\n    }\n\n    collection.find({}, findOptions).toArray(function(err, items) {\n        if (err) {\n            console.log('error querying collection: ', err);\n            request.respond(200, { error: err });\n        } else {\n            items.forEach(function(item) {\n                mongoHelper.mongoIdToMobileServiceId(item);\n            });\n            request.respond(200, items);\n        }\n    });\n\n    function applyTopAndSkip(findOptions, queryComponents) {\n        if (queryComponents.take) {\n            findOptions.limit = queryComponents.take;\n        }\n\n        if (queryComponents.skip) {\n            findOptions.skip = queryComponents.skip;\n        }\n    }\n\n    function applySelect(findOptions, queryComponents) { }\n    function applyOrdering(findOptions, queryComponents) { }\n    function applyFilter(queryComponents, request) { }\n    function getFilterQuery(queryComponents, request) { return {}; }\n}</pre>\n이제 요청을 <code>/tables/order?$skip=3&amp;$top=5</code>보내면 처음 3개 문서를 건너뛰고 5개의 문서만 받게 됩니다(기본 컬렉션 순서로 곧 정렬될 예정임). 한 가지 더 참고: 요청에 쿼리 매개 변수가 포함되어 <code>$top</code> 있지 않으면 값 <code>queryComponents.take</code> 이 0이 아니므로(node.js 런타임에서 반환되는 기본 최대 항목 수인 50의 값이 있음) 찾기 옵션에서 제한을 정의할 때 해당 값을 확인하는 것이 안전합니다.\n<h2>순서 지정</h2>\n페이징(skip/take)을 사용하면 페이징이 수행되는 순서를 정의할 수 있을 때 더 강력합니다. 예를 들어 클라이언트 이름 또는 주문 날짜를 기준으로 페이징합니다. 쿼리 구성 요소의 출력에서 볼 수 있듯이 순서는 필드를 나타내는 키와 요청된 순서가 오름차순인지 내림차순인지를 나타내는 부울 값과 함께 개체로 지정됩니다. 그런 다음 MongoDB 노드 패키지(필드 이름/순서가 지정된 배열)에서 필요한 형식으로 해당 형식이 필요합니다.\n<pre class=\"prettyprint\">function applyOrdering(findOptions, queryComponents) {\n    var orderBy = [];\n    var ordering = queryComponents.ordering;\n    for (var orderField in ordering) {\n        if (ordering.hasOwnProperty(orderField)) {\n            var ascending = queryComponents.ordering[orderField] ? 'ascending' : 'descending';\n            orderBy.push([ orderField, ascending ]);\n        }\n    }\n\n    if (orderBy.length) {\n        findOptions.sort = orderBy;\n    }\n}</pre>\n이제 이 게시물 <code>/tables/order?$top=10&amp;orderby=orderDate desc</code>의 시작 부분에 표시된 코드 조각을 실행할 수 있습니다.\n<h2>선택 영역</h2>\nMongoDB 문서(및 일반적으로 데이터베이스에 저장된 엔터티)에는 필요한 것보다 더 많은 정보(속성/열)가 있는 경우가 많으며, 모든 문서를 검색하는 것은 비일관적인 비용(대역폭 및 처리)입니다. OData 및 MongoDB는 검색할 필드 선택을 지원하며, 쿼리 구성 요소를 MongoDB 노드 드라이버가 예상하는 형식으로 다시 한 번 매핑할 수 있습니다.\n<pre class=\"prettyprint\">function applySelect(findOptions, queryComponents) {\n    var selects = queryComponents.selections;\n    if (selects &amp;&amp; selects.length) {\n        if (selects.length === 1 &amp;&amp; selects[0] === '*') {\n            // Same as no $select, nothing to do\n        } else {\n            findOptions.fields = {};\n            selects.forEach(function(field) {\n                findOptions.fields[field] = 1;\n            });\n        }\n    }\n}</pre>\n이제 마지막 10개 주문의 클라이언트 이름만 있으면 다음 <code>/tables/order?$top=10&amp;$orderby=orderDate desc&amp;$select=client</code>을 수행할 수 있습니다.\n<h2>필터링</h2>\n종종 컬렉션의 모든 요소를 요청하는 대신(페이징된 경우에도) 클라이언트는 특정 조건과 일치하는 특정 문서만 요청합니다. 예를 들어 'J' 문자로 시작하는 클라이언트에 대한 주문만 원합니다.\n<pre class=\"prettyprint\">var table = Client.GetTable&lt;Order&gt;();\nvar items = await table\n    .Where(o =&gt; o.Client.StartsWith(\"J\"))\n    .OrderByDescending(o =&gt; o.OrderDate)\n    .Take(10)\n    .ToListAsync();</pre>\n위의 필터는 $filter OData 쿼리 매개 변수로 서버에 <code>/tables/order?$top=10&amp;$orderby=orderDate desc&amp;$filter=startswith(client,'J')</code>전송됩니다. 쿼리 구성 요소를 기록하면 아래와 같이 필터 개체의 'queryString' 값에 필터 식이 표시됩니다. 필터(인수, 형식)에는 다른 속성이 있지만 이 시나리오에서는 사용되지 않습니다(OData와 쿼리 문자열을 변환하는 코드는 서버 런타임과 JavaScript 클라이언트 SDK 간에 공유되며 클라이언트에서만 사용됩니다.)\n<pre class=\"prettyprint\">{ filters: \n   { queryString: 'startswith(client,\\'J\\')',\n     args: [],\n     type: 'LiteralExpression' },\n  selections: [],\n  projection: null,\n  ordering: { orderDate: false },\n  skip: 0,\n  take: 10,\n  table: 'complexOrders',\n  context: undefined,\n  includeTotalCount: false,\n  version: 4 }</pre>\n이제 필터를 사용하여 node.js MongoDB 라이브러리의 <a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/collection.html#find\">collection.find 메서드</a> 에 전달할 수 있습니다. 하지만 필터는 문자열로 지정되므로 필터를 구문 분석하고 노드 드라이버에서 예상하는 적절한 형식으로 변환하는 것은 우리에게 달려 있습니다. 여기서는 몇 가지 구문(단순 이진 연산자, 'startswith' 함수)을 지원하는 방법을 보여 주지만, 완전한 구현은 쿼리 문자열을 식 트리로 구문 분석하고 이를 트래버스하여 동등한 MongoDB 쿼리 개체를 만들어야 하지만 이 게시물의 범위를 벗어나게 됩니다(주로 쿼리 구성 요소 기능을 도입하는 것이었습니다).\n<pre class=\"prettyprint\">function getFilterQuery(queryComponents, request) {\n    // Simple case: filter that excludes everything; no need to talk to the DB\n    if (queryComponents.filters &amp;&amp; queryComponents.filters.queryString === 'false') {\n        request.respond(200, []);\n        return null;\n    }\n\n    var findQuery = convertFilter(queryComponents.filters);\n    if (findQuery === null) {\n        request.respond(500, { error: 'Unsupported filter: ' + queryComponents.filters.queryString });\n        return null;\n    }\n\n    return findQuery;\n}\n\nfunction convertFilter(filters) {\n    var findQuery = {};\n\n    var startsWith = [ /^startswith\\(([^,]+),\\'([^\\']+)\\'\\)/, function(p) {\n        var field = p[1];\n        var value = p[2];\n        var result = {};\n        result[field] = new RegExp('^' + value);\n        return result;\n    } ];\n\n    var binaryOperator = [ /^\\(([^\\s]+)\\s+([^\\s]{2})\\s(.+)$/, function(p) {\n        var field = p[1];\n        var operator = p[2];\n        var value = p[3].slice(0, -1); // remove ending ')'\n        if (/datetime\\'\\d{4}-\\d{2}-\\d{2}T\\d{2}\\:\\d{2}\\:\\d{2}\\.\\d{3}Z\\'/.test(value)) {\n            // Date literal\n            value = new Date(Date.parse(value.slice(9, -1)));\n        } else if (/^\\'.+\\'$/.test(value)) {\n            // String literal\n            value = value.slice(1, -1);\n        } else {\n            // Number\n            value = parseFloat(value);\n        }\n\n        var result = {};\n        if (operator === 'eq') {\n            result[field] = value;\n        } else {\n            result[field] = {};\n            result[field]['$' + operator] = value;\n        }\n        return result;\n    } ];\n\n    var supportedFilters = [startsWith, binaryOperator];\n\n    if (filters) {\n        // Easy cases\n        if (filters.queryString === 'true') {\n            return {};\n        }\n\n        var foundMatch = false;\n        for (var i = 0; i &lt; supportedFilters.length; i++) {\n            var match = filters.queryString.match(supportedFilters[i][0]);\n            if (match) {\n                findQuery = supportedFilters[i][1](match);\n                foundMatch = true;\n                break;\n            }\n        }\n\n        if (!foundMatch) {\n            return null;\n        }\n    }\n\n    return findQuery;\n}</pre>\n이제 지원되는 모든 모바일 서비스 클라이언트 SDK를 사용하여 MongoDB에서 상당히 복잡한 쿼리를 실행할 수 있습니다.\n<h2>요약</h2>\n이 게시물에서는 읽기 스크립트가 OData 쿼리 매개 변수에 액세스할 수 있도록 하는 <a href=\"https://msdn.microsoft.com/en-us/library/azure/jj613353.aspx\">쿼리 개체</a> 에 문서화되지 않은 기능과 이를 사용하여 MongoDB 컬렉션에 복잡한 쿼리를 수행하는 방법을 보여 줍니다. 기능을 개선할 수 있지만(예: 필터 필터링 변환에 대한 더 나은 지원) 모든 클라이언트가 다른 백 엔드 스토리지에 지원하는 것과 동일한 테이블 추상화 확장을 위해 이 게시물(및 이전) 게시물에서 사용한 시나리오를 사용할 수 있습니다.\n\n이 게시물에 대한 전체 코드를 얻으려면 내 <a href=\"https://github.com/carlosfigueira/blogsamples/tree/master/AzureMobileServices/MongoDbOnNodeBackend/ComplexQueryTests/ComplexQueries\">블로그 샘플 리포지토리</a>에서 찾을 수 있습니다. 언제나처럼, 이 게시물의 댓글 섹션 또는 <a href=\"https://social.msdn.microsoft.com/Forums/windowsazure/en-US/home?forum=azuremobile\">MSDN 포럼</a>에서 의견 / 제안을 자유롭게 남겨 주시기 바랍니다."
