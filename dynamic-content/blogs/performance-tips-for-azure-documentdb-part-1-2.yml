### YamlMime:Yaml
ms.openlocfilehash: 9123bac3710592a8c0583e628496b97bda68c8ea
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139900978"
Slug: performance-tips-for-azure-documentdb-part-1-2
Title: Azure DocumentDB에 대한 성능 팁 - 1부
Summary: Azure DocumentDB의 성능에 영향을 주는 여러 영역을 다루는 두 부분으로 구성된 블로그 게시물 시리즈를 준비했습니다.
Content: "<p><strong>2016년 8월 5일 현재 업데이트:</strong> 이제 성능 팁이 DocumentDB 설명서 문서에 <em><a href=\"https://azure.microsoft.com/documentation/articles/documentdb-performance-tips/\">대한 성능 팁</a></em> 에서 문서화되고 업데이트됩니다.</p>\n\n<p><b>Azure DocumentDB 1부 Azure DocumentDB &ndash; 에 대한 성능 팁</b> <a href=\"https://azure.com/docdb\"></a> 애플리케이션의 요구 사항을 가장 잘 충족하도록 데이터베이스 성능을 최적화할 수 있습니다.&nbsp; Weve&rsquo;는 Azure DocumentDB의 성능에 영향을 주는 여러 영역을 다루는 두 부분으로 구성된 블로그 게시물 시리즈를 준비했습니다. 1부에서는 DocumentDB에서 사용할 수 있는 네트워킹 및 SDK 구성 옵션과 해당 옵션이 성능에 미치는 영향을 살펴봅합니다. <a href=\"https://azure.microsoft.com/blog/2015/01/27/performance-tips-for-azure-documentdb-part-2/\">2부</a>에서는 인덱싱 정책, 처리량 최적화 및 일관성 수준을 다룹니다.&nbsp; 다른 성능 튜닝 권장 사항과 마찬가지로 이러한 팁 중 일부가 사용 사례에 적용할 수 있는 것은 아니지만 이 정보를 가이드로 사용하여 애플리케이션에 적합한 디자인 선택을 할 수 있습니다.</p>\n\n<h1>네트워킹</h1>\n\n<p><b>네트워킹 팁 #1 연결 정책 - 성능 향상을 위해 직접 연결 모드 사용</b> 먼저 연결&rsquo; 정책을 살펴보겠습니다. 클라이언트의 Azure DocumentDB에 연결하는 방법은 성능, 특히 관찰된 클라이언트 쪽 대기 시간 면에서 중요한 영향을 줍니다. 클라이언트 연결 정책 &ndash; 연결 <i>모드</i> 와 연결 <i>프로토콜</i>을 구성하는 데 사용할 수 있는 두 가지 주요 구성 설정이 있습니다.&nbsp; 사용 가능한 두 가지 모드는 다음과 같습니다.</p>\n\n<ol>\n <li>게이트웨이 모드(기본값)</li>\n <li>직접 모드</li>\n</ol>\n\n<p>DocumentDB는 분산 스토리지 시스템이므로 컬렉션 및 문서와 같은 DocumentDB 리소스는 여러 머신에서 분할되고 각 파티션은 고가용성을 위해 복제됩니다. 논리적-물리적 주소 변환이 유지되는 라우팅 테이블도 내부적으로 리소스로 사용할 수 있습니다. 게이트웨이 모드에서 DocumentDB 게이트웨이 컴퓨터는 이 라우팅을 수행하므로 클라이언트 코드가 간단하고 간결해집니다. 클라이언트 애플리케이션은 요청의 논리적 URI를 백 엔드 노드의 실제 주소로 변환하고 요청을 적절하게 전달하는 DocumentDB 게이트웨이 머신에 요청을 실행합니다.&nbsp; 반대로 직접 모드에서 클라이언트는 이 라우팅 테이블의 복사본을 유지 관리 &ndash; 및 주기적으로 새로 고친 &ndash; 다음 백 엔드 DocumentDB 노드에 직접 연결해야 합니다. 게이트웨이 모드는 모든 SDK 플랫폼에서 지원되며 구성된 기본값입니다.&nbsp; 애플리케이션이 엄격한 방화벽 제한으로 회사 네트워크 내에서 실행되는 경우 게이트웨이 모드는 표준 HTTPS 포트 및 단일 엔드포인트를 사용하기 때문에 가장 적합합니다. 그러나 성능 절충은 데이터를 DocumentDB에 읽거나 쓸 때마다 게이트웨이 모드에 추가 네트워크 홉이 포함된다는 것입니다.&nbsp;&nbsp; 이 때문에 직접 모드는 네트워크 홉 수가 적기 때문에 더 나은 성능을 제공합니다. <i>직접 모드는 현재 .NET SDK에서만 지원되지만 후속 SDK 새로 고침을 사용하는 다른 플랫폼에서 사용할 수 있습니다</i><i>.&nbsp; 클라이언트 연결 옵션에 대한 자세한 내용은 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/documentdb-interactions-with-resources/\">여기</a>를 참조하세요.</i> <b>네트워킹 팁 #2 연결 정책 - 성능 향상을 위해 TCP 프로토콜 사용</b> 직접 모드를 활용하는 경우 다음 두 가지 프로토콜 옵션을 사용할 수 있습니다.</p>\n\n<ol>\n <li>TCP</li>\n <li>HTTPS</li>\n</ol>\n\n<p>DocumentDB는 HTTP를 통해 단순한 개방형 RESTful 프로그래밍 모델을 제공합니다. 또한 통신 모델에서도 RESTful이며 .NET 클라이언트 SDK를 통해 사용할 수 있는 효율적인 TCP 프로토콜을 제공합니다. 최상의 성능을 위해 가능한 경우 TCP 프로토콜을 사용 합니다. 연결 모드는 ConnectionPolicy 매개 변수로 DocumentClient 인스턴스를 생성하는 도중 구성됩니다. 직접 모드를 사용하는 경우 ConnectionPolicy 매개 변수 내에서 프로토콜을 설정할 수도 있습니다.</p>\n\n<pre class=\"prettyprint\">\n            var serviceEndpoint = new Uri(&quot;https://contoso.documents.net&quot;);\n            var authKey = new &quot;your authKey from Azure Mngt Portal&quot;;\n            DocumentClient client = new DocumentClient(serviceEndpoint, authKey, \n            new ConnectionPolicy\n            {\n                ConnectionMode = ConnectionMode.Direct,\n                ConnectionProtocol = Protocol.Tcp\n            });</pre>\n\n<p><i>TCP는 직접 모드에서만 지원되기 때문에, 게이트웨이 모드를 사용하는 경우 게이트웨이와 통신하는 데 항상 HTTPS 프로토콜을 사용하고 ConnectionPolicy의 프로토콜 값은 무시됩니다.</i> <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ConnectionPolicy.png\"><img alt=\"ConnectionPolicy\" height=\"338\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ConnectionPolicy.png\" width=\"623\"></a><em>연결 정책 설명</em> <b>네트워킹 팁 #3: 첫 번째 요청에서 시작 대기 시간을 방지하기 위해 OpenAsync를 호출</b>합니다. 기본적으로 첫 번째 요청은 주소 라우팅 테이블을 가져와야 하므로 대기 시간이 더 짧아집니다. 첫 번째 요청에서 이 시작 대기 시간을 방지하려면 다음과 같이 초기화 중에 OpenAsync()를 한 번 호출해야 합니다.</p>\n\n<pre class=\"prettyprint\">\nawait client.OpenAsync();</pre>\n\n<p><b>네트워킹 팁 #4: 성능을 위해 동일한 Azure 지역에 클라이언트 배치</b> DocumentDB에 요청을 하고 응답을 받는 사이에 네트워크 대기 시간이 더 많이 발생할 수 있습니다. 이 대기 시간은 클라이언트에서 Azure 데이터 센터 경계로의 요청에 의해 수행되는 경로에 따라 요청마다 다를 수 있습니다. 호출 애플리케이션이 프로비전된 DocumentDB 엔드포인트와 동일한 Azure 지역 내에 있는지 확인하여 가능한 가장 낮은 대기 시간을 달성할 수 있습니다. <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/DeploymentConsiderations.png\"><img alt=\"DeploymentConsiderations\" height=\"279\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/DeploymentConsiderations.png\" width=\"517\"></a><em> 설명된 배포 고려 사항</em></p>\n\n<h1>SDK 사용</h1>\n\n<p><b>SDK 사용 팁 #1: 애플리케이션 수명 동안 Singleton DocumentDB 클라이언트 사용</b> 각 DocumentClient 인스턴스는 스레드로부터 안전하며 직접 모드에서 작동할 때 효율적인 연결 관리 및 주소 캐싱을 수행합니다. DocumentClient에 의해 연결을 효율적으로 관리하고 성능을 개선하려면 애플리케이션 수명 동안 AppDomain당 DocumentClient의 단일 인스턴스를 사용하는 것이 좋습니다. <b>SDK 사용 팁 #2: 읽기 대기 시간을 낮추기 위해 문서 및 컬렉션 SelfLink 캐시</b> Azure DocumentDB에서 각 문서에는 시스템 생성 selfLink가 있습니다. 이러한 selfLinks는 문서의 수명 동안 고유하고 변경할 수 없음을 보장합니다. selfLink를 사용하여 단일 문서를 읽는 것이 단일 문서를 가져오는 가장 효율적인 방법입니다. selfLink의 불변성으로 인해 최상의 읽기 성능을 위해 가능하면 언제든지 selfLinks를 캐시해야 합니다.</p>\n\n<pre class=\"prettyprint\">\nDocument document = await client.ReadDocumentAsync(&quot;/dbs/1234/colls/1234354/docs/2332435465&quot;);</pre>\n\n<p>즉, 응용 프로그램이 읽기 시나리오를 위해 문서&rsquo; selfLink로 작업하는 것이 항상 가능하지는 않을 수 있습니다. 이 경우 문서를 검색하는 다음으로 가장 효율적인 방법은 사용자가 제공한 Id 속성을 사용하여 문서를&rsquo; 쿼리하는 것입니다.&nbsp; 예를 들어:</p>\n\n<pre class=\"prettyprint\">\nIDocumentQuery&lt;Document&gt; query = (from doc in client.CreateDocumentQuery(colSelfLink) where doc.Id == &quot;myId&quot; select document).AsDocumentQuery(); \n            Document myDocument = null;\n            while (query.HasMoreResults)\n            {\n                FeedResponse&lt;Document&gt; res = await query.ExecuteNextAsync&lt;Document&gt;();\n                if (res.Count != 0) {\n                    myDocument = res.Single();\n                    break;\n                }\n           }</pre>\n\n<p><b>SDK 사용 팁 #3: 성능 향상을 위해 쿼리/읽기 피드에 대한 페이지 크기 조정</b> 읽기 피드 기능(예: ReadDocumentFeedAsync)을 사용하거나 DocumentDB SQL 쿼리를 실행하는 경우 결과 집합이 너무 크면 결과가 분할된 방식으로 반환됩니다. 기본적으로, 100개의 항목 또는 1MB 단위(둘 중 먼저 도달하는 단위)로 결과가 반환됩니다. 적용 가능한 모든 결과를 검색하는 데 필요한 네트워크 왕복 수를 줄이기 위해 x-ms-max-item-count 요청 헤더를 사용하여 페이지 크기를 최대 1,000개로 늘릴 수 있습니다. 예를 들어 사용자 인터페이스 또는 애플리케이션 API가 한 번에 10개의 결과만 반환하는 경우 몇 가지 결과만 표시해야 하는 경우 읽기 및 쿼리에 사용되는 처리량을 줄이기 위해 페이지 크기를 10으로 줄일 수도 있습니다. 사용 가능한 DocumentDB SDK를 사용하여 페이지 크기를 설정할 수도 있습니다.&nbsp; 예를 들어:</p>\n\n<pre class=\"prettyprint\">\nIQueryable&lt;dynamic&gt; authorResults =\nclient.CreateDocumentQuery(documentCollection.SelfLink, &quot;SELECT p.Author FROM Pages p WHERE p.Title = &#39;About Seattle&#39;&quot;, new FeedOptions { MaxItemCount = 1000 });</pre>\n\n<h1>요약</h1>\n\n<p>이러한 팁 중 하나 이상이 DocumentDB 사용에 유용하고 적용 가능한 것을 발견했으면 합니다.&nbsp; 이 블로그 시리즈의 <a href=\"https://azure.microsoft.com/blog/2015/01/27/performance-tips-for-azure-documentdb-part-2/\">2부</a>에서는 인덱싱 정책, 처리량 최적화 및 일관성 수준에 대해 계속 설명합니다.&nbsp; 또한, 가장&rsquo; 가치 있는 DocumentDB 기능 및 환경에 대한 의견을 듣고 싶어합니다.&nbsp; Microsoft Azure DocumentDB <a href=\"https://feedback.azure.com/forums/263030-documentdb?filter=top&amp;page=1\">피드백 포럼</a>에서 제안을 제출하세요.&nbsp; DocumentDB를 아직 시도하지 않은&rsquo; 경우 <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\">여기에서</a> 시작합니다.</p>"
