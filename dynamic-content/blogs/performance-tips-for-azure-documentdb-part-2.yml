### YamlMime:Yaml
ms.openlocfilehash: 3217081424b9117dc2f231af94f2f77b616ae81d
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907613"
Slug: performance-tips-for-azure-documentdb-part-2
Title: Azure DocumentDB에 대한 성능 팁 - 2부
Summary: 이 게시물은 토론을 계속하고 인덱싱 정책, 처리량 최적화 및 일관성 수준의 성능 영향을 다룹니다.
Content: >-
  <div style="background: rgb(238, 238, 238); padding: 5px 10px; border: 1px solid rgb(204, 204, 204); border-image: none;"><strong>2016년 8월 5일 현재 업데이트:</strong> 이제 <em><a href="https://azure.microsoft.com/documentation/articles/documentdb-performance-tips/">DocumentDB 설명서 문서의 성능 팁에서 성능 팁을</a></em> 문서화하고 업데이트합니다.</div>


  <p><b>Azure DocumentDB 2부 Azure DocumentDB &ndash; 에 대한 성능 팁</b> <a href="https://azure.com/docdb"></a> 애플리케이션의 요구 사항을 가장 잘 충족하도록 데이터베이스 성능을 조정할 수 있습니다.&nbsp; 이 시리즈의 <a href="https://azure.microsoft.com/blog/2015/01/20/performance-tips-for-azure-documentdb-part-1-2/">1부</a>에서는 DocumentDB에서 사용할 수 있는 네트워킹 및 SDK 구성 옵션과 성능에 미치는 영향을 살펴보았습니다. 이 게시물은 토론을 계속하고 인덱싱 정책, 처리량 최적화 및 일관성 수준의 성능 영향을 다룹니다.&nbsp; 성능 튜닝 권장 사항과 마찬가지로 이러한 팁 중 하나라도 사용 사례에 적용할 수 있는 것은 아니지만 이 정보를 가이드로 사용하여 애플리케이션에 적합한 디자인을 선택할 수 있도록 지원할 수 있습니다.</p>


  <h1>인덱싱 정책</h1>


  <p><b>인덱싱 정책 팁 #1: 빠른 피크 시간 수집 속도를 위해 지연 인덱싱 사용</b> DocumentDB를 사용하면 컬렉션 수준에서 &ndash; 인덱싱 정책을 지정할 &ndash; 수 있으므로 컬렉션의 문서를 자동으로 인덱싱할지 여부를 선택할 수 있습니다.&nbsp; 또한 동기(일관성)와 비동기(지연) 인덱스 업데이트 중에서 선택할 수도 있습니다. 기본적으로 컬렉션의 문서를 삽입하거나 바꾸거나 삭제할 때마다 인덱스가 동기적으로 업데이트됩니다. 이렇게 하면 쿼리가 인덱스를 따라 잡기 위해 지연 없이 문서 읽기와 동일한 <a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-consistency-levels/">일관성 수준을</a> 적용할 수 &ldquo;있습니다&quot;. 지연 인덱싱은 데이터가 갑자기 작성되는 시나리오에 대해 고려할 수 있으며, 오랜 시간 동안 콘텐츠를 인덱싱하는 데 필요한 작업을 분할하고자 합니다. 이렇게 하면 프로비전된 처리량을 효과적으로 사용하고 대기 시간을 최소화하면서 사용량이 많은 시간에 쓰기 요청을 제공할 수 있습니다. 반면 지연 인덱싱을 사용할 경우 쿼리 결과는 DocumentDB 계정에 대해 구성된 일관성 수준에 관계없이 일관성을 지니게 됩니다. 따라서 일관된 인덱싱 모드(IndexingPolicy.IndexingMode가 Consistent로 설정됨)는 한 번 쓰는 데 가장 높은 요청 단위 요금이 부과되고, 지연 인덱싱 모드(IndexingPolicy.IndexingMode는 Lazy로 설정됨)와 인덱싱 없음 모드(IndexingPolicy.Automatic이 False로 설정됨)는 쓰는 시간에 대한 인덱싱 비용이 없습니다. <b>인덱싱 정책 팁</b><b> #2: 더 빠른 쓰기를 위해 인덱싱에서 사용되지 않는 경로 제외</b> DocumentDBs&rsquo; 인덱싱 정책을 사용하면 인덱싱 경로(IndexingPolicy.IncludedPaths 및 IndexingPolicy.ExcludedPaths)를 활용하여 인덱싱에서 포함하거나 제외할 문서 경로를 지정할 수도 있습니다. 인덱싱 경로의 사용은 인덱싱 비용이 인덱싱된 고유 경로 수와 직접 상관 관계가 있으므로 쿼리 패턴을 미리 알려진 시나리오에 대해 향상된 쓰기 성능 및 낮은 인덱스 스토리지를 제공할 수 있습니다.&nbsp; 예를 들어:</p>


  <pre class="prettyprint">

  //exclude index paths


  collection.IndexingPolicy.ExcludedPaths.Add(&quot;/\&quot;metaData\&quot;/*&quot;); collection.IndexingPolicy.ExcludedPaths.Add(&quot;/\&quot;subDoc\&quot;/\&quot;subSubDoc\&quot;/\&quot;someProperty\&quot;/*&quot;);

  collection = await client.CreateDocumentCollectionAsync(databaseLink, collection);</pre>


  <p><b>인덱싱 정책 </b><b>팁 #3: 현재 DocumentDB에서 지원하는 범위 쿼리에 사용되는 모든 경로에 대해 범위 인</b> 덱스 경로 유형을 지정합니다. 해시 및 범위입니다. 해시의 인덱스 경로 형식을 선택하면 효율적인 같음 쿼리가 가능합니다. 범위의 인덱스 유형을 선택하면 범위 쿼리(using&gt;, , &gt;&lt;=, &lt;=)를 사용할 수 있습니다.&nbsp;&nbsp; 예를 들어:</p>


  <pre class="prettyprint">

  var collection = new DocumentCollection

  {
        Id = ConfigurationManager.AppSettings[&quot;CollectionId&quot;]
  };


  collection.IndexingPolicy.IncludedPaths.Add(new IndexingPath

  {
         IndexType = IndexType.Hash,
         Path = &quot;/&quot;,
  });


  collection.IndexingPolicy.IncludedPaths.Add(new IndexingPath

  {
         IndexType = IndexType.Range,
         Path = @&quot;/&quot;&quot;shippedTimestamp&quot;&quot;/?&quot;,
         NumericPrecision = 7
  });


  collection = await client.CreateDocumentCollectionAsync(databaseLink, collection);</pre>


  <p><b>인덱싱 정책 </b><b>팁 #4: 쓰기 및 쿼리 성능 및 스토리지 절충에 대한 인덱스 정밀도를 변경</b> 합니다. 마지막으로 인덱싱 정책을 사용하면 인덱스 경로 정밀도를 바이트 단위로 변경하여 쿼리 성능을 향상시킬 수 있습니다. 더 높은 정밀도로 인덱싱된 경로에 대한 쿼리는 일반적으로 더 빠르지만 인덱스에 대한 스토리지 오버헤드가 더 높습니다. 반대로 정밀도를 낮추면 쿼리 실행 중에 더 많은 문서를 처리해야 하지만 스토리지 오버헤드가 낮아집니다. 인덱싱 정책에 대한 자세한 내용은 <a href="https://azure.microsoft.com/en-us/documentation/articles/documentdb-indexing-policies/">이</a> 설명서를 참조하세요.</p>


  <blockquote><b>참고:</b> 현재 미리 보기 릴리스에서 컬렉션에 대한 인덱스 정책은 컬렉션을 만들 때만 지정할 수 있습니다.</blockquote>


  <h1>처리량</h1>


  <p><b>처리량 팁 #1: 낮은 요청 단위/초 사용량에 대한 측정 및 조정</b> DocumentDB는 UDF를 사용하는 관계형 및 계층적 쿼리, 저장 프로시저 및 데이터베이스 컬렉션 내의 문서에서 작동하는 모든 트리거 &ndash; 를 비롯한 다양한 데이터베이스 작업 집합을 제공합니다. 이러한 각 작업과 관련된 비용은 작업을 완료하는 데 필요한 CPU, IO 및 메모리에 따라 달라집니다. 하드웨어 리소스를 고려하고 관리하는 대신 다양한 데이터베이스 작업을 수행하고 애플리케이션 요청을 처리하는 데 필요한 리소스의 단일 측정값으로 RU(요청 단위)를 고려할 수 있습니다. 요청 단위는 구매한 용량 단위 수에 따라 각 데이터베이스 계정에 대해 프로비전됩니다. 요청 단위 소비는 초당 비율로 평가됩니다. 계정에 대해 프로비전된 요청 단위 속도를 초과하는 애플리케이션은 요금이 계정에 대한 예약된 수준 아래로 떨어질 때까지 제한됩니다. 애플리케이션에 더 높은 처리량 수준이 필요한 경우 추가 용량 단위를 구매할 수 있습니다. 쿼리의 복잡성은 작업에 사용되는 요청 단위의 양에 영향을 줍니다. 조건자의 수, 조건자의 특성, UDF 수 및 원본 데이터 집합의 크기는 모두 쿼리 작업의 비용에 영향을 줍니다. 모든 작업의 오버헤드를 측정하려면(만들기, 업데이트 또는 삭제) <b>x-ms-request-charge </b>헤더(또는 .NET SDK의 ResourceResponseT&lt; 또는 FeedResponseT&gt;&lt;&gt;에서 해당하는 RequestCharge 속성)를 검사하여 이러한 작업에서 사용되는 요청 단위 수를 측정합니다.</p>


  <pre class="prettyprint">

  // Measure the performance (request units) of writes


  ResourceResponse&lt;Document&gt; response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);


  Console.WriteLine(&quot;Insert of document consumed {0} request units&quot;, response.RequestCharge);


  // Measure the performance (request units) of queries


  IDocumentQuery&lt;dynamic&gt; queryable = client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();


  while (queryable.HasMoreResults)
       {

            FeedResponse&lt;dynamic&gt; queryResponse = await queryable.ExecuteNextAsync&lt;dynamic&gt;();

            Console.WriteLine(&quot;Query batch consumed {0} request units&quot;, queryResponse.RequestCharge);
       }</pre>

  <p>이 헤더에 반환된 요청 요금은 프로비전된 처리량(예: 2000RU/초)의 일부입니다.&nbsp;&nbsp; 예를 들어 위의 쿼리가 1,000개의 1KB 문서를 반환하는 경우 작업 비용은 1000입니다. 따라서 1초 이내에 서버는 후속 요청을 제한하기 전에 두 개의 요청만 적용합니다. <b>처리량 팁 #2: 서버 제한 처리/요청 속도가 너무 큽니다&nbsp;</b>. 클라이언트가 계정에 대한 예약된 처리량을 초과하려고 하면 서버에서 성능 저하가 없고 예약된 수준 이상의 처리량 용량을 사용하지 않습니다. 서버에서 RequestRateTooLarge(HTTP 상태 코드 429)를 사용하여 선제적으로 요청을 종료하고, 사용자가 요청을 다시 시도할 수 있을 때까지 기다려야 하는 시간을 밀리초 단위로 표시하는 x-ms-retry-after-ms 헤더를 반환합니다.</p>


  <blockquote>HTTP 상태 429, 상태 줄: RequestRateTooLarge x-ms-retry-after-ms :100</blockquote>


  <p>.NET 클라이언트 SDK 및 LINQ 쿼리를 사용하는 경우에는 거의 대부분 이 예외를 처리할 필요가 없습니다. .NET 클라이언트 SDK 최신 버전이 이 응답을 암시적으로 catch하고, 서버에서 지정한 retry-after 헤더를 준수하고, 요청을 다시 시도하기 때문입니다. 동시에 여러 클라이언트가 계정에 액세스하지만 않으면 다음 재시도가 성공할 것입니다. 두 개 이상의 클라이언트가 요청 속도보다 지속적으로 지속적으로 작동하는 경우 .NET 클라이언트에서 현재 3으로 설정된 기본 재시도는 충분하지 않을 수 있습니다. 이 경우 클라이언트는 상태 코드가 429인 DocumentClientException을 애플리케이션에 throw합니다. .NET SDK의 현재 릴리스에서는 기본 재시도 횟수를 해제할 방법이 없습니다. 자동화된 재시도 동작은 대부분의 애플리케이션에 대한 복원력 및 유용성을 개선하는 데 도움이 되지만, 특히 대기 시간을 측정할 때 성능 벤치마크를 수행할 때 발생할 수 있습니다.&nbsp; 실험이 서버 스로틀에 도달하고 클라이언트 SDK가 자동으로 다시 시도하게 되면 클라이언트에서 관찰된 대기 시간이 급증합니다. 성능 실험 중 대기 시간 급증을 방지하려면, 각 작업에 의해 반환된 비용을 측정하고 요청이 예약된 요청 속도 이하로 작동하고 있는지 확인합니다. <b>처리량 팁 #3: 빈 컬렉션을 삭제하여 프로비전된 모든 처리량을 활용</b> 합니다. DocumentDB 계정에서 만든 모든 문서 컬렉션은 프로비전된 CPU(용량 단위) 수 및 생성된 컬렉션 수에 따라 예약된 처리량 용량을 할당합니다.&nbsp;&nbsp; 단일 CU를 사용하면 RU(요청 단위)를 2,000개 사용할 수 있으며 최대 3개의 컬렉션을 지원합니다. CU에 대해 하나의 컬렉션만 만들어지면 전체 CU 처리량을 컬렉션에 사용할 수 있습니다. 두 번째 컬렉션이 만들어지면 첫 번째 컬렉션의 처리량이 절반으로 줄어들고 두 번째 컬렉션에 지정됩니다. 추가 CPU를 프로비전하면 기존 컬렉션에 대한 처리량을 늘릴 수 있습니다. DocumentDB 미리 보기 중에 단일 컬렉션은 최대 10GB까지 확장할 수 있으며 단일 CU의 최대 처리량(초당 요청 단위 2,000개)까지 할당할 수 있습니다. 컬렉션당 사용 가능한 처리량을 최대화하려면 컬렉션에 대한 용량 단위 수가 1:1인지 확인합니다. <b>처리량 팁 #4: 더 높은 처리량을 위해 더 작은 문서를 위한 디자인</b> 지정된 작업의 요청 요금(예: 요청 처리 비용)은 문서 크기와 직접 상관 관계가 있습니다. 큰 문서에서 작업하는 경우 작은 문서 작업에 비해 비용이 많이 듭니다.</p>


  <h1>일관성 수준</h1>


  <p><b>일관성 수준 팁 #1: 읽기 대기 시간을 높이기 위해 약한 일관성 수준 사용</b> DocumentDB 애플리케이션의 성능을 조정하는 동안 고려해야 할 또 다른 중요한 요소는 일관성 수준입니다. 일관성 수준을 선택하면 읽기 및 쓰기 모두에 성능에 영향을 줍니다. 데이터베이스 계정에서 기본 일관성 수준을 구성할 수 있으며 선택한 일관성 수준은 DocumentDB 계정 내의 모든 컬렉션(모든 데이터베이스)에 적용됩니다. 쓰기 작업에서 일관성 수준 변경이 미치는 영향은 요청 대기 시간을 통해 관찰됩니다. 더 강력한 일관성 수준이 사용되면 <i>쓰기</i> 대기 시간이 증가합니다. 반면에 일관성 수준이 <i>읽기</i> 작업에 미치는 영향은 처리량 측면에서 관찰됩니다. 약한 일관성 수준은 클라이언트에 의해 실현되는 읽기 처리량을 높일 수 있습니다. 기본적으로 사용자 정의 리소스에 대해 발급된 모든 읽기 및 쿼리는 데이터베이스 계정에 지정된 기본 일관성 수준을 사용합니다. 그러나 x-ms-consistency-level 요청 헤더를 지정하여 특정 읽기/쿼리 요청의 일관성 수준을<b> </b>낮출 수 있습니다.</p>


  <h1>요약</h1>


  <p>이 게시물과 <a href="https://azure.microsoft.com/blog/2015/01/20/performance-tips-for-azure-documentdb-part-1-2/">1</a>&rsquo;부 사이에 DocumentDB 사용에 유용하고 적용 가능한 성능 팁을 찾았으면 합니다.&nbsp; 언제나 그처럼, Wed&rsquo;는 가장 가치 있는 DocumentDB 기능과 환경에 대해 여러분의 의견을 듣고 싶어합니다.&nbsp; Microsoft Azure DocumentDB <a href="https://feedback.azure.com/forums/263030-documentdb?filter=top&amp;page=1">피드백 포럼</a>에서 제안 사항을 제출하세요.&nbsp; DocumentDB를 아직 시도하지 않은&rsquo; 경우 <a href="https://azure.microsoft.com/en-us/services/documentdb/">여기에서</a> 시작합니다.</p>
