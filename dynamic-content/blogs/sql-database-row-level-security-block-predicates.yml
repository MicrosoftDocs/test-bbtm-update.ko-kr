### YamlMime:Yaml
ms.openlocfilehash: 403b4d063ee855443d261682eeb196a72a22fa12
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139900412"
Slug: sql-database-row-level-security-block-predicates
Title: '새로운 Row-Level 보안 기능: 조건자 차단(미리 보기)'
Summary: 차단 조건자를 사용하면 사용자가 조건자를 위반하는 행을 삽입, 업데이트 및/또는 삭제하지 못하도록 보안 정책을 사용할 수 있습니다. 이제 SQL Database 미리 보기로 제공됩니다.
Content: "<p>블록 조건자는 이제 Azure SQL Database RLS(<a href=\"https://azure.microsoft.com/en-us/blog/row-level-security-for-sql-database-is-generally-available/\">행 수준 보안</a>)에 대한 미리 보기 기능으로 사용할 수 있습니다. 차단 조건자는 사용자가 조건자를 위반하는 행을 삽입, 업데이트 및/또는 삭제하지 못하도록 보안 정책을 사용하도록 설정하여 고객 피드백의 공통점을 해결합니다. 현재 모든 Azure SQL Database(V12) 서버에서 차단 조건자를 사용해 볼 수 있습니다.</p>\n\n<p>블록 조건자의 일반적인 사용 사례는 다음과 같습니다.</p>\n\n<ul>\n    <li>다중 테넌트 데이터베이스에서 테넌트 간 삽입 방지</li>\n    <li>INSERT, UPDATE 및 DELETE 작업에 별도의 액세스 논리가 필요한 시나리오를 포함하여 다양한 사용자에 대한 데이터에 대한 쓰기 액세스에 대한 세부적인 제어 적용</li>\n</ul>\n\n<p>블록 조건자는 필터 조건자처럼 정의되므로 RLS의 기본 사항에 이미 익숙할&#39;있다면 쉽게 시작할&#39;있습니다. 예를 들어 이미 RLS를 사용하여 사용자에게 표시되는 행을 필터링할&#39;있는 경우 이제 블록 조건자로 동일한 조건자 함수를 다시 사용하여 사용자가 행을 삽입하거나 업데이트하여 표시되는&#39;외부에 있지 않도록 할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\nCREATE SECURITY POLICY Security.userAccessPolicy\n ADD FILTER PREDICATE Security.userAccessPredicate(UserId) ON dbo.MyTable,\n ADD BLOCK PREDICATE Security.userAccessPredicate(UserId) ON dbo.MyTable</pre>\n\n<p>필터 조건자는 읽기 작업에 적용되는 반면, 블록 조건자는 쓰기 작업에 적용됩니다.</p>\n\n<ul>\n    <li>AFTER INSERT 및 AFTER UPDATE 조건자는 조건자에 대해 새 행 값을 확인합니다.</li>\n    <li>BEFORE UPDATE 및 BEFORE DELETE 조건자는 조건자에 대해 기존 행 값을 확인합니다.</li>\n</ul>\n\n<p>위와 같이 작업이 지정되지 않은 경우 블록 조건자가 모든 작업에 적용됩니다. 그렇지 않으면 블록 조건자당 하나의 작업을 지정할 수 있습니다. 예를 들어 BEFORE UPDATE 및 BEFORE DELETE에 대한 블록 조건자를 사용하려면 이러한 각 작업에 대해 별도의 블록 조건자를 추가해야 합니다.</p>\n\n<p>다음은 다중 테넌트 데이터베이스에서 교차 테넌트 삽입을 방지하기 위해 블록 조건자를 사용하는 방법을 보여 주는 간단한 예제를&#39;. <a href=\"https://azure.microsoft.com/en-us/blog/building-more-secure-middle-tier-applications-with-azure-sql-database-using-row-level-security/\">이전 예제와</a> 마찬가지로 애플리케이션은 CONTEXT_INFO 사용하여 테넌트 식별:</p>\n\n<pre class=\"prettyprint\">\n-- Create sample table, where each row has a TenantId\nCREATE TABLE Sales (\n OrderId int,\n Qty int,\n Product varchar(10),\n TenantId int\n)\n \nINSERT INTO Sales VALUES \n (1, 53, &#39;Valve&#39;, 1), \n (2, 71, &#39;Bracket&#39;, 2), \n (3, 60, &#39;Wheel&#39;, 2)\ngo\n \n-- Create shared user for application to connect\nCREATE USER AppUser WITHOUT LOGIN\ngo\n \n-- Tenants will have both read and write access\nGRANT SELECT, INSERT, UPDATE, DELETE ON Sales TO AppUser\nDENY UPDATE ON Sales(TenantId) TO AppUser -- never allowed to change TenantId\ngo\n \n-- Enable RLS\nCREATE SCHEMA Security\ngo\n \nCREATE FUNCTION Security.tenantAccessPredicate(@TenantId int)\n RETURNS TABLE\n WITH SCHEMABINDING\nAS\n RETURN SELECT 1 AS accessResult\n WHERE @TenantId = CONVERT(int, CONVERT(varbinary(4), CONTEXT_INFO()))\ngo\n \n-- Note: We only need a block predicate AFTER INSERT, because \n-- rows for BEFORE UPDATE and BEFORE DELETE are already filtered, and \n-- AFTER UPDATE is unnecessary due to the column permission\nCREATE SECURITY POLICY Security.tenantPolicy\n ADD FILTER PREDICATE Security.tenantAccessPredicate(TenantId) ON dbo.Sales,\n ADD BLOCK PREDICATE Security.tenantAccessPredicate(TenantId) ON dbo.Sales AFTER INSERT\ngo\n \n-- Try it out by simulating queries as AppUser connected with TenantId = 2\nEXECUTE AS USER = &#39;AppUser&#39;\nSET CONTEXT_INFO 2\ngo\n \nSELECT * FROM Sales -- only rows for current tenant are visible\ngo\n \nINSERT INTO Sales VALUES (4, 1000, &#39;Wheel&#39;, 1) -- blocked from inserting for wrong tenant!\ngo\n \nREVERT\ngo</pre>\n\n<p><br />\n이 기능은 고객 피드백에서 직접 비롯되므로 블록 조건자를 매우 기쁘게&#39;. 시도해 보시고 아래의 의견에서 어떻게 생각하는지 알려주세요.</p>\n\n<p>자세한 내용은 MSDN의 <a href=\"https://msdn.microsoft.com/en-us/library/dn765131.aspx\"><font>행 수준 보안</font></a> 설명서를 확인하세요.</p>"
