### YamlMime:Yaml
ms.openlocfilehash: 490cbea7557c6ecd1be2e3d68054681ec39fb4b9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907656"
Slug: mvc-movie-app-with-azure-redis-cache-in-15-minutes
Title: 15분 만에 Azure Redis Cache를 사용한 MVC 영화 앱
Summary: 새 미리 보기 Azure Redis Cache는 Azure 웹앱에 쉽게 연결할 수 있습니다. MVC Movie 샘플 앱에 연결하여 Azure에 배포하고 17분(로컬로 연결하고 테스트하는 데 15분) 미만으로 실행했습니다.
Content: "<strong>업데이트 25 10월 2014 - 지금 GA의 Redis 캐시</strong> 새 <a href=\"https://azuremicrosoftcom/en-us/documentation/services/cache/\" target=\"_blank\">Azure Redis Cache</a> 는 <a href=\"https://wwwaspnet/mvc/tutorials/mvc-5/introduction/getting-started\">MVC Movie 샘플 앱</a>에 연결하여 Azure에 배포하고 17분(로컬로 연결하고 테스트하는 데 15분) 미만으로 실행한 Azure 웹앱에 연결하기가 정말 쉽습니다.\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/p1png\"><img style=\"border-width: 0px\" title=\"p1\" alt=\"p1\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/p1_thumb.png\" width=\"493\" height=\"525\" border=\"0\" /></a>\n\n캐시는 캐시에서 핫 데이터를 가져와서 데이터베이스를 두드리는 것보다 약 100배 더 빠릅니다. 앱 속도를 높일 뿐만 아니라 DB 부하를 줄이고 다른 쿼리에 대한 응답성을 높일 수 있습니다.\n\n여기서 완성된 샘플을 다운로드할 수 있습니다.\n\nRedis 캐시를 MVC 동영상 샘플에 연결하기 위해 수행된 동작입니다.\n<ol>\n <li><a href=\"https://portalazurecom/\" target=\"_blank\">Azure</a> Portal에 로그온하고 새 캐시 만들기를 선택합니다.\n<img alt=\"\" src=\"\" />\n이 단계는 최대 15분이 걸릴 수 있지만 전체 지침은 <a href=\"https://azuremicrosoftcom/en-us/documentation/articles/cache-dotnet-how-to-use-azure-redis-cache/\" target=\"_blank\">Azure Redis Cache</a>  를 사용하는 방법을 참조하세요. 캐시를 만드는 것은 웹 사이트를 다른 위치로 이동하여 테스트한 웹 사이트를 만드는 것과 동일한 위치(데이터 센터)를 만드는 것이 중요합니다.  및 캐시 대기 시간이 25배 증가했습니다. 자세한 지침은 <a href=\"https://msdnmicrosoftcom/en-us/library/dn690516aspx\" target=\"_blank\">Redis Cache 만들기</a> 를 참조하세요. 시작 샘플로 내 MvcMovie를 다운로드할 수 있습니다. 또는 완료된 샘플을 다운로드하고 캐시 엔드포인트(URL) 및 자격 증명을 업데이트한 다음 다음을 수행합니다.</li>\n <li>캐시 이름 <span style=\"font-family: lucida console\">&lt;yourNamerediscachewindowsnet&gt;</span> 및 암호를 복사합니다(포털의 속성 블레이드에서 <strong>키</strong> 단추를 눌러 캐시 이름과 암호를 확인합니다.)</li>\n <li>NuGet 패키지 <strong>추가 StackExchangeRedis</strong>를 사용하는 경우 샘플에서 NuGet 패키지를 복원해야 합니다.</li>\n <li>패키지 관리자 콘솔에서 <strong>Update-Database</strong>를 실행합니다. <strong>update-Database</strong> 명령을 보려면 NuGet 패키지를 복원한 후 Visual Studio 종료하고 다시 시작해야 할 수 있습니다.</li>\n <li>연결 정보를 컨트롤러에 연결합니다.</li>\n</ol>\n<pre class=\"prettyprint\">public class MoviesController : Controller\n{\n   private MovieDBContext db = new MovieDBContext();\n   private static Lazy&lt;ConnectionMultiplexer&gt; lazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;\n   {\n      return ConnectionMultiplexerConnect(KeysconStr);\n   });\n\n   public static ConnectionMultiplexer Connection\n   {\n      get\n      {\n         return lazyConnectionValue;\n      }\n   }</pre>\n&nbsp;\n\n<span style=\"background: white;color: black\"><strong>경고</strong>: 이 샘플을 단순하게 유지하기 위해 소스 코드에 자격 증명을 저장하지 마세요. 소스 코드에 표시합니다. <a href=\"https://azuremicrosoftcom/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/\">Azure 웹 사이트 Windows 참조: 애플리케이션 문자열 및 연결 문자열이 작동하는</a> 방법</span>: \n\n<span style=\"background: white;color: black\">연결이 정적 변수로 저장되므로 각 요청에 대해 새 연결을 만들 필요가 없도록 자격 증명을 저장하는 방법에 대한 자세한 내용은 Get 메서드를 사용하여 연결이 유효한지 확인할 수 있습니다.  연결이 끊어지면 연결이 다시 설정됩니다.</span>\n\n<strong>SampleStackExchangeRedisExtensions</strong> 클래스를 포함하는 새 클래스를 만듭니다.\n<pre class=\"prettyprint\">public static class SampleStackExchangeRedisExtensions\n{\n   public static T Get&lt;T&gt;(this IDatabase cache, string key)\n   {\n      return Deserialize&lt;T&gt;(cacheStringGet(key));\n   }\n\n   public static object Get(this IDatabase cache, string key)\n   {\n      return Deserialize&lt;object&gt;(cacheStringGet(key));\n   }\n\n   public static void Set(this IDatabase cache, string key, object value)\n   {\n      cacheStringSet(key, Serialize(value));\n   }\n\n   static byte[] Serialize(object o)\n   {\n      if (o == null)\n      {\n         return null;\n      }\n      BinaryFormatter binaryFormatter = new BinaryFormatter();\n      using (MemoryStream memoryStream = new MemoryStream())\n      {\n         binaryFormatterSerialize(memoryStream, o);\n         byte[] objectDataAsStream = memoryStreamToArray();\n         return objectDataAsStream;\n      }\n   }\n\n   static T Deserialize&lt;T&gt;(byte[] stream)\n   {\n      BinaryFormatter binaryFormatter = new BinaryFormatter();\n      if (stream == null)\n         return default(T);\n\n      using (MemoryStream memoryStream = new MemoryStream(stream))\n      {\n         T result = (T)binaryFormatterDeserialize(memoryStream);\n         return result;\n      }\n   }\n}</pre>\n&nbsp;\n\n<strong>SampleStackExchangeRedisExtensions</strong> 클래스를 사용하면 직렬화 가능한 모든 형식을 쉽게 캐시할 수 있습니다. <a href=\"https://msdnmicrosoftcom/en-us/library/systemserializableattributeaspx\">모델에 [Serializable]</a> 특성을 추가해야 합니다.\n<pre class=\"prettyprint\">[Serializable]\npublic class Movie</pre>\n  <span style=\"background: white;color: #2b91af\">Movie </span><span style=\"background: white;color: black\">동영상 = dbMoviesFind(id)</span>의 모든 인스턴스를 찾습니다.\n\n다음으로 대체합니다.\n<pre class=\"prettyprint\">//Movie movie = dbMoviesFind(id);\nMovie movie = getMovie((int)id);</pre>\nPOST 편집 및 삭제 메서드에서 다음 호출을 사용하여 캐시를 제거합니다.\n<pre class=\"prettyprint\">ClearMovieCache(movieID);</pre>\n영화 컨트롤러에 다음 코드를 추가 <strong>합니다. getMovie</strong> 메서드는 표준 주문형 캐시 배제 방법을 사용합니다.\n<pre class=\"prettyprint\">Movie getMovie(int id)\n{\n   Stopwatch sw = StopwatchStartNew();\n   IDatabase cache = ConnectionGetDatabase();\n   Movie m = (Movie)cacheGet(idToString()); \n\n   if (m == null)\n   {\n      Movie movie = dbMoviesFind(id);\n      cacheSet(idToString(), movie);\n      StopWatchMiss(sw);\n      return movie;\n   }\n   StopWatchHit(sw); \n\n   return m;\n} \n\nprivate void ClearMovieCache(int p)\n{\n   IDatabase cache = connectionGetDatabase();\n   if (cacheKeyExists(pToString()))\n      cacheKeyDelete(pToString());\n} \n\nvoid StopWatchEnd(Stopwatch sw, string msg)\n{\n   swStop();\n   double ms = swElapsedTicks / (StopwatchFrequency / (10000));\n   ViewBagcacheMsg = msg + msToString() +\n       ” PID: ” + ProcessGetCurrentProcess()IdToString();\n} \n\nvoid StopWatchMiss(Stopwatch sw)\n{\n   StopWatchEnd(sw, “Miss – MS:”);\n} \n\nvoid StopWatchHit(Stopwatch sw)\n{\n   StopWatchEnd(sw, “Hit – MS:”);\n}</pre>\n모든 페이지에서 타이밍 정보를 얻을 수 있도록 <em>View\\SharedLayoutcshtml\\_ </em>파일에 <strong>ViewBagcacheMsg</strong> 코드를 추가합니다.\n<pre class=\"prettyprint\">&lt;div class=\"container body-content\"&gt;\n        @RenderBody()\n        &lt;hr /&gt;\n        &lt;footer&gt;\n           &lt;h2&gt;@ViewBagcacheMsg&lt;/h2&gt;\n        &lt;/footer&gt;\n    &lt;/div&gt;\n\n    @ScriptsRender(\"~/bundles/jquery\")\n    @ScriptsRender(\"~/bundles/bootstrap\")\n    @RenderSection(\"scripts\", required: false)\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n이제 로컬에서 테스트하고 타이밍 정보를 가져올 수 있습니다. 동영상이 캐시되면 캐시된 상태로 유지됩니다(메모리 압력으로 인해 데이터를 제거할 때마다 DB가 너무 작음) 데스크톱에서 클라우드 캐시로의 성능이 좋지 않습니다. 샘플 다운로드 시 <strong>ClearCache</strong> 단추를 클릭하여 각 캐시 항목을 제거할 수 있습니다.\n<h2>포털에서 캐시 모니터링</h2>\n포털에서 캐시 적중/누락 통계를 가져올 수 있습니다.\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/stpng\"><img style=\"border-width: 0px\" title=\"st\" alt=\"st\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/st_thumbpng\" width=\"381\" height=\" it to your dashboard – that way you’ll see it each time you log into the portal You can also add other metrics such as <em>evicted keys, expired keys, used memory</em> and <em>CPU</em>\n\n최신 데이터를 가져와 모니터링할 항목을 선택하려면 <strong>모니터링</strong> 상자를 마우스 오른쪽 단추로 클릭하고 <strong>QueryYou 편집</strong>을 선택하면 모니터링할 데이터를 확인할 수 있습니다.\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/ed2png\"><img style=\"border-width: 0px\" title=\"ed2\" alt=\"ed2\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/ed2_thumbpng\" width=\"315\" height=\"573\" border=\"0\" /></a>\n\n위에서 확인한 항목에 대해서만 경고를 설정할 수 있습니다. <경고 <strong>추가</strong> 단추를 스트로닉하고 아래 이미지에서 모니터링하는 모든 항목에 대한 경고를 설정할 수 있습니다. 15분 동안 키 제거를 모니터링하고 있습니다. 제거 비율이 높으면 더 큰 캐시의 이점을 얻을 수 있음을 나타냅니다.\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/metpng\"><img style=\"border-width: 0px\" title=\"만난\" alt=\"met\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/met_thumbpng\" width=\"594\" height=\"843\" border=\"0\" /></a>\n\nVisual Studio 쉽게 Azure에 게시할 수 있도록 웹앱을 마우스 오른쪽 단추로 클릭하고 게시를 선택하면 캐시 클라이언트와 다른 지역에 있는 캐시(이 경우 웹앱)가 데이터 전송 비용을 발생시킬 수 있으므로 캐시 Ie 대기 시간을 만든 동일한 웹 사이트 지역을 선택하는 것이 중요합니다. 설정 탭에서 실행이 확인되었는지 확인합니다.<strong> Code First 마이그레이션</strong>\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/05/pwpng\"><img style=\"border-width: 0px\" title=\"비밀 번호\" alt=\"pw\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/pw_thumbpng\" width=\"652\" height=\"513\" border=\"0\" /></a>\n\n이제 클라우드에서 앱을 테스트하고 캐시 대기 시간이 훨씬 낮아집니다(캐시와 웹 사이트가 동일한 데이터 센터에 있다고 가정).\n<h2>캐시 스트레스 테스트</h2>\n캐시 작업에 대한 기본 시간 제한은 1000MS(1초)입니다. 다음 코드를 사용하여 코드가 제한 시간 예외를 올바르게 처리하고 <strong>#define NotTestingTimeOut</strong> 이 주석 처리되면 시간 제한이 150MS로 낮아집니다. 따라서 부하가 높은 시간 제한 예외를 더 쉽게 적중할 수 있습니다.\n<pre class=\"prettyprint\">#else\n   #region StressTest\n       private static Lazy&lt;ConnectionMultiplexer&gt; lazyConnection = new Lazy&lt;ConnectionMultiplexer&gt;(() =&gt;\n      {\n\n      var config = new ConfigurationOptions();\n            configEndPointsAdd(KeysURL);\n            configPassword = Keyspasswd;\n            configSsl = true;\n            configSyncTimeout = 150;\n\n           return ConnectionMultiplexerConnect(config);\n      });\n   #endregion\n#endif</pre>\n스트레스 테스트 중에 세션 캐시를 사용하지 않도록 설정하는 것이 좋습니다. <em>webconfig</em> 파일의 흐름 요소를 사용하여 전체 앱에 대해 수행할 수 있습니다.\n<pre class=\"prettyprint\">&lt;sessionState mode=\"Off\" /&gt;</pre>\n또는 컨트롤러에서 <a href=\"https://msdnmicrosoftcom/en-us/library/systemwebmvcsessionstateattributeaspx\" target=\"_blank\">[SessionState(SessionStateBehaviorDisabled)]</a> 를 사용할 수 있습니다. 업데이트된 <span style=\"font-family: lucida console\">getMovie</span> 메서드는 더 강력하며 시간 초과 예외를 제외하고 최대 3번까지 다시 시도합니다.\n<pre class=\"prettyprint\">      Movie getMovie(int id, int retryAttempts = 0)\n      {\n         IDatabase cache = ConnectionGetDatabase();\n         if (retryAttempts &gt; 3)\n         {\n            string error = \"getMovie timeout with \" + retryAttemptsToString()\n               + \" retry attempts Movie ID = \" + idToString();\n            Logger(error);\n\n            ViewBagcacheMsg = error + \" Fetch from DB\";\n            // Cache unavailable, get data from DB\n            return dbMoviesFind(id);\n         }\n         Stopwatch sw = StopwatchStartNew();\n         Movie m;\n\n         try\n         {\n            m = (Movie)cacheGet(idToString());\n         }\n\n         catch (TimeoutException tx)\n         {\n            Logger(\"getMovie fail, ID = \" + idToString(), tx);\n            return getMovie(id, ++retryAttempts);\n         }\n\n         if (m == null)\n         {\n            Movie movie = dbMoviesFind(id);\n            cacheSet(idToString(), movie);\n            StopWatchMiss(sw);\n            return movie;\n         }\n         StopWatchHit(sw);\n\n         return m;\n      }</pre>\n샘플 앱에는 캐시를 부하 테스트하기 위해 호출할 수 있는 몇 가지 방법이 있습니다.\n\n<a href=\"https://acomazurecomcdnnet/80C57D/blogmedia/blogmedia/2014/06/qqpng\"><img style=\"border-width: 0px\" title=\"Qq\" alt=\"qq\" src=\"https://azurecomcdnazureedgenet/mediahandler/acomblog/media/Default/blog/qq_thumbpng\" width=\"549\" height=\"526\" border=\"0\" /></a>\n\n<span style=\"font-family: lucida console\">WriteCache</span> 및 <span style=\"font-family: lucida console\">ReadCache</span> 메서드는 1K 항목을 쓰거나 읽습니다. 필요에 따라 URL에 \"/n\"을 추가하여 n*K 항목을 쓰거나 읽을 수 있습니다. 예를 들어 https://&lt; your siteazurewebsitesnet&gt;/Movies/ReadCache/3은 3K 캐시된 항목을 읽습니다.\n\n150MS 시간 초과 및 캐시 하드 타격으로 style=\"background: white;color: black\">getMovie</span> 메서드가 캐시 오류를 올바르게 처리하고 DB에서 영화를 반환한 다음 로그에 경고 메시지를 씁니다. \"<span style=\"font-family: lucida console\"><strong>getMovie timeout with 4 retry attempts Movie ID = 3 Fetch from DB</strong></span>\"\n\n기본 캐시(슬레이브 또는 장애 조치(failover)가 없는)를 선택한 경우, 표준 캐시에 매우 빠른 비차단 첫 번째 동기화 및 자동 재연결이 있는 마스터 및 슬레이브(장애 조치(failover) 캐시)가 있는 동안 호스팅 VM이 패치되는 동안 한 달에 한 번 몇 분 동안 캐시를 사용할 수 없게 됩니다.  캐시 오류를 올바르게 처리하기 위해 코드를 작성해야 합니다.\n\n&nbsp;\n<h2>Azure Redis Cache ASPNET 세션 상태 공급자</h2>\n세션 상태를 사용하지 않는 것이 모범 사례로 간주되지만, 일부 애플리케이션은 실제로 세션 데이터를 사용하면 <strong>성능/복잡성 이점이</strong> 있을 수 있지만, 다른 앱은 세션 상태를 완전히 요구하는 반면, 세션 상태에 대한 메모리 공급자의 기본값은 스케일 아웃(웹 사이트의 여러 인스턴스 실행)을 허용하지 않습니다. ASPNET은 SQL Server  세션 상태 공급자는 여러 웹 사이트에서 세션 상태를 사용할 수 있도록 허용하지만 메모리 내 공급자에 비해 대기 시간이 긴 비용이 발생합니다. Redis 세션 상태 캐시 공급자는 매우 쉽게 구성하고 설정할 수 있는 짧은 대기 시간 대안입니다. 앱에서 제한된 양의 세션 상태만 사용하는 경우  대부분의 캐시를 데이터 캐싱에 사용할 수 있으며 세션 상태에는 소량의 캐시를 사용할 수 있습니다.\n\n웹앱에 <strong>RedisSessionStateProvider</strong> NuGet 패키지 추가(전체 지침은 <a href=\"https://msdnmicrosoftcom/en-us/library/dn690522aspx\" target=\"_blank\">이</a> 문서 <em>참조 시험판</em> 지정) 호스트 URL 및 키를 사용하여 루트 <em>Webconfig </em>파일에 추가된 태그를 편집합니다. SSL을 true로 설정해야 합니다.\n<pre class=\"prettyprint\"> &lt;systemweb&gt;\n     &lt;customErrors mode=\"Off\" /&gt;\n     &lt;!--&lt;sessionState mode=\"Off\" /&gt;--&gt;\n    &lt;authentication mode=\"None\" /&gt;\n    &lt;compilation debug=\"true\" targetFramework=\"45\" /&gt;\n    &lt;httpRuntime targetFramework=\"45\" /&gt;\n  &lt;sessionState mode=\"Custom\" customProvider=\"RedisSessionProvider\"&gt;\n               &lt;add name=\"RedisSessionProvider\" \n              type=\"MicrosoftWebRedisRedisSessionStateProvider\" \n              port=\"6380\"\n              host=\"movie2rediscachewindowsnet\" \n              accessKey=\"m7PNV60CrvKpLqMUxosC3dSe6kx9nQ6jP5del8TmADk=\" \n              ssl=\"true\" /&gt;\n      &lt;!--&lt;add name=\"MySessionStateStore\" type=\"MicrosoftWebRedisRedisSessionStateProvider\" host=\"127001\" accessKey=\"\" ssl=\"false\" /&gt;--&gt;\n      &lt;/providers&gt;\n    &lt;/sessionState&gt;\n  &lt;/systemweb&gt;\n  &lt;systemwebServer&gt;</pre>\n이제 웹앱에서 세션 상태를 사용할 수 있습니다. 샘플은 WriteCache 및 ReadCache 작업 메뉴(및 UI)를 제공합니다. 쓰기 캐시는 문자열 경로 데이터를 제공하는 옵션을 허용합니다. 예를 들어 <span style=\"font-family: lucida console\"><em>https://&lt; your siteazurewebsitesnet&gt;/SessionTest/WriteSession/Hello_joe</em></span> 세션 상태에 \"Hello_joe\"을 작성합니다. 앱의 모든 인스턴스는 동일한 Redis 세션 캐시를 사용합니다.  따라서 고정 세션을 사용할 필요가 없습니다.\n\n이 항목을 어떻게 좋아하고 다음에 Redis 캐시에서 어떤 내용을 다루고 싶은지 알려주세요.\n\n내가 품질 트윗의 스팸 보장이없는 트위터에 나를 따라 ( <a href=\"https://twittercom/RickAndMSFT\">@RickAndMSFT</a> )\n<h2>추가 리소스</h2>\n<ul>\n <li><a href=\"https://msdnmicrosoftcom/en-us/library/dn690521aspx\" target=\"_blank\">Azure Redis Cache에서 데이터 캐싱</a></li>\n <li><a href=\"https://wacelcodeplexcom/\">Windows Azure Cache 확장 라이브러리</a> WACEL은 서비스 및 애플리케이션 간에 공유할 수 있는 고급 데이터 구조의 구현을 제공합니다.</li>\n <li><a href=\"https://msdnmicrosoftcom/en-us/library/dn690523aspx\">MSDN Azure Redis Cache</a></li>\n</ul>"
