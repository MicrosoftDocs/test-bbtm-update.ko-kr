### YamlMime:Yaml
ms.openlocfilehash: 060dc726ede24b6b8804808946a18671a0f7323e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903236"
Slug: implementing-geographic-redundancy
Title: 지리적 중복성 구현
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] 지리적 중복성은 전 세계적으로 여러 데이터 센터에 데이터를 배포하기 위한 멋진 단어입니다. 이 작업을 수행하는 한 가지 방법은 확산하는 것입니다...'
Content: "<p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p><a href=\"\"><img style=\"border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px\" title=\"\" border=\"0\" hspace=\"12\" alt=\"clip_image002\" align=\"right\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1715.clip_5F00_image002_5F00_thumb_5F00_08BA52CA.jpg\" width=\"244\" height=\"244\"></a>clip_image002지구적 중복성은 전 세계적으로 여러 데이터 센터에 데이터를 배포하기 위한 멋진 단어입니다. 이 작업을 수행하는 한 가지 방법은 SQL Azure 데이터 동기화 Service를 사용하여 여러 SQL Azure 데이터 센터에 데이터를 분산하여 허브 데이터베이스를 여러 글로벌 멤버 데이터베이스에 동기화하는 것입니다. SQL Azure 전 세계적으로 6개의 데이터 센터가 있습니다.</p>  <p>앞으로는 데이터 동기화 Services를 통해 실시간 쓰기 및 지리적 중복성을 제공하는 더 복잡한 기술에 대해 블로그로 작성할 예정입니다.</p>  <h2>고려 사항</h2>  <p>이 블로그 게시물에서 설명하는 기술은 쓰기가 낮고 읽기가 높은 데이터베이스에 가장 적합하며 쓰기 데이터를 실시간으로 동기화할 필요가 없습니다. 이 기술에 잘 맞는 한 가지 시나리오는 이 블로그 게시물에서 설명한 잡지 게시 웹 사이트입니다.</p>  <p>SQL Azure 대한 데이터 동기화 Service의 현재 CTP를 사용하면 가장 자주 동기화되는 시간이 1시간이 될 수 있습니다. 이 제한은 이 특정 기술의 유용성을 제한된 수의 애플리케이션으로 줄입니다. 좋은 소식은 데이터 동기화 Services의 향후 릴리스에서 더 자주 동기화할 수 있는 옵션이 있다는 것입니다. </p>  <h2>SQL Azure 대한 데이터 동기화 서비스 설정</h2>  <p>지리적 중복성을 얻으려면 서로 다른 데이터 센터에 있는 SQL Azure 서버가 있는 여러 SQL Azure 서비스 계정이 있어야 합니다. 현재 계정당 하나의 서버만 사용할 수 있습니다. 즉, 여러 데이터 센터에 상주하는 경우 여러 계정이 필요합니다. 데이터 센터의 위치와 멤버 데이터베이스의 수는 애플리케이션의 요구 사항에 따라 달라집니다. 두 개의 서로 다른 데이터 센터에 두 개의 데이터베이스가 있는 것은 지리적 중복에 필요한 최소값입니다.</p>  <p>다음 단계는 SQL Azure 대한 데이터 동기화 서비스를 설정하는 것입니다. 이 기술을 사용하면 허브 데이터베이스는 읽고 쓸 수 있는 데이터베이스이며 멤버 데이터베이스는 읽기 전용(SELECT)입니다. 멤버 데이터베이스를 읽기 전용으로 사용하면 데이터 무결성 및 동기화 충돌 문제가 간소화됩니다.</p>  <h2>데이터 계층 수정</h2>  <p>마지막 단계는 먼저 Windows Azure 웹 역할에 상대적인 로컬 데이터 센터를 선택하는 일부 인텔리전스를 데이터 계층 코드에 추가하는 것입니다. 로컬 데이터베이스가 오프라인 상태이고 코드가 원격 SQL Azure 데이터 센터로 장애 조치되는 경우 이 코드는 이 블로그 게시물에서 설명한 연결 처리 코드를 확장합니다.</p>  <h2>연결 문자열</h2>  <p>위의 설정을 사용하면 이제 여러 읽기 전용 멤버 데이터베이스가 전역적으로 배포됩니다. 즉, 애플리케이션에서 사용할 수 있는 여러 연결 문자열이 있습니다. 디자인 연습에서는 이러한 애플리케이션이 Azure 웹 역할에 Windows SQL Azure 데이터베이스와 동일한 데이터 센터에 존재할 수 있다고 가정해 보겠습니다.</p>  <p>이 기술에서는 데이터베이스에 대해 읽기 쿼리가 실행될 때마다 연결 문자열을 동적으로 구성합니다. 내 코드에서 다음 목표를 갖고 싶습니다.</p>  <ul>   <li>주 서버가 실행 중인 Windows Azure 웹 역할과 동일한 데이터 센터에 있는 연결 문자열을 반환합니다. 이렇게 하면 성능이 향상되고 데이터 전송 요금이 줄어듭니다.</li>    <li>장애 조치(failover) 파트너가 주 서버와 다른 데이터 센터에 있는 연결 문자열을 반환합니다. 이렇게 하면 지리적 중복성이 부여됩니다.</li>    <li>원격 데이터 센터를 호출하는 대신 일시적인 오류에 대해 로컬 데이터 센터에서 다시 시도하려면 이전 코드 예제를 빌드합니다.</li>    <li>데이터 센터당 일치하는 데이터가 있는 서버가 하나 있습니다.</li>    <li>모든 데이터베이스의 이름은 동일합니다. 이렇게 하면 각 서버의 데이터베이스 이름 목록을 유지할 필요가 없으므로 이 예제에서 코드를 더 간단하게 유지할 수 있습니다.</li>    <li>하나의 원격 데이터 센터만 사용해 보세요. 로컬 데이터 센터와 임의 장애 조치(failover) 파트너가 실패하면 작업을 중단합니다.</li> </ul>  <h2>ConnectionStringManager</h2>  <p>아래 표시된 <b>ConnectionStringManager</b> 클래스는 데이터를 보유하는 데이터 센터 및 서버에 대해 알고 있습니다. 구성 파일에서 사용자 ID 및 암호를 읽는 방법도 알고 있습니다. 이 정보에서 로컬 SQL Azure 데이터베이스에 대한 연결 문자열을 생성하거나 임의 장애 조치(failover) 파트너를 반환하여 원격으로 연결할 수 있습니다.</p>  <p><b>ConnectionStringManager</b> 클래스 코드는 블로그 게시물의 끝에 있는 다운로드에서 찾을 수 있습니다. <b>ConnectionStringManager</b> 클래스 코드는 다음과 같습니다.</p>  <pre class=\"csharpcode\"><span class=\"kwrd\">internal</span> <span class=\"kwrd\">class</span> ConnectionStringManager  {      <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Enumeration of SQL Azure Data Centers</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"kwrd\">internal</span> <span class=\"kwrd\">enum</span> DataCenterEnum      {          EastAsia,          NorthCentralUS,          NorthEurope,          SouthCentralUS,          SoutheastAsia,          WestEurope      }        <span class=\"kwrd\">protected</span> Dictionary&lt;DataCenterEnum, String&gt; _datacenters =          <span class=\"kwrd\">new</span> Dictionary&lt;DataCenterEnum, <span class=\"kwrd\">string</span>&gt;();      Random _random = <span class=\"kwrd\">new</span> Random();        <span class=\"kwrd\">internal</span> ConnectionStringManager()      {          <span class=\"rem\">// WWB: List of Servers With The Same Data, One Per DataCenter</span>          _datacenters[DataCenterEnum.SouthCentralUS]               = <span class=\"str\">&quot;n50rqzztlj&quot;</span>;          _datacenters[DataCenterEnum.NorthCentralUS]               = <span class=\"str\">&quot;iiyzhlnz4s&quot;</span>;      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">// Overall performance could be improved by changing or</span>      <span class=\"rem\">// caching this algorithm, however for simplicity of </span>      <span class=\"rem\">// the example, I am leaving it this way.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> DataCenterEnum? FailOverPartner(          DataCenterEnum localDataCenter)      {          <span class=\"rem\">// WWB: Generate a List Of FailOver Partners Not In</span>          <span class=\"rem\">// The Local Data Center</span>          List&lt;DataCenterEnum&gt; nonLocalServers = <span class=\"kwrd\">new</span> List&lt;DataCenterEnum&gt;();          <span class=\"kwrd\">foreach</span> (DataCenterEnum dataCenter <span class=\"kwrd\">in</span> _datacenters.Keys)              <span class=\"kwrd\">if</span> (dataCenter != localDataCenter)                  nonLocalServers.Add(dataCenter);            <span class=\"rem\">// WWB: There Are No Valid FailOver Partners</span>          <span class=\"kwrd\">if</span> (nonLocalServers.Count == 0)              <span class=\"kwrd\">return</span> (<span class=\"kwrd\">null</span>);            <span class=\"rem\">// WWB: Choose a Random Remote DataCenter</span>          <span class=\"kwrd\">int</span> index = _random.Next(nonLocalServers.Count);            <span class=\"kwrd\">return</span> (nonLocalServers[index]);      }        <span class=\"kwrd\">internal</span> String Database      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;Database&quot;</span>]);          }      }        <span class=\"kwrd\">internal</span> String UserId      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;UserId&quot;</span>]);          }      }        <span class=\"kwrd\">internal</span> String Password      {          get          {              <span class=\"kwrd\">return</span> (ConfigurationManager.AppSettings[<span class=\"str\">&quot;password&quot;</span>]);          }      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Return the server name for the datacenter.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> String Server(DataCenterEnum localDataCenter)      {          <span class=\"kwrd\">return</span> (_datacenters[localDataCenter]);      }        <span class=\"rem\">/// &lt;summary&gt;</span>      <span class=\"rem\">/// Returns the Connection String For the DataCenter</span>      <span class=\"rem\">/// Performance Could be Improved By Caching the Results</span>      <span class=\"rem\">/// And Not Constructing the String Everytime.</span>      <span class=\"rem\">/// &lt;/summary&gt;</span>      <span class=\"rem\">/// &lt;param name=&quot;localDataCenter&quot;&gt;&lt;/param&gt;</span>      <span class=\"rem\">/// &lt;returns&gt;&lt;/returns&gt;</span>      <span class=\"kwrd\">internal</span> String ConnectionString(DataCenterEnum localDataCenter)      {          StringBuilder connectionString = <span class=\"kwrd\">new</span> StringBuilder();            connectionString.AppendFormat(<span class=\"str\">&quot;Server=tcp:{0}.database.windows.net;&quot;</span>,              Server(localDataCenter));          connectionString.AppendFormat(<span class=\"str\">&quot;Database=AdventureWorksLTAZ2008R2;&quot;</span>,               Database);          connectionString.AppendFormat(<span class=\"str\">&quot;User ID={0}@{1};&quot;</span>, UserId,              Server(localDataCenter));          connectionString.AppendFormat(<span class=\"str\">&quot;Password={0};&quot;</span>, Password);          connectionString.AppendFormat(<span class=\"str\">&quot;Trusted_Connection=False;&quot;</span>);          connectionString.AppendFormat(<span class=\"str\">&quot;Encrypt=True;&quot;</span>);            <span class=\"kwrd\">return</span> (connectionString.ToString());      }  }</pre>      <p>호출 코드는 이 블로그 게시물에서 설명한 연결 처리 코드를 기반으로 합니다. 현재 Azure를 Windows C# 코드에서 어떤 데이터 센터에 있는지 검색할 수 있는 방법은 없습니다. 따라서 코드에서 로컬 데이터 센터를 하드 코딩해야 합니다. 동일한 코드를 다른 Windows Azure 데이터 센터에 배포할 때 변경해야 합니다. Windows Azure 구성 파일로 이동하고 여기에서 코드를 읽도록 할 수도 있습니다.</p>    <pre class=\"csharpcode\"><span class=\"kwrd\">static</span> <span class=\"kwrd\">private</span> ConnectionStringManager       ConnectionStringManager = <span class=\"kwrd\">new</span> ConnectionStringManager();  <span class=\"kwrd\">static</span> <span class=\"kwrd\">private</span> ConnectionStringManager.DataCenterEnum       LocalDataCenter = ConnectionStringManager.DataCenterEnum.SouthCentralUS;    <span class=\"rem\">/// &lt;summary&gt;</span>  <span class=\"rem\">/// Generic Code that takes and input and executes </span>  <span class=\"rem\">/// a statement against the SQL Azure</span>  <span class=\"rem\">/// &lt;/summary&gt;</span>  <span class=\"rem\">/// &lt;param name=&quot;companyId&quot;&gt;&lt;/param&gt;</span>  <span class=\"kwrd\">static</span> <span class=\"kwrd\">void</span> DoSomething(Int32 customerId)  {      <span class=\"rem\">// Always Start Locally, It Is Less Expensive and Faster</span>      ConnectionStringManager.DataCenterEnum currentDataCenter           = LocalDataCenter;        <span class=\"rem\">// This is the retry loop, handling the retries session</span>      <span class=\"rem\">// is done in the catch for performance reasons</span>      <span class=\"kwrd\">for</span> (Int32 attempt = 1; ; )      {          <span class=\"rem\">// Create a SqlConnection Class, the connection isn't established </span>          <span class=\"rem\">// until the Open() method is called</span>          <span class=\"kwrd\">using</span> (SqlConnection sqlConnection =              <span class=\"kwrd\">new</span> SqlConnection(                  ConnectionStringManager.ConnectionString(currentDataCenter)))          {              <span class=\"kwrd\">try</span>              {                  <span class=\"rem\">// Open the connection</span>                  sqlConnection.Open();                    <span class=\"rem\">// Statement To Call</span>                  String sql = <span class=\"str\">@&quot;SELECT CompanyName FROM [SalesLT].[Customer]&quot;</span> +                       <span class=\"str\">@&quot; WHERE CustomerId = @CustomerId&quot;</span>;                    SqlCommand sqlCommand = <span class=\"kwrd\">new</span> SqlCommand(sql, sqlConnection);                    sqlCommand.Parameters.AddWithValue(<span class=\"str\">&quot;@CustomerId&quot;</span>, customerId);                    <span class=\"kwrd\">using</span> (SqlDataReader sqlDataReader = sqlCommand.ExecuteReader())                  {                      <span class=\"kwrd\">while</span> (sqlDataReader.Read())                      {                          <span class=\"rem\">/// Do Something Wtih CompanyName</span>                      }                        <span class=\"kwrd\">return</span>;                  }              }              <span class=\"kwrd\">catch</span> (SqlException sqlException)              {                  <span class=\"rem\">// Increment attempts</span>                  attempt++;                    <span class=\"rem\">// Find Maximum attempts</span>                  Int32 maxRetryCount = Int32.Parse(                      ConfigurationManager.AppSettings[<span class=\"str\">&quot;ConnectionRetrys&quot;</span>]);                    <span class=\"rem\">// Throw Error if we have reach the maximum number of attempts</span>                  <span class=\"kwrd\">if</span> (attempt == maxRetryCount)                      <span class=\"kwrd\">throw</span>;                    <span class=\"rem\">// Determine if we should retry or abort.</span>                  <span class=\"kwrd\">if</span> (RetryLitmus(sqlException))                  {                      <span class=\"rem\">// Transient Error, Lets Wait And Try Again</span>                      <span class=\"rem\">// In This Data Center</span>                      Thread.Sleep(ConnectionRetryWaitSeconds(attempt));                  }                  <span class=\"kwrd\">else</span> <span class=\"kwrd\">if</span> (currentDataCenter == LocalDataCenter)                  {                      <span class=\"rem\">// Non Transient Error, Lets Try In a Remote DataCenter</span>                      currentDataCenter = ConnectionStringManager.FailOverPartner                          (currentDataCenter).Value;                  }                  <span class=\"kwrd\">else</span>                  {                      <span class=\"rem\">// We have tried a remote datacenter, now it is time to error.</span>                      <span class=\"kwrd\">throw</span>;                  }              }          }      }  }</pre>      <h4>요약</h4>    <p>질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>"
