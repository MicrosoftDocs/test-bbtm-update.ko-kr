### YamlMime:Yaml
ms.openlocfilehash: aa473afbd2fbd1505d0f09ca391e30da1cd4ff78
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139912082"
Slug: azure-documentdb-bids-fond-farewell-to-self-links
Title: Azure DocumentDB는 Self-Links 작별을 고합니다.
Summary: DocumentDB에서 새롭고 향상된 ID 기반 라우팅을 시작하는 방법입니다.
Content: "<p>좋아, 나는 그것을 인정, 그 제목은 완전히 자기 링크를 제거하지 않기 때문에&rsquo; 오해의 소지가. Ill&rsquo;은 조금 더 자세히 설명하지만 먼저 잠시 일시 중지하여 DocumentDB가 처음에 자체 링크를 사용하는 방법과 이유를 생각해 보겠습니다&rsquo;. <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\" target=\"_blank\">Azure DocumentDB</a>는 REST 인터페이스를 통해 액세스할 수 있는 Microsoft Azure 호스트되는 완전히 관리되는 JSON 문서 데이터베이스 서비스입니다. REST 서비스로서 DocumentDB의 모든 리소스는 Uri(Uniform Resource Identifier)로 주소를 지정합니다. <a href=\"https://azure.microsoft.com/documentation/articles/documentdb-resources/\">DocumentDB 리소스 모델은</a> 모든 리소스가 서로 어떻게 관련되는지, 그리고 이 리소스 모델에 따라 이러한 URI를 구성하는 방법을 설명합니다. 리소스 ID는 변경할 수 없는 고유한 시스템 생성 값입니다. DocumentDB에서 리소스를 검사하면 밑줄(&ldquo;_&rdquo;) 문자로 식별되는 일부 시스템 속성이 표시됩니다. _rid 이러한 시스템 속성 중 하나는 이 리소스 ID입니다. <img alt=\"JSON document with system properties\" border=\"0\" height=\"185\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/doc-frag.png\" style=\"border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"시스템 속성이 있는 JSON 문서\" width=\"610\"> 시스템 속성 중 하나는 이 리소스에 대한 자체 링크인 _self. 자체 링크는 dbs//colls/{0}/docs/{2}&rdquo;형식의 &ldquo;URI입니다. 여기서 {0} 데이터베이스는 _rid {1} 문서 컬렉션 {2} 의 _rid 문서의{1} _rid. DocumentDB로 작업을 수행한 경우 다음과 같은 URI에 대해 잘 알고 있을 것입니다. 은 데이터베이스의 모든 리소스로 작업을 수행할 때마다 사용되기 때문입니다. 자체 링크와 같은 URI를 사용하여 리소스를 처리할 수 있는 것은 리소스를 해결하는 데 사용할 수 있는 안정적인 URI를 제공하기 때문에 좋은 일입니다. 그렇다면 왜 우리는 그들을 없애고 있을까요? 글쎄, 우리는 자체 링크를 제거하지 않았습니다&rsquo;. 전적으로 한 것은 아닌. Weve&rsquo;는 많은 고객으로부터 이러한 _rid 기반의 자체 링크는 리소스 ID가 오프핸드인지 아무도 모르기 때문에 사용하기가 정말 어렵다는 것을 들었습니다. 해당 리소스로 작업을 수행하기 전에 자체 링크를 가져오기 위해 리소스를 쿼리해야 합니다. &ldquo;고객은 리소스를 만들 때 설정한 ID가 모든 리소스에 있으므로 리소스를 처리할 때 해당 ID를 사용할 수&rsquo; 없는 이유는 무엇인가요?&rdquo;&nbsp; 우리는이 감정에 동의, 그래서 오늘&rsquo;이 분야에서 큰 변화를 발표 분노. 문서에는 여전히 _self 속성이 있지만&rsquo; 이제는 _rid 아닌 ID를 기반으로 하는 리소스에 대한 대체 링크를 빌드하는 기능을 추가해야 합니다. (참고: 리소스에서 기존 자체 링크를 사용하는 기능은 계속 지원됩니다.) 즉, 이제 다음 URI가 앞에서 살펴본 문서를 참조하는 유효한 방법입니다. dbs/<strong>MyDatabaseId</strong>/colls/<strong>MyCollectionId</strong>/docs/<strong>MyDocumentId</strong> <strong>NB - 이 URI가 후행 &#39;/&#39; 문자로 끝나지 않는 방법을 확인합니다. 이것은 미묘하지만 중요한 차이점입니다.</strong> 눈에는 이 작업이 더 쉬울 뿐만 아니라 이 URI의 일부로 리소스를 만들 때 제공한 ID를 사용할 수 있다는 점이 더 중요합니다. 지금까지 문서를 삭제하는 것과 같은 간단한 작업을 수행하려면 다음과 유사한 코드를 작성해야 했습니다.</p>\n\n<pre class=\"prettyprint\">\n// Get a Database by querying for it by id\nDatabase db = client.CreateDatabaseQuery()\n                    .Where(d =&gt; d.Id == &quot;SalesDb&quot;)\n                    .AsEnumerable()\n                    .Single();\n\n// Use that Database&#39;s SelfLink to query for a DocumentCollection by id\nDocumentCollection coll = client.CreateDocumentCollectionQuery(db.SelfLink)\n                                .Where(c =&gt; c.Id == &quot;Catalog&quot;)\n                                .AsEnumerable()\n                                .Single();\n\n// Use that Collection&#39;s SelfLink to query for a DocumentCollection by id\nDocument doc = client.CreateDocumentQuery(coll.SelfLink)\n                     .Where(d =&gt; d.Id == &quot;prd123&quot;)\n                     .AsEnumerable()\n                     .Single();\n\n// Now that we have a doc, use it&#39;s SelfLink property to delete it\nawait client.DeleteDocumentAsync(doc.SelfLink);</pre>\n\n<p>대부분의&rsquo; 코드는 필요한 자체 링크를 가져오기 위해 리소스를 조회하는 간단한 상용구 코드입니다. 코드 조각에는 서비스에 대한 세 가지 호출이 있으며, 각 호출 비용은 단위 및 네트워크 왕복을 요청하는 데 비용이 들기 때문에 원하는 작업을 수행할 수 있습니다. 이 릴리스에서는 해당 코드를 다음 두 줄의 코드로 바꿀 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\n// Build up a link manually using ids\n// If you are building up links manually, ensure that \n// the link does not end with a trailing &#39;/&#39; character\nvar docLink = string.Format(&quot;dbs/{0}/colls/{1}/docs/{2}&quot;, \n     &quot;SalesDb&quot;, &quot;Catalog&quot;, &quot;prd123&quot;);\n\n// Use this constructed link to delete the document\nawait client.DeleteDocumentAsync(docLink);</pre>\n\n<p>이렇게 하면 코드 작성 및 유지 관리가 감소할 뿐만 아니라 문서 작성과 같은 더 중요한 작업을 위해 해당 RU를 떠나는 데이터베이스 작업도 줄어듭니다. 위의 코드에서는 리소스 모델에서 URI를 올바르게 빌드하는 방법을 이해해야 합니다. 또한 이스케이프 공백과 같은 작업을 수행하고 특수 문자를 인코딩하여 유효한 URI가 있는지 확인해야 하므로 SDK에서 한 단계 더 나아가 간단한 도우미 팩터&nbsp;리를 추가했습니다.</p>\n\n<pre class=\"prettyprint\">\n// Use UriFactory to build the DocumentLink\nUri docUri = UriFactory.CreateDocumentUri(&quot;SalesDb&quot;, &quot;Catalog&quot;, &quot;prd123&quot;);\n\n// Use this constructed Uri to delete the document\nawait client.DeleteDocumentAsync(docUri);</pre>\n\n<p>이 새 UriFactory 클래스를 사용하면 필요한 Uri 종류와 적절한 ID만 알 수 있습니다. 이러한 변경 내용을 활용하고 UriFactory 클래스에 액세스하려면 <a href=\"https://www.nuget.org/packages/Microsoft.Azure.DocumentDB/1.4.0\">.NET SDK 버전 1.4.0 이상</a>에서 사용하도록 애플리케이션을 업데이트해야 합니다. Node.js, Python 및 Java SDK의 경우 업데이트가 필요하지 않으며 새 대체 링크를 만들고 즐겨보세요! 이 ID 기반 라우팅의 사용을 보여 주는 보다 포괄적인 샘플을 원하는 경우 <a href=\"https://portalcontent.blob.core.windows.net/samples/IdBasedRoutingSamples.zip\">이 프로젝트를</a> 함께 사용해 보세요. 피드백 포럼을 사용하여 사용자에게 가장 중요한 기능에 대한 <a href=\"https://feedback.azure.com/forums/263030-documentdb\">피드백을</a> 계속 보내주세요. &rsquo;이 피드백은 다음과 같은 업데이트로 서비스를 개선하는 데 도움이 됩니다. 최신 DocumentDB 뉴스 및 기능을 최신 상태로 유지하려면 Twitter <a href=\"https://twitter.com/DocumentDB\">@DocumentDB</a>에서 팔로우하세요. DocumentDB를 아직 시도하지 않은&rsquo; 경우 <a href=\"https://azure.microsoft.com/en-us/services/documentdb/\">여기에서</a> 시작하고 브라우저를 <a href=\"https://azure.microsoft.com/en-us/documentation/learning-paths/documentdb/\">학습 경로</a> 로 가리킬 수 있습니다.</p>"
