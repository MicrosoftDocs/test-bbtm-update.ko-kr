### YamlMime:Yaml
ms.openlocfilehash: c58b3eb6c4263013ce72a9244281d6a8aef94d98
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139898268"
Slug: optimization-tips-and-tricks-on-azure-sql-server-for-machine-learning-services
Title: Machine Learning Services에 대한 Azure SQL Server 최적화 팁 및 요령
Summary: 2016년 SQL Server 이후 R Services라는 새로운 함수가 도입되었습니다. Microsoft는 최근 고급 분석 기능을 Python으로 확장하는 다음 버전의 SQL Server 대한 미리 보기를 발표했습니다. R 또는 Python 데이터베이스에서 대규모로 실행하는 이 새로운 기능을 사용하면 분석 서비스를 데이터에 가깝게 유지하고 데이터 이동의 부담을 제거할 수 있습니다.
Content: >-
  <h1>요약</h1>


  <p>2016년 SQL Server 이후 R Services라는 새로운 함수가 도입되었습니다. Microsoft는 최근 고급 분석 기능을 Python<a href="https://blogs.technet.microsoft.com/dataplatforminsider/2017/04/19/sql-server-2017-community-technology-preview-2-0-now-available/" target="_blank">으로 확장하는 다음 버전의 SQL Server 대한 미리 보기를 발표</a>했습니다. R 또는 Python 데이터베이스에서 대규모로 실행하는 이 새로운 기능을 사용하면 분석 서비스를 데이터에 가깝게 유지하고 데이터 이동의 부담을 제거할 수 있습니다. 또한 지능형 애플리케이션의 개발 및 배포를 간소화합니다. SQL 서버를 최대한 활용하기 위해 인텔리전스 모델 자체를 미세 조정하는 방법을 아는 것은 충분하지 않으며 성능 요구 사항을 충족하지 못하는 경우도 있습니다. 성능을 크게 향상시키는 데 도움이 될 수 있는 몇 가지 최적화 팁과 요령이 있습니다. 이 게시물에서는 이러한 기술이 데이터 분석을 보다 효율적이고 강력하게 만드는 방법을 보여주기 위해 대규모 예측의 워크플로를 모방하는 몇 가지 최적화 기술을 다시 시작 일치 시나리오에 적용합니다. 블로그에 도입된 세 가지 주요 최적화 기술은 다음과 같습니다.</p>


  <ul>
   <li>전체 지속성 메모리 최적화 테이블</li>
   <li>CPU 선호도 및 메모리 할당</li>
   <li>리소스 거버넌스 및 동시 실행</li>
  </ul>


  <p>이 블로그 게시물은 위의 최적화 팁과 요령이 Azure SQL Server R Services에서 작동하는 방식에 대한 간단한 요약입니다. 이러한 최적화 기술은 R Services뿐만 아니라 SQL Server 통합된 모든 Machine Learning 서비스에서도 작동합니다. 샘플 코드 및 단계별 연습은 <a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">전체 자습서</a> 를 참조하세요.</p>


  <h1>샘플 사용 사례에 대한 설명</h1>


  <p>이 블로그와 관련 자습서 모두에 대한 샘플 사용 사례는 다시 시작 일치 예제입니다. 구직에 가장 적합한 후보자를 찾는 것은 오랫동안 노동 집약적이며 검색 에이전트의 많은 수동 노력이 필요한 예술이었습니다. 다양한 출처에서 수집된 방대한 양의 정보에서 특정 기술 또는 전문화된 자질을 가진 후보자를 찾는 방법은 새로운 큰 과제가 되었습니다. 우리는 기부 위치에 대한 이력서의 수백만 중 좋은 일치를 검색하는 모델을 개발했다. 이진 분류 문제로 공식화되는 기계 학습 모델은 이력서 및 작업 설명을 입력으로 사용하고 각 이력서 작업 쌍에 대해 좋은 일치가 될 확률을 생성합니다. 그런 다음, 사용자 정의 확률 임계값을 사용하여 모든 좋은 일치 항목을 추가로 필터링합니다.</p>


  <p>이 사용 사례의 주요 과제는 새 작업마다 적절한 시간 내에 수백만 개의 이력서와 일치시켜야 한다는 것입니다. 수천 개의 기능(이 경우 2600)을 생성하는 기능 엔지니어링 단계는 점수 매기기 중에 상당한 성능 병목 현상입니다. 따라서 이 사용 사례의 주요 목표는 낮은 일치(점수 매기기) 대기 시간을 달성하는 것입니다.</p>


  <h1>최적화</h1>


  <p>다양한 유형의 최적화 기술이 있으며, 이력서 일치 시나리오를 사용하여 몇 가지 방법을 논의할 예정입니다. 이 블로그에서는 이러한 최적화 기술이 높은 수준에서 작동하는 이유와 방법을 설명합니다. 자세한 설명 및 배경 지식은 포함된 참조 링크를 참조하세요. <a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">이 자습서</a>에서는 유사한 하드웨어 구성 및 SQL 스크립트를 사용하여 결과를 재현할 수 있어야 합니다.</p>


  <h2>메모리 액세스에 최적화된 테이블</h2>


  <p>요즘 메모리는 더 이상 크기와 속도 측면에서 최신 컴퓨터에 문제가 되지 않습니다. 사람들은 하드웨어의 발전과 함께 RAM&rsquo;의 가치를 얻을 &lsquo;수 있습니다. 그동안 데이터는 그 어느 때보다 빠르게 생성되었으며 일부 작업은 대기 시간이 짧은 데이터를 처리해야 합니다. 메모리 최적화 테이블은 하드웨어의 발전을 활용하여 이 문제를 해결할 수 있습니다. 메모리 최적화 테이블은 주로 메모리에 상주하므로 데이터를 메모리에서 읽고 메모리에 쓸 수 있습니다[1]. 그러나 내구성을 위해 테이블의 두 번째 복사본은 디스크에서 유지 관리되며 데이터는 데이터베이스 복구 중에 디스크에서만 읽습니다. 메모리를 사용하여 높은 확장성과 짧은 대기 시간으로 성능을 최적화할 수 있습니다. 특히 테이블 [2]에서 읽고 씁니다. 이 <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables" target="_blank">블로그 [1]</a>에서 메모리 최적화 테이블의 자세한 소개를 찾을 수 있습니다. 또한 이 <a href="https://www.youtube.com/watch?v=l5l5eophmK4" target="_blank">동영상 [3]을</a> 시청하여 OLTP를 In-Memory 사용할 때의 성능 이점에 대해 자세히 알아볼 수 있습니다.</p>


  <p>다시 시작 일치 시나리오에서는 데이터베이스의 모든 이력서 기능을 읽고 모든 기능을 새 작업 열기와 일치시켜야 합니다. 메모리 최적화 테이블을 사용하면 다시 시작 기능이 주 메모리에 저장되고 디스크 IO가 크게 줄어들 수 있습니다. 또한 모든 예측을 다른 일괄 처리에서 동시에 데이터베이스에 다시 작성해야 하므로 메모리 최적화 테이블을 사용하여 추가 성능 향상을 달성할 수 있습니다. SQL Server 메모리 최적화 테이블을 지원하여 테이블 읽기/쓰기 대기 시간이 짧아지고 개발 중에 원활한 환경을 구현했습니다. 전체 지속성 메모리 최적화 테이블은 데이터베이스 만들기와 함께 만들어졌습니다. 나머지 개발은 데이터가 저장되는 위치를 모르고 이전과 정확히 동일합니다.</p>


  <h2>CPU 선호도 및 메모리 할당</h2>


  <p>SQL Server 2014 SP2 이상 버전을 사용하면 SQL Server 서비스 [4, 5, 6]를 시작할 때 데이터베이스 인스턴스 수준에서 soft-NUMA가 자동으로 사용하도록 설정됩니다. 데이터베이스 엔진 서버가 NUMA 노드 또는 소켓당 8개 이상의 물리적 코어를 검색하는 경우 8개의 코어를 포함하는 소프트 NUMA 노드를 자동으로 만듭니다. 그러나 노드당 5개 또는 최대 9개의 논리 코어로 내려갈 수 있습니다. SQL Server 각 소켓에서 8개 이상의 물리적 코어를 검색할 때 로그 정보를 찾을 수 있습니다.</p>


  <p><img alt="SQL log of auto Soft-NUMA" border="0" height="97" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/b9bda84d-47b1-4939-94af-d4ca8559ca8c.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="자동 Soft-NUMA의 SQL 로그" width="891"></p>


  <p align="center"><strong>그림 1:</strong> 자동 Soft-NUMA의 SQL 로그, 4개의 소프트 NUMA 노드가 생성됨</p>


  <p>그림 1에 표시된 것처럼 테스트는 20개의 물리적 코어로 구성되었으며, 그 중 4개의 소프트 NUMA 노드가 자동으로 생성되어 각 노드에 5개의 코어가 포함됩니다. Soft-NUMA를 사용하면 노드당 서비스 스레드를 분할할 수 있으며 일반적으로 IO 및 지연 기록기 병목 상태를 줄여 확장성과 성능을 향상합니다. 그런 다음 4개의 SQL 리소스 풀과 4개의 외부 리소스 풀[7]을 만들어 각 노드에서 동일한 CPU 집합을 사용하는 CPU 선호도를 지정했습니다. 이렇게 하면 프로세스가 동일한 NUMA 노드 내에 있으므로 SQL Server 및 R 프로세스 모두 외장 메모리 액세스를 제거할 수 있습니다. 따라서 메모리 액세스 대기 시간을 줄일 수 있습니다. 그런 다음 이러한 리소스 풀을 다른 워크로드 그룹에 할당하여 하드웨어 리소스 사용을 향상시킵니다.</p>


  <p>소프트 NUMA 및 CPU 선호도는 각 실제 NUMA 노드에서 실제 메모리를 나눌 수 없습니다. 동일한 물리적 NUMA 노드의 모든 소프트 NUMA 노드는 동일한 OS 메모리 블록에서 메모리를 수신하며 메모리-프로세서 선호도는 없습니다. 그러나 SQL Server R 프로세스 간의 메모리 할당에 주의해야 합니다. 기본적으로 메모리의 20%만 R 서비스에 할당되며 대부분의 데이터 분석 작업에는 충분하지 않습니다. 자세한 내용은 <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/how-to-create-a-resource-pool-for-r" target="_blank">방법: R용 리소스 풀 만들기[7]</a> 를 참조하세요. 이 두 가지 간에 메모리 할당을 미세 조정해야 하며, 물론 최상의 구성은 대/소문자별로 다릅니다. 다시 시작 일치 사용 사례에서 가장 적합한 구성인 외부 메모리 리소스 할당을 70%로 늘렸습니다.</p>


  <h2>리소스 거버넌스 및 동시 채점</h2>


  <p>점수 매기기 문제를 강화하려면 수백만 개의 이력서를 여러 일괄 처리로 분할한 다음 여러 채점을 동시에 실행하는 맵 감소 접근 방식을 채택하는 것이 좋습니다. 병렬 처리 프레임워크는 그림 2에 나와 있습니다.</p>


  <p><img alt="Parallel processing" border="0" height="262" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d6e2a8aa-61c1-4bad-9064-56d2aaab0522.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="병렬 처리" width="610"></p>


  <p align="center"><strong>그림 2:</strong> 여러 일괄 처리의 병렬 처리 그림</p>


  <p>이러한 일괄 처리는 다른 CPU 집합에서 처리되며 결과가 수집되어 데이터베이스에 다시 기록됩니다. SQL Server 리소스 거버넌스는 이 아이디어를 구현하도록 설계되었습니다. 점수 매기기 일괄 처리를 다른 워크로드 그룹으로 라우팅하여 [8] SQL Server R 서비스에 대한 리소스 거버넌스를 만들 수 있습니다(그림). 3). 리소스 관리자에 대한 자세한 내용은 이 <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">블로그 [9]</a>에서 찾을 수 있습니다.</p>


  <p><img alt="Resource governer" border="0" height="522" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/234f97ea-43af-471e-932c-7df682979e70.gif" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="리소스 관리자" width="452"></p>


  <p align="center"><strong>그림 3:</strong> 리소스 관리자(<em>출신: <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor</a></em>)</p>


  <p>리소스 관리자는 분류자 함수 [10, 11]을 사용하여 워크로드 경쟁을 최소화하기 위해 SQL Server 사용 가능한 리소스(CPU 및 메모리)를 나눌 수 있습니다. 잠재적으로 실행을 개선하고 예측 가능한 성능을 제공하기 위해 여러 작업에 대해 SQL Server 다중 테넌트 및 리소스 격리를 제공합니다.</p>


  <h2>기타 트릭</h2>


  <p>R의 한 가지 문제는 기능 엔지니어링을 수행할 때 일반적으로 단일 CPU에서 처리된다는 것입니다. 이는 대부분의 데이터 분석 작업에 대한 주요 성능 병목 현상입니다. 이력서 일치 사용 사례에서는 원래 100개의 기능과 결합될 2,500개의 제품 간 기능을 생성해야 합니다(그림 4). 모든 작업이 단일 CPU에서 수행된 경우 이 전체 프로세스에는 상당한 시간이 걸립니다.</p>


  <p><img alt="Feature engineering" border="0" height="275" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/60dbc136-0d96-44a3-9b2f-4403263ca6bc.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="기능 엔지니어링" width="610"></p>


  <p align="center"><strong>그림 4:</strong> 이력서 일치 사용 사례의 기능 엔지니어링</p>


  <p>여기서 한 가지 트릭은 기능 엔지니어링을 위한 R 함수를 만들고 학습 중에 <em><strong>rxTransform</strong></em> 함수로 전달하는 것입니다. 기계 학습 알고리즘은 병렬 처리로 구현됩니다. 교육의 일환으로 기능 엔지니어링도 여러 CPU에서 처리됩니다. 학습 및 채점 전에 기능 엔지니어링이 수행되는 정기적인 접근 방식과 비교하여 점수 매기기 시간 측면에서 성능이 <strong>16%</strong> 향상되는 것을 관찰했습니다.</p>


  <p>잠재적으로 성능을 향상시킬 수 있는 또 다른 트릭은 R [12] 내에서 SQL 컴퓨팅 컨텍스트를 사용하는 것입니다. 다양한 일괄 처리 실행에 대한 리소스를 격리했으므로 각 일괄 처리에 대한 SQL 쿼리도 격리해야 합니다. SQL 컴퓨팅 컨텍스트를 사용하여 SQL 쿼리를 병렬화하여 테이블에서 데이터를 추출하고 동일한 워크로드 그룹의 데이터를 제한할 수 있습니다.</p>


  <h1>결과 및 결론</h1>


  <p>이러한 팁과 요령을 완벽하게 설명하기 위해 매우 자세한 단계별 <a href="https://gallery.cortanaintelligence.com/Tutorial/SQL-Server-Optimization-Tips-and-Tricks-for-Analytics-Services" target="_blank">자습서</a>를 게시했습니다. 110만 행의 데이터를 채점하기 위한 몇 가지 벤치마크 테스트도 수행되었습니다. <strong><em>RevoScaleR</em></strong> 및 <strong><em>MicrosoftML</em></strong> 패키지를 모두 사용하여 예측 모델을 별도로 학습했습니다. 그런 다음 최적화 없이 최적화를 사용하는 경우 점수 매기기 시간을 비교했습니다. 그림 5와 6은 RevoScaleR 및 MicrosoftML 패키지를 사용하여 최상의 성능 결과를 요약합니다. 동일한 SQL 쿼리 및 R 코드를 사용하여 동일한 Azure SQL Server VM에서 테스트를 수행했습니다. 일치하는 작업 하나에 대해 8개의 일괄 처리가 모든 테스트에서 사용되었습니다.</p>


  <p><img alt="RevoScaleR results" border="0" height="288" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/63e281b3-76aa-40f8-9acd-6d31a332c0e1.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="RevoScaleR 결과" width="480"></p>


  <p align="center"><strong>그림 5:</strong> RevoScaleR 채점 결과</p>


  <p><img alt="MicrosoftML results" border="0" height="288" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/d98ad558-6fc9-44a5-a5ff-fd0d4f399508.png" style="border-width: 0px; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;" title="MicrosoftML 결과" width="480"></p>


  <p align="center"><strong>그림 6:</strong> MicrosoftML 채점 결과</p>


  <p>결과는 기능 수가 점수 매기기 시간에 상당한 영향을 미친다는 것을 시사했습니다. 또한 이러한 최적화 팁과 요령을 사용하면 점수 매기기 시간 측면에서 성능이 크게 향상될 수 있습니다. 예측 모델에서 더 많은 기능을 사용하는 경우 향상된 기능이 더욱 두드러졌습니다.</p>


  <h1>Acknowledgement</h1>


  <p>마지막으로, 우마찬다르 자야칸드란, 아미트 배너지, 람쿠마르 찬드라세카란, Wee Hyong Tok, Xinwei Xue, James Ren, Lixin Gong, Ivan Popivanov, Costin Eseanu, Mario Bourgoin, Katherine Lin 및 Yiyu Chen에게 감사의 말씀을 전합니다.</p>


  <h1>참조</h1>


  <p><br>

  [1] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/introduction-to-memory-optimized-tables" target="_blank">Memory-Optimized 테이블 소개</a></p>


  <p>[2] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/in-memory-oltp/demonstration-performance-improvement-of-in-memory-oltp" target="_blank">데모: In-Memory OLTP의 성능 향상</a></p>


  <p>[3] <a href="https://www.youtube.com/watch?v=l5l5eophmK4" target="_blank">In-Memory OLTP를 설명하고 성능 이점을 보여주는 17분 분량의 비디오</a></p>


  <p>[4] <a href="https://technet.microsoft.com/en-us/library/ms178144(v=sql.105).aspx" target="_blank">균일하지 않은 메모리 액세스 이해</a></p>


  <p>[5] <a href="https://technet.microsoft.com/en-us/library/ms180954(v=sql.105).aspx" target="_blank">SQL Server NUMA를 지원하는 방법</a></p>


  <p>[6] <a href="https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/soft-numa-sql-server" target="_blank">소프트 NUMA(SQL Server)</a></p>


  <p>[7] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/how-to-create-a-resource-pool-for-r" target="_blank">방법: R용 리소스 풀 만들기</a></p>


  <p>[8] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/r/resource-governance-for-r-services" target="_blank">R Services에 대한 리소스 거버넌스</a></p>


  <p>[9] <a href="https://docs.microsoft.com/en-us/sql/relational-databases/resource-governor/resource-governor" target="_blank">리소스 관리자</a></p>


  <p>[10] <a href="https://technet.microsoft.com/en-us/library/bb895232(v=sql.105).aspx" target="_blank">리소스 관리자 소개</a></p>


  <p>[11] <a href="https://blog.sqlauthority.com/2012/06/04/sql-server-simple-example-to-configure-resource-governor-introduction-to-resource-governor/" target="_blank">SQL SERVER &ndash; 리소스 관리자 &ndash; 소개를 구성하는 간단한 예제</a></p>


  <p>[12] <a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/tutorials/deepdive-define-and-use-compute-contexts" target="_blank">컴퓨팅 컨텍스트 정의 및 사용</a></p>
