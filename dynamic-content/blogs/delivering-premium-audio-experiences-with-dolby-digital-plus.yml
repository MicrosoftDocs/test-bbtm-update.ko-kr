### YamlMime:Yaml
ms.openlocfilehash: c4c0f6e25c45c7c1a2b827df37e53aae2205e213
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139899285"
Slug: delivering-premium-audio-experiences-with-dolby-digital-plus
Title: Dolby® Digital Plus를 사용하여 Premium 오디오 환경 제공
Summary: Azure Media Encoder를 사용하여 Dolby® Digital Plus 다중 채널 서라운드 사운드로 콘텐츠를 인코딩하고 스마트 TV, Xbox, Windows 8 장치, 모바일 장치 등 여러 플랫폼에서 제공하는 방법을 알아봅니다.
Content: "미디어를 사용하는 디바이스가 확산하면서 사용자에게 우수한 오디오 품질을 제공하고 5.1 서라운드 사운드로 프리미엄 콘텐츠를 제공하기 위해 비디오 스트리밍 서비스에 대한 필요성이 증가하고 있습니다. Azure Media Services 사용하여 스마트 TV, Xbox, Windows 8 장치, 모바일 장치 등 여러 플랫폼에서 Dolby® Digital Plus 다중 채널 서라운드 사운드로 HD 콘텐츠를 인코딩할 수 있습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/08/Dolby_linear_Black.jpg\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border: 0px\" title=\"Dolby_linear_Black\" alt=\"Dolby_linear_Black\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Dolby_linear_Black_thumb.jpg\" width=\"360\" height=\"147\" border=\"0\" /></a>\n\nDolby® Digital Plus 또는 고급 AC-3(E-AC-3)은 고품질 오디오용으로 설계된 고급 서라운드 사운드 오디오 코덱입니다. 이 코덱은 영화, 방송 및 홈 시어터 서라운드 사운드에 대한 확립된 표준인 핵심 Dolby Digital 기술을 기반으로 하며 2.1 B 이상의 제품에서 지원됩니다. 이 블로그에서는 Media Services 사용하여 이 코덱을 사용하여 콘텐츠에 프리미엄 오디오 환경을 제공하는 방법을 설명합니다.\n<h1>개요</h1>\n이 예제에서 Dolby® Digital Plus로 인코딩하는 단계는 다음과 같습니다.\n<ol>\n <li>원본 콘텐츠를 Azure Media Services 계정에 업로드 자산 만들기</li>\n <li>사용자 지정 인코딩 사전 설정을 빌드하고 파일에 저장</li>\n <li>사용자 지정 사전 설정을 사용하여 위의 자산을 인코딩하는 작업 제출</li>\n <li>출력 자산을 게시하고 SAS URL 만들기</li>\n <li>애플리케이션에서 재생 시연</li>\n</ol>\n시작하려면 이러한 각 단계를 설명한 다음 사용한 샘플 코드를 제공하겠습니다.\n\n샘플 코드를 실행한 후에는 H.264 비디오 및 Dolby Digital Plus 오디오가 포함된 표준 MP4 파일의 URL이 생성됩니다. 그런 다음 이 URL을 사용하여 Dolby Digital Plus 디코딩을 지원하는 디바이스에서 스트림을 재생할 수 있습니다. Windows 8 Xbox에는 모두 기본 제공 Dolby Digital Plus 디코더가 있지만 Apple 장치는 현재 이 코덱을 기본적으로 지원하지 않습니다.Windows 8 및 플레이어 프레임워크를 사용하여 서라운드 사운드 디코딩을 테스트하는 방법에 대한 지침을 따르는 것이 좋습니다.전체 서라운드 사운드 영광의 파일을 듣고 싶다면 5.1 재생이 가능한 AV 수신기에 연결된 PC가 있어야 합니다.\n<h1>원본 콘텐츠 업로드</h1>\n시작하려면 먼저 HD 비디오 및 다중 채널 오디오를 사용하여 일부 원본 콘텐츠를 Media Service 계정에 업로드해야 합니다. 다음 파일 형식을 사용하는 것이 좋습니다.\n<ul>\n <li>AC-3으로 인코딩된 5.1 오디오가 있는 MPEG-2 전송 스트림(Dolby® Digital이라고도 함)</li>\n <li>AAC로 인코딩된 5.1 오디오가 있는 ISO MPEG-4(MP4) 파일</li>\n <li>WMA Professional 사용하여 인코딩된 5.1 오디오가 있는 WMV 파일</li>\n</ul>\n소스 파일을 업로드하는 샘플 코드는 <span style=\"font-family: Courier New\">CreateAssetAndUploadSingleFile</span>()을 참조하세요.\n<h1>사용자 지정 사전 설정 빌드</h1>\n사용자 지정 사전 설정을 처음 만드는 경우 고급 인코딩 기능에 대한 이전 게시물에서 사용자 지정 사전 설정을 만드는 방법에 대한 세부 정보를 검토하는 것이 좋습니다.\n\n다음으로, 원본을 4.5Mbps로 인코딩된 720p 비디오와 512kbps의 5.1 채널 Dolby Digital Plus 오디오가 있는 MP4 파일로 변환하기 위한 사용자 지정 사전 설정을 설명합니다. 이 사용자 지정 사전 설정은 \"<a href=\"https://msdn.microsoft.com/en-us/library/dn619402.aspx\">H264 광대역 720p</a>\" 사전 설정을 기반으로 합니다. 이 사전 설정의 <strong>AudioProfile&gt; 섹션은&lt;</strong> <a href=\"https://msdn.microsoft.com/en-us/library/dn296427.aspx\">Dolby Digital Plus 설정을</a> 사용하도록 수정되었습니다.\n<blockquote>참고: 이 예제와 같이 512kbps보다 낮은 비트 전송률을 사용하는 등 오디오 인코딩 설정을 조정하는 방법에 대한 자세한 내용은 다음을 참조하세요. <a href=\"https://msdn.microsoft.com/en-us/library/dn296500.aspx\">https://msdn.microsoft.com/en-us/library/dn296500.aspx</a></blockquote>\n완료된 XML 사용자 지정 사전 설정은 다음과 이며 인코딩에 사용할 로컬 파일에 저장해야 합니다. \"Dolby Audio Preset.xml\"라는 이름을 사용했습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-16\"?&gt;\n&lt;Presets&gt;\n &lt;Preset\n   Version=\"5.0\"&gt;\n   &lt;MediaFile\n     DeinterlaceMode=\"AutoPixelAdaptive\"\n     ResizeQuality=\"Super\"\n     VideoResizeMode=\"Stretch\"&gt;\n     &lt;OutputFormat&gt;\n       &lt;MP4OutputFormat\n         StreamCompatibility=\"Standard\"&gt;\n         &lt;VideoProfile&gt;\n           &lt;MainH264VideoProfile\n             BFrameCount=\"3\"\n             EntropyMode=\"Cabac\"\n             RDOptimizationMode=\"Speed\"\n             HadamardTransform=\"False\"\n             SubBlockMotionSearchMode=\"Speed\"\n             MultiReferenceMotionSearchMode=\"Balanced\"\n             ReferenceBFrames=\"False\"\n             AdaptiveBFrames=\"True\"\n             SceneChangeDetector=\"True\"\n             FastIntraDecisions=\"False\"\n             FastInterDecisions=\"False\"\n             SubPixelMode=\"Quarter\"\n             SliceCount=\"0\"\n             KeyFrameDistance=\"00:00:02\"\n             InLoopFilter=\"True\"\n             MEPartitionLevel=\"EightByEight\"\n             ReferenceFrames=\"4\"\n             SearchRange=\"64\"\n             AutoFit=\"True\"\n             Force16Pixels=\"False\"\n             FrameRate=\"0\"\n             SeparateFilesPerStream=\"True\"\n             SmoothStreaming=\"False\"\n             NumberOfEncoderThreads=\"0\"&gt;\n             &lt;Streams\n               AutoSize=\"False\"\n               FreezeSort=\"False\"&gt;\n               &lt;StreamInfo\n                 Size=\"1280, 720\"&gt;\n                 &lt;Bitrate&gt;\n                   &lt;ConstantBitrate\n                     Bitrate=\"4500\"\n                     IsTwoPass=\"False\"\n                     BufferWindow=\"00:00:05\" /&gt;\n                 &lt;/Bitrate&gt;\n               &lt;/StreamInfo&gt;\n             &lt;/Streams&gt;\n           &lt;/MainH264VideoProfile&gt;\n         &lt;/VideoProfile&gt;\n          &lt;AudioProfile&gt;\n            &lt;DolbyDigitalPlusAudioProfile\n              Codec=\"DolbyDigitalPlus\"\n              EncoderMode=\"DolbyDigitalPlus\"\n              AudioCodingMode=\"Mode32\"\n              LFEOn=\"True\"\n              SamplesPerSecond=\"48000\"\n              BandwidthLimitingLowpassFilter=\"True\"\n              DialogNormalization=\"-31\"&gt;\n              &lt;Bitrate&gt;\n                &lt;ConstantBitrate\n                  Bitrate=\"512\"\n                  IsTwoPass=\"False\"\n                  BufferWindow=\"00:00:00\" /&gt;\n              &lt;/Bitrate&gt;\n            &lt;/DolbyDigitalPlusAudioProfile&gt;\n\n          &lt;/AudioProfile&gt;  \n\n       &lt;/MP4OutputFormat&gt;\n     &lt;/OutputFormat&gt;\n   &lt;/MediaFile&gt;\n &lt;/Preset&gt;\n&lt;/Presets&gt;</pre>\n<h1>원본 콘텐츠 트랜스코딩</h1>\nWindows Azure Media Encoder를 사용하여 원본 콘텐츠를 트랜스코딩하여 사용자 지정 사전 설정의 콘텐츠를 구성 문자열로 Task에 전달할 수 있습니다. 관련된 단계는 아래 샘플 코드에서   <span style=\"font-family: Courier New\">theTranscode</span>() 메서드를 참조하세요. 이 태스크는 H.264로 인코딩된 비디오와 인터리빙된 Dolby Digital Plus 오디오가 있는 MP4 파일을 포함하는 출력 자산이 생성됩니다.\n<h1>출력 자산 게시</h1>\n콘텐츠가 트랜스코딩되면 출력 자산에 대한 SAS 로케이터를 만들 수 있습니다. 관련된 단계는 아래 샘플 코드에서 <span style=\"font-family: Courier New\">CreateSASLocator</span>()를 참조하세요. SAS URI는 플레이어 애플리케이션에 전달될 수 있습니다.\n<h1>샘플 코드</h1>\n이 항목의 코드는 <a href=\"https://www.nuget.org/packages/windowsazure.mediaservices.extensions\">Azure Media Services .NET SDK 확장을</a> 사용합니다. Media Services .NET SDK Extensions는 코드를 단순화하고 Media Services를 사용하여 더욱 쉽게 개발할 수 있도록 지원하는 일련의 확장 메서드 및 도우미 함수입니다.\n\n샘플 코드의 App.Config 파일은 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;</pre>\n위의 App.Config <strong>MediaAccountName&gt; 및 MediaAccountKey를 Media Services 계정 이름 및 키로 바꿉&lt;</strong> 있습니다.<strong> &gt;&lt;</strong>\n\n또한 Dolby에서 제공하는 단편 영화 \"Silent\"의 다음 샘플 5.1 서라운드 사운드 파일을 사용했습니다.\n원본 MP4 파일을 여기에서 다운로드하여 사용자 고유의 테스트에 사용할 수 있습니다.\n\n<a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Silent.jpg\"><img class=\"size-full wp-image-183481\" alt=\"Silent from Dolby\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Silent.jpg\" width=\"400\" height=\"168\" /></a>\n\n(©돌비 - 돌비의 자동 호의)\n\n사용되는 샘플 코드는 다음과 같습니다.\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace DeliveringPremiumAudio\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey =\n            ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString =\n            ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n\n        // Pointers to sample file, and the saved custom preset XML\n        private static readonly string _sampleFile = @\"C:\\temp\\sintel.wmv\";\n        private static readonly string _customPreset = @\"C:\\temp\\Dolby Audio Preset.xml\";\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the cached credentials to create the CloudMediaContext\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                // Step 1. Upload the sample content and create an Asset\n                IAsset inputAsset = CreateAssetAndUploadSingleFile(AssetCreationOptions.None, _sampleFile);\n\n                // Step 2. Load the custom preset into a configuration string\n                string configuration = File.ReadAllText(_customPreset);\n\n                // Step 3. Transcode the input\n                IAsset outputAsset = Transcode(inputAsset, configuration);\n\n                // Step 4. Create a SAS locator for the output asset and print to console\n                if (null != outputAsset) CreateSASLocator(outputAsset);\n\n                // The above method creates a locator valid for 30 days\n                // You should consider deleting the locator after the tests are complete\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates an empty Asset\n        /// &lt;/summary&gt;\n        static private IAsset CreateEmptyAsset(string assetName, AssetCreationOptions assetCreationOptions)\n        {\n            var asset = _context.Assets.Create(assetName, assetCreationOptions);\n            Console.WriteLine(\"Asset name: \" + asset.Name);\n            Console.WriteLine(\"Time created: \" + asset.Created.Date.ToString());\n\n            return asset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates an Asset and uploads the input file to it\n        /// &lt;/summary&gt;\n        static public IAsset CreateAssetAndUploadSingleFile(AssetCreationOptions assetCreationOptions, string singleFilePath)\n        {\n            var fileName = Path.GetFileName(singleFilePath);\n            // Create a unique asset name\n            var assetName = fileName + DateTime.UtcNow.ToString();\n            var asset = CreateEmptyAsset(assetName, assetCreationOptions);\n\n            var assetFile = asset.AssetFiles.Create(fileName);\n            Console.WriteLine(\"Created assetFile {0}\", assetFile.Name);\n\n            // In order to upload the file, we need a locator with the appropriate access policy\n            var accessPolicy = _context.AccessPolicies.Create(assetName, TimeSpan.FromDays(30),\n                                                                AccessPermissions.Write | AccessPermissions.List);\n            var locator = _context.Locators.CreateLocator(LocatorType.Sas, asset, accessPolicy);\n\n            assetFile.Upload(singleFilePath);\n            Console.WriteLine(\"Done uploading {0}\", assetFile.Name);\n            Console.WriteLine(\"\");\n            long size = assetFile.ContentFileSize;\n\n            locator.Delete();\n            accessPolicy.Delete();\n\n            return asset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function transcodes the source Asset using the preset provided, and return the output Asset\n        /// &lt;/summary&gt;\n        static public IAsset Transcode(IAsset sourceAsset, string preset)\n        {\n            // Declare a new job.\n            IJob job = _context.Jobs.Create(\"Transcoding Job for \" + sourceAsset.Name);\n            // Get a reference to Windows Azure Media Encoder, and pass to it the name of the \n            // processor to use for the specific task.\n            IMediaProcessor processor = GetLatestMediaProcessorByName(\"Windows Azure Media Encoder\");\n\n            // Create a task with the encoding details, using a string preset.\n            ITask task = job.Tasks.AddNew(\"Transcoding Task for \" + sourceAsset.Name,\n                processor,\n                preset,\n                Microsoft.WindowsAzure.MediaServices.Client.TaskOptions.None);\n\n            // Specify the source asset to be encoded.\n            task.InputAssets.Add(sourceAsset);\n            // Add an output asset to contain the results of the job. \n            // This output is specified as AssetCreationOptions.None, which \n            // means the output asset is not encrypted. \n            task.OutputAssets.AddNew(\"Output asset\", AssetCreationOptions.None);\n\n            // Use the following event handler to check job progress.  \n            job.StateChanged += new\n                    EventHandler&lt;JobStateChangedEventArgs&gt;(StateChanged);\n\n            // Launch the job.\n            job.Submit();\n\n            // Check job execution and wait for job to finish. \n            Task progressJobTask = job.GetExecutionProgressTask(CancellationToken.None);\n            progressJobTask.Wait();\n\n            // Get an updated job reference.\n            job = GetJob(job.Id);\n\n            // If job state is Error the event handling \n            // method for job progress should log errors.  Here we check \n            // for error state and exit if needed.\n            if (job.State == JobState.Error)\n            {\n                Console.WriteLine(\"Transcode() failed, exiting...\");\n                return null;\n            }\n\n            // Get a reference to the output asset from the job.\n            IAsset outAsset = job.OutputMediaAssets[0];\n\n            return outAsset;\n        }\n\n        /// &lt;summary&gt;\n        /// This function returns a reference to the latest version of the specified media processor\n        /// &lt;/summary&gt;\n        private static IMediaProcessor GetLatestMediaProcessorByName(string mediaProcessorName)\n        {\n            var processor = _context.MediaProcessors.Where(p =&gt; p.Name == mediaProcessorName).\n                ToList().OrderBy(p =&gt; new Version(p.Version)).LastOrDefault();\n\n            if (processor == null)\n                throw new ArgumentException(string.Format(\"Unknown media processor\", mediaProcessorName));\n\n            return processor;\n        }\n\n        /// &lt;summary&gt;\n        /// A helper method to handle events\n        /// &lt;/summary&gt;\n        private static void StateChanged(object sender, JobStateChangedEventArgs e)\n        {\n            Console.WriteLine(\"Job state changed event:\");\n            Console.WriteLine(\"  Previous state: \" + e.PreviousState);\n            Console.WriteLine(\"  Current state: \" + e.CurrentState);\n\n            switch (e.CurrentState)\n            {\n                case JobState.Finished:\n                    Console.WriteLine();\n                    Console.WriteLine(\"********************\");\n                    Console.WriteLine(\"Job is finished.\");\n                    Console.WriteLine(\"Please wait while local tasks or downloads complete...\");\n                    Console.WriteLine(\"********************\");\n                    Console.WriteLine();\n                    Console.WriteLine();\n                    break;\n                case JobState.Canceling:\n                case JobState.Queued:\n                case JobState.Scheduled:\n                case JobState.Processing:\n                    Console.WriteLine(\"Please wait...\\n\");\n                    break;\n                case JobState.Canceled:\n                case JobState.Error:\n                    // Cast sender as a job.\n                    IJob job = (IJob)sender;\n                    // Display or log error details as needed.\n                    LogJobStop(job.Id);\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// A helper method to log information about a failed Job\n        /// &lt;/summary&gt;\n        private static void LogJobStop(string jobId)\n        {\n            StringBuilder builder = new StringBuilder();\n            IJob job = GetJob(jobId);\n\n            builder.AppendLine(\"\\nThe job stopped due to cancellation or an error.\");\n            builder.AppendLine(\"***************************\");\n            builder.AppendLine(\"Job ID: \" + job.Id);\n            builder.AppendLine(\"Job Name: \" + job.Name);\n            builder.AppendLine(\"Job State: \" + job.State.ToString());\n            builder.AppendLine(\"Job started (server UTC time): \" + job.StartTime.ToString());\n            // Log job errors if they exist.  \n            if (job.State == JobState.Error)\n            {\n                builder.Append(\"Error Details: \\n\");\n                foreach (ITask task in job.Tasks)\n                {\n                    foreach (ErrorDetail detail in task.ErrorDetails)\n                    {\n                        builder.AppendLine(\"  Task Id: \" + task.Id);\n                        builder.AppendLine(\"    Error Code: \" + detail.Code);\n                        builder.AppendLine(\"    Error Message: \" + detail.Message + \"\\n\");\n                    }\n                }\n            }\n            builder.AppendLine(\"***************************\\n\");\n            Console.Write(builder.ToString());\n        }\n\n        /// &lt;summary&gt;\n        /// This function creates a SAS locator for the given Asset\n        /// &lt;/summary&gt;\n        private static void CreateSASLocator(IAsset asset)\n        {\n            Console.WriteLine(\"Publishing asset \" + asset.Name);\n            // Publish the output asset by creating an Origin locator.  \n            // Define the Read only access policy and\n            // specify that the asset can be accessed for 30 days.  \n            _context.Locators.Create(\n                LocatorType.Sas,\n                asset,\n                AccessPermissions.Read,\n                TimeSpan.FromDays(30));\n\n            // Generate a SAS Locator for the MP4 file.\n            var mp4AssetFile = asset.AssetFiles.ToList().Where(f =&gt; f.Name.EndsWith(\".mp4\", StringComparison.OrdinalIgnoreCase)).FirstOrDefault();\n            Uri mp4Uri = mp4AssetFile.GetSasUri();\n            Console.WriteLine(\"Output is now available for progressive download: \");\n            Console.WriteLine(mp4Uri.OriginalString);\n\n            return;\n        }\n    }\n}</pre>\n<h1></h1>\n<h1>재생 데모</h1>\n재생을 보여 주는 간단한 방법은 Windows 8.1 Windows Media Player 애플리케이션을 시작하고 File\\Open URL로 이동한 다음 인코딩된 자산에 SAS 로케이터를 입력하는 것입니다.\nPC가 5.1 재생이 가능한 AV 수신기에 연결한 경우 전체 5.1 서라운드의 출력을 들을 수 있습니다.\n\n여기에서 인코딩 작업 샘플의 출력을 다운로드할 수 있습니다.\n<h1>고려 사항</h1>\n<h2>스테레오 오디오를 사용하여 콘텐츠 인코딩</h2>\n입력 자산에 스테레오 오디오가 있는 경우 Azure Media Encoder는 서라운드 채널에 침묵을 삽입합니다. 출력 자산에는 여전히 5.1 오디오가 있습니다. 무음 삽입은 출력 콘텐츠를 부드러운 스트리밍으로 제공할 때만 권장됩니다.\n\n또는 인<a href=\"https://msdn.microsoft.com/en-us/library/dn296428.aspx\">코딩의</a><strong> &lt;XML에서 Dolby Digital Plus 스테레오로 문서화된 설정을 사용하여 DolbyDigitalPlusAudioProfile&gt;</strong> 요소를 스테레오 출력으로 인코딩하도록 수정할 수 있습니다.\n<h2>부드러운 스트리밍을 통해 Dolby Digital Plus 오디오 스트리밍</h2>\nDolby Digital Plus 오디오를 Windows 8.1 최신 애플리케이션에 제공하거나 부드러운 스트리밍을 통해 Xbox One 수 있습니다. 이렇게 하려면 다음과 같이 샘플 코드를 수정해야 합니다.\n<ul>\n <li>이 예제의 사용자 지정 사전 설정에서 <strong>VideoProfile&gt;을 \"H264 적응 비트 전송률 MP4 Set 720p\" 사전 설정의 비디오 파일로 바꿉니다.&lt;</strong><a href=\"https://msdn.microsoft.com/en-us/library/dn619413.aspx\"></a></li>\n <li>SAS URL을 만드는 대신 Azure Media Services <a href=\"https://www.nuget.org/packages/windowsazure.mediaservices.extensions\">.NET SDK 확장</a>에서 사용할 수 있는 <span style=\"font-family: Courier New\">GetSmoothStreamingUri</span>() 도우미 메서드를 사용합니다.</li>\n</ul>\n그런 다음 Windows 8 부드러운 스트리밍 클라이언트 SDK를 사용하여 Windows 8 최신 애플리케이션을 빌드해야 합니다.Dolby 콘텐츠를 재생하기 위해 부드러운 스트리밍 클라이언트 SDK를 사용하여 애플리케이션을 빌드하는 방법에 대한 자세한 내용은 \"<a href=\"https://azure.microsoft.com/en-us/documentation/articles/media-services-build-smooth-streaming-apps/\" target=\"_blank\">부드러운 스트리밍 Windows 스토어 애플리케이션을 빌드하는 방법</a>\" 문서를 참조하세요.\n\nDolby 디코더(예: Apple iOS)는 현재 모든 플랫폼에서 사용할 수 없지만, 셋톱 박스 및 스마트 TV와 같은 디바이스에서 Dolby의 디코딩을 지원하는 다른 많은 클라이언트 프레임워크가 시장에 출시되고 있습니다. 다른 디바이스에 연결하려는 경우 지원되는 디코더에 대해 제조업체에 문의해야 합니다.\n<h2>Dolby Professional 음량 계량 사용</h2>\n과거에는 멀티채널 오디오를 사용하는 방송사에서 평균 수준이 다른 프로그래밍보다 높거나 낮은 사운드트랙에 문제가 있었습니다. 프로그램이 휴식 시간 동안 정말 큰 소리로 광고로 전환 할 때 당신은 이것을 직접 경험했을 수 있습니다.또한 스테레오 또는 모노 오디오 출력을 사용하여 TV 세트에서 서라운드 사운드 콘텐츠를 재생할 때 문제가 발생했습니다.Dolby의 이 <a href=\"https://www.dolby.com/uploadedFiles/Assets/US/Doc/Professional/17_.AllMetadata.pdf\">보고서에서</a> 설명한 것처럼 다중 채널 오디오로 작업할 때 발생하는 일반적인 문제는 여러 프로그램에서 일관된 음질을 유지하는 것입니다. 이 문제를 해결하려면 Dolby Digital Plus 스트림 내에서 대화 상자 수준 매개 변수(대화 정규화 또는 DialNorm)를 지정하는 것이 좋습니다. 이 값은 오디오 볼륨을 미리 설정된 수준으로 설정하여 디코더가 한 프로그램에서 다른 프로그램으로 일치하도록 돕고 방해되는 볼륨 변경을 제거합니다.\n\n위에 제공된 사전 설정에서는 원본 콘텐츠에 대한 기본 대화 상자 정규화 값이 -31 dB라고 가정합니다.원본 콘텐츠에서 대화 상자의 실제 음량을 측정하고 대화 정규화에 올바른 값을 설정하는 방법을 알아보려면 \"<a href=\"https://msdn.microsoft.com/en-us/library/dn296426.aspx\">Dolby Professional DPLM(음량 계량) 지원 사용</a>\" 섹션을 참조하세요.\n\nDolby Digital Plus 기술에 대해 자세히 알아보려면 이 <a href=\"https://www.dolby.com/us/en/technologies/dolby-digital-plus.html\">Dolby 페이지에서</a> 파트너가 제공하는 세부 정보를 살펴보세요."
