### YamlMime:Yaml
ms.openlocfilehash: 5d0db355477fe76d7908e0ece35b6fe6e3026de9
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901976"
Slug: vm-image-powershell-how-to-blog-post
Title: VM 이미지 PowerShell '방법' 블로그 게시물
Summary: >-
  편집자 주: 이 게시물은 케이 싱, 프로그램 관리자, Microsoft Azure 엔지니어링과 함께 작성되었습니다.


  내 첫 번째 블로그 게시물에서 약속대로, 나는 에서 VM 이미지로 작업하는 방법을 안내하기 위해 돌아왔다 ...
Content: "편집자 주: 이 게시물은 케이 싱, 프로그램 관리자, Microsoft Azure 엔지니어링과 함께 작성되었습니다.\n\n첫 번째 블로그 게시물에서 약속했듯이 PowerShell에서 VM 이미지로 작업하는 방법을 안내하기 위해 돌아왔습니다.저는 컴퓨팅 cmdlet을 담당하는 동료 Kay, PowerShell PM에게 세부 사항 중 일부를 설명하는 데 참여해 달라고 요청했습니다.바라건대, 당신은 VM 이미지와 함께 조금 놀 수있는 기회를 가졌고 지금 며칠 동안이 블로그 게시물을 기대하고있다.그래... 나는 여기에 내 흥분으로 멀리 걱정되고있을 수 있습니다.\n\n앞서 설명한 것처럼 VM 이미지는 OS 이미지의 후속 작업이며 두 엔터티에는 많은 유사점이 있습니다.VM 이미지 기능이 개발되면 OS 이미지를 캡슐화하는 것으로 생각할 수 있습니다.VM 이미지와 OS 이미지를 두 개의 개별 엔터티로 논의하는 동안 PowerShell은 단일 'über' 이미지 엔터티와 함께 작동합니다.따라서 OS 이미지를 사용할 때 익숙한 많은 PowerShell cmdlet이 VM 이미지에 적용됩니다.\n\n시작하려면 OS 이미지 PowerShell 지식을 간략하게 살펴보겠습니다.OS 이미지를 만들고 나열하고 삭제하기 위해 기억할 수 있듯이 다음 PowerShell 코드 조각을 사용할 수 있습니다.\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"myServiceName\" –Name \"myVMtoCapture\" –ImageName \"myAwesomeOSImage\" –ImageLabel \"This is my OS Image\"\n\nGet-AzureVMImage\n\nRemove-AzureVMImage –ImageName \"myAwesomeOSImage\"</pre>\n다음 PowerShell 코드 조각을 사용하여 새로 만든 OS 이미지에서 VM을 배포할 수 있습니다.\n<pre class=\"prettyprint\">New-AzureQuickVM –Windows –Location \"West US\" –ServiceName \"MySvc1\" –Name \"myVM1\" –InstanceSize \"Medium\" –ImageName \"myAwesomeOSImage\" –AdminUsername \"admin\"–Password \"adminPassword123\" -WaitForBoot</pre>\n또는,\n<pre class=\"prettyprint\">New-AzureVMConfig -Name \"myVM1\" -InstanceSize \"Medium\" -ImageName \"myAwesomeOSImage\" |\n\nAdd-AzureProvisioningConfig -Windows -AdminUsername \"admin\" -Password \"adminPassword123\" |\n\nNew-AzureVM –ServiceName \"MySvc1\" -WaitForBoot</pre>\n바라건대, 지금까지의 모든 것이 새로 고침이며 우리는 VM 이미지로 다이빙을 시작할 수 있습니다.\n<h4>캡처할 VM 만들기</h4>\nVM 이미지 특정 부분을 시작하기 전에 작업할 가상 머신이 필요합니다.위에서 설명한 내용을 사용하여 두 개의 데이터 디스크가 있는 SQL Server 2014를 실행하는 가상 머신을 배포해 보겠습니다.SQL Server 2014 RTM DataWarehousing의 4월 릴리스를 사용하여 가상 머신을 만드는 스크립트는 다음과 같습니다.\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"fb83b3509582419d99629ce476bcb5c8__SQL-Server-2014RTM-12.0.2000.8-DataWarehousing-ENU-WS2012R2-AprilGA\"\n\n$user = \"admin\"\n$pass = \"adminPassword123\"\n\n$myVM = New-AzureVMConfig -Name \"myVMToCapture2\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n        | Add-AzureProvisioningConfig -Windows -AdminUsername $user -Password $pass `\n        | Add-AzureDataDisk -CreateNew -DiskSizeInGB 10 -DiskLabel \"DataDisk1\" -LUN 0 `\n        | Add-AzureDataDisk -CreateNew -DiskSizeInGB 10 -DiskLabel \"DataDisk2\" -LUN 1\n\nNew-AzureVM -ServiceName \"MySvc2\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\n<h4>VM을 일반화된 VM 또는 특수화된 VM 이미지로 캡처</h4>\n가상 머신을 캡처하기 전에 일반화된 캡처 또는 특수 캡처를 사용할지 여부를 결정해야 합니다.이전 블로그 게시물에서 언급했듯이 일반화된 VM 이미지는 유사한 가상 머신을 신속하게 스탬핑하는 \"모델\"로 사용됩니다.OS 이미지에서도 비슷한 기능을 사용할 수 있습니다.특수 VM 이미지는 새로운 기능이며 잘못되어 가상 머신을 쓸모 없게 렌더링할 수 있는 작업을 수행하기 전에 잘 알려진 시점에 VM을 배포하기 위한 \"스냅샷\"으로 사용됩니다.\n\n캡처를 위해 가상 머신을 준비하려면 몇 가지 추가 단계를 수행해야 합니다.일반화된 Windows 서버 VM 이미지를 캡처하려면 Microsoft Azure 문서에서 설명한 단계를 수행<a href=\"https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-capture-image-windows-server/\">하여 Windows Server를 실행하는 Virtual Machine의 이미지를 캡처하는 방법을</a> 확인할 수 있습니다.Linux VM 이미지를 캡처하려면 유사한 문서인 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-capture-image/\">Linux를 실행하는 Virtual Machine의 이미지를 캡처하는 방법을</a> 따를 수 있습니다.\n\n이제 가상 머신을 VM 이미지로 실제로 캡처합니다. 캡처 프로세스는 OS 이미지와 비슷합니다. 기존 Save-AzureVMImage cmdlet을 사용해야 하지만 OS 이미지 또는 VM 이미지를 캡처할지 여부를 결정하는 새 매개 변수를 포함해야 합니다.\n\n먼저 myFirstVMImage를 호출하여 일반화된 VM 이미지를 캡처해 보겠습니다.\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"mySvc2\" –Name \"MyVMToCapture2\" –ImageName \"myFirstVMImage\" –OSState \"Generalized\" -Verbose</pre>\n대신 특수한 VM 이미지를 캡처하려는 경우 다음 코드 조각을 사용할 수 있습니다.\n<pre class=\"prettyprint\">Save-AzureVMImage –ServiceName \"mySvc2\" –Name \"MyVMToCapture2\" –ImageName \"myFirstVMImageSP\" –OSState \"Specialized\" -Verbose</pre>\nOSState 매개 변수를 사용하면 VM 이미지를 캡처하려는 의도가 지정됩니다.이 매개 변수를 사용하지 않으면 이 cmdlet은 OS 이미지를 캡처합니다.OS 이미지는 항상 '일반화'로 간주되므로 OSState 매개 변수는 필요하지 않습니다.\n\n한 가지 팁은 이름이 같은 두 개의 이미지(VM 이미지 및 OS 이미지)를 만들지 않는 것이 좋습니다.Microsoft Azure 플랫폼에서 이를 허용하지만 플랫폼이 의도를 확인할 수 없으므로 문제가 발생할 수 있습니다.\n\n중복이 어떻게 발생할 수 있는지 궁금할 수 있습니다.한 클라이언트(예: PowerShell)에서 VM 이미지를 만든 다음 다른 클라이언트(포털)에서 OS 이미지를 만드는 경우 중복된 이름이 발생할 수 있습니다.OS 이미지 및 VM 이미지를 만드는 데만 PowerShell을 사용하는 경우 Save-AzureVMImage cmdlet은 명명의 유효성을 검사하고 동일한 이름의 VM 이미지 및 OS 이미지를 만들면 오류가 발생합니다.\n<h4>VM 이미지 나열</h4>\n이전에 다시 적용한 것처럼 Get-AzureVMImage cmdlet을 사용하면 사용자 및 게시된 OS 이미지가 모두 나열됩니다.그렇지만 잠시 기다리세요.지금 cmdlet을 실행하면 방금 캡처한 VM 이미지가 실제로 표시됩니다.당신이 우리를 믿지 않는 경우, 다음 PowerShell 조각을 시도!\n<pre class=\"prettyprint\">Get-AzureVMImage | Select -Property Label, ImageName | Format-Table -Wrap</pre>\n기존 Get-AzureVMImage cmdlet은 OS 이미지뿐만 아니라 사용자 및 게시된 VM 이미지도 반환합니다.VM 이미지만 나열하려면 DataDiskConfiguration과 같은 VM 이미지에만 적용되는 속성을 필터링할 수 있습니다.\n<pre class=\"prettyprint\">Get-AzureVMImage | where {(gm –InputObject $_ -Name DataDiskConfigurations) -ne $null} | Select -Property Label, ImageName</pre>\n<h4>VM 이미지 삭제</h4>\nVM 이미지를 삭제하는 것은 OS 이미지를 삭제하는 것과 같습니다.\n<pre class=\"prettyprint\">Remove-AzureVMImage –ImageName $img –DeleteVHD;</pre>\n동일한 이름의 이미지가 두 개 있는 경우 플랫폼이 의도를 확인할 수 없다는 점을 기억하십니까?위의 cmdlet은 잘못된 이미지를 삭제하지 않도록 이 상황에서 오류가 발생합니다.OS 이미지를 삭제하려면 PowerShell에서 포털 또는 Invoke-Rest URI 메서드를 사용하여 REST API를 직접 호출해야 합니다.VM 이미지를 삭제하려면 PowerShell에서 Invoke-Rest URI 메서드도 사용할 수 있습니다.이미지 중 하나가 삭제되면 Remove-AzureVMImage cmdlet을 다시 사용할 수 있습니다.이 상황에 처한 경우 Invoke-RestMethod cmdlet을 사용하여 VM 이미지를 삭제하는 PowerShell 코드 조각은 다음과 같습니다.\n<pre class=\"prettyprint\"># Delete VM Image API Documentation - https://msdn.microsoft.com/en-us/library/azure/dn499769.aspx \n#-------------------------------------------------------------------------------------#\n# Method | Request URI \n#-------------------------------------------------------------------------------------#\n# DELETE | https://management.core.windows.net/&lt;subscription-id&gt;/services/vmimages/&lt;image-name&gt;?comp=media \n#-------------------------------------------------------------------------------------# \n\n$cert = (Get-AzureSubscription).Certificate.Thumbprint \n$subid =  (Get-AzureSubscription).SubscriptionId \n$vmimgname = ‘myFirstVMImage’\n$uri = \"https://management.core.windows.net/$subid/services/vmimages/$vmimgname\" + \"?comp=media\" \n\n$header = @{\"x-ms-version\" = \"2014-02-01\";}\n\nInvoke-RestMethod -Uri $uri -Method Delete -ContentType \"application/xml\" -Headers $header -CertificateThumbprint $cert</pre>\n<h4>일반화된 VM 또는 특수화된 VM 이미지에서 VM 배포</h4>\n일반화된 VM 이미지에서 배포하는 것은 두 이미지가 모두 일반화되므로 OS 이미지에서 배포하는 것과 비슷합니다.주요 차이점은 VM 이미지에서 배포할 때 데이터 디스크를 추가할 수 없다는 것입니다.VM 이미지에는 처음에 가상 머신에 추가하려는 데이터 디스크가 이미 포함되어 있어야 합니다.가상 머신이 배포되면 모든 VM과 마찬가지로 디스크를 연결하거나 분리할 수 있습니다.\n\nRemove-AzureVMImage와 마찬가지로 플랫폼은 동일한 이름의 두 이미지가 있는 경우 이미지를 확인하려고 합니다.참조된 이미지가 OS 이미지인지 VM 이미지인지 고유하게 확인할 수 없는 경우 오류가 발생합니다.\n\n아래 PowerShell 코드 조각은 앞에서 만든 VM 이미지(myFirstVMImage)를 사용하여 대규모 가상 머신 인스턴스를 배포합니다.\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"myFirstVMImage\"\n\n$user = \"admin\"\n$pass = \"adminPassword123\"\n\n$myVM = New-AzureVMConfig -Name \"VMImageVM\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n       | Add-AzureProvisioningConfig -Windows -AdminUsername $user -Password $pass\n\nNew-AzureVM -ServiceName \"VMImageCloudService\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\n이제 약간 다르므로 특수한 VM 이미지에서 배포하는 방법을 살펴보겠습니다.이 경우 이미지가 일반화되지 않으므로 프로비전 구성이 필요하지 않습니다.특수한 VM 이미지를 사용하는 것은 디스크를 사용하는 것과 비슷합니다.사용자 이름 및 암호는 원래(캡처된) 가상 머신과 동일합니다. 스크립트 코드 조각은 다음과 같습니다.\n<pre class=\"prettyprint\">$img = Get-AzureVMImage -ImageName \"myFirstVMImageSP\"\n\n$myVM = New-AzureVMConfig -Name \"VMImageVMSP\" -InstanceSize \"Large\" -ImageName $img.ImageName `\n| Add-AzureProvisioningConfig -Windows\n\nNew-AzureVM -ServiceName \"VMImageCloudService\" -VMs $myVM -Location \"West US\" -WaitForBoot</pre>\n너무 길나요? 읽지 않았나요? 주요 사항을 요약해 보겠습니다.<em></em>\n<ul>\n <li>VM 이미지는 '일반화' 또는 '특수화'될 수 있지만 OS 이미지는 '일반화'만 가능합니다.</li>\n <li>선택적 –OSState 매개 변수의 사용은 Save-AzureVMImage cmdlet을 사용하여 OS 이미지 대신 VM 이미지를 저장하려는 의도를 전달합니다.</li>\n <li>Save-AzureVMImage cmdlet은 이름이 같은 VM 이미지 또는 OS 이미지의 캡처를 허용하지 않지만 여러 클라이언트를 사용하는 경우 주의해야 합니다.</li>\n <li>이제 Get-AzureVMImage VM 이미지뿐만 아니라 OS 이미지를 반환합니다.</li>\n <li>Remove-AzureVMImage cmdlet은 플랫폼에서 사용자 의도를 확인할 수 없으므로 이름이 OS 이미지와 VM 이미지를 모두 참조할 때 삭제를 차단합니다.</li>\n</ul>\nPowerShell 연습이 유용하다는 것을 알게 되었으면 합니다.질문이나 의견이 있는 경우 자유롭게 연락해 주세요!\n\n곧 다시 얘기하십시오....\n\n크리스틴과 케이\n\n2014년 6월 16일 업데이트: Get-AzureVMImage 사용하여 OS 이미지를 필터링하는 PowerShell 코드 조각이 수정되었습니다."
