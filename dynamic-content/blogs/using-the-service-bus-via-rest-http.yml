### YamlMime:Yaml
ms.openlocfilehash: a1e22b9fbc6ae5a472ffe2aa7f53da184983f2be
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903421"
Slug: using-the-service-bus-via-rest-http
Title: REST/HTTP를 통해 서비스 버스 사용
Summary: '[이 문서는 AppFabric 팀에서 제공했습니다.]  2011년 5월 CTP와 함께 도입된 새로운 Service Bus 지속성 메시징 기능은 정말 멋지며, 새로운 기능보다 더 좋은 것은 무엇일까요?'
Content: "<p>[이 문서는 AppFabric 팀에서 제공했습니다.]</p>  <p>2011년 5월 CTP에서 도입된 <a href=\"https://blogs.msdn.com/b/appfabric/archive/2011/05/14/announcing-the-windows-azure-appfabric-ctp-may-and-june-releases.aspx\">새로운 Service Bus 지속성 메시징 기능은</a> 정말 멋지며, AppFabric에 추가된 새로운 메시징 기능보다 훨씬 더 좋은 점은 HTTP를 사용하는 플랫폼의 클라이언트에서 액세스할 수 있다는 사실입니다. 이 게시물에서 메시징에 대한 Service Bus REST 엔드포인트를 사용하는 방법을 소개합니다. 그 중 일부는 <a href=\"https://blogs.msdn.com/b/willpe/archive/2010/11/01/getting-started-with-service-bus-v2-october-ctp-connection-points.aspx\">10 월 CTP</a>를 생각 나게 할 수 있습니다, 우리는 큐를 사용할 것입니다 (그래서 화요일에서 <a href=\"https://blogs.msdn.com/b/appfabric/archive/2011/05/17/an-introduction-to-service-bus-queues.aspx\">데이비드의 게시물을</a> 살펴 보는 것은 좋은 생각이 될 수 있습니다), <a href=\"https://blogs.msdn.com/b/willpe/archive/2011/05/12/getting-access-control-service-tokens-via-http.aspx\">그리고 HTTP를 통해 액세스 제어 토큰이 작동하는 방법에</a> 그립에 점점 좋은 입문서가 될 것입니다,  너무.</p>  <h3>RESTful Service Bus 대한 서문</h3>  <p>일반적으로 Service Bus 사용자는 AppFabric SDK를 다운로드하여 설치하고, Microsoft.ServiceBus 및/또는 <i>Microsoft.ServiceBus.Messaging</i>에 대한 참조를 추가하고, <a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.servicebusnamespaceclient.aspx\">ServiceBusNamespaceClient</a>를 사용하여 관리 작업(큐, 토픽 또는 구독 만들기, 열거 및 삭제) 또는 메시지 보내기 및 받기를 위한 <a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.messagingfactory.aspx\">MessagingFactory를</a> 수행합니다.<i></i> 주소 지정 및 보안과 같은 세부 정보는 SDK에서 처리합니다. Access Control Service 토큰을 가져오거나 갱신할 필요가 없으며 서비스와 직접 상호 작용할 필요가 없습니다. SDK만 사용합니다. REST 엔드포인트를 사용하면 금속에 조금 더 가까워질 수 있으며, 이 괴짜의 겸손한 의견으로는 적어도 조금 더 재미있을 수 있습니다! </p>  <p>가능한 경우 SDK를 사용하려고 합니다. 그것은 서비스의 기본 복잡성 중 일부에서 당신을 쉐일링, 기능이 미래에 변경으로 당신을 보호하는 데 도움이 될 수 있습니다 - 솔직히 - 그것은 단지 훨씬 쉽습니다. 즉, SDK를 사용할 수 없는 경우가 많이 있습니다. 예를 들어 데스크톱이 아닌 .Net Framework 버전(예: Windows Phone 7 또는 Silverlight)에서 작업하는 경우, 타사 플랫폼(예: iOS, Android, Java, PHP 또는 Ruby)에서 작업하는 경우 및 이전 버전의 .Net Framework로 작업할 때입니다.</p>  <p>편의성과 일관성을 위해 이 게시물의 코드 샘플은 C#에 표시됩니다. iOS, PHP 또는 Ruby의 Service Bus 사용할 때 C#으로 작성했기 때문은 아닙니다. 저는 오늘 많은 사용자가 잘 알고 있는 언어에서 REST API를 사용하는 몇 가지 기본 사항을 보여 주는 데 집중하고 싶습니다. 즉, 플랫폼 및 장치에서 Service Bus 사용하여 할 수 있는 멋진 작업을 보여주는 다양한 언어로 향후 게시물을 기대할 수 있습니다.</p>  <p>당신이 시작하기 위해이 게시물에서 다룰 5 가지가 있습니다 - 의견 (아래) 또는 <a href=\"https://social.msdn.microsoft.com/Forums/en-US/appfabricctp/\">AppFabric CTP 포럼</a>에서 더 자세한 내용, 예제 및 지침을 원하는 영역에 대한 피드백을 남겨주세요. </p>  <ol>  <li>Access Control Service에서 보안 토큰 가져오기 </li>  <li>서비스 네임스페이스에 큐 만들기 </li>  <li>큐로 메시지 보내기 </li>  <li>큐에서 메시지 받기 </li>  <li>큐 삭제 </li>  </ol>  <p>사용량이 많아질 예정이므로 <a href=\"https://portal.appfabriclabs.com/\">AppFabric Labs 포털</a>에 계정이 설정되어 있는지 확인하고 시작 수 있습니다!</p>  <h3>보안 토큰 가져오기 및 사용</h3>  <p>지난 주, <a href=\"https://blogs.msdn.com/b/willpe/archive/2011/05/12/getting-access-control-service-tokens-via-http.aspx\">HTTP를 통해 액세스 제어 서비스 토큰을 가져오고 이해하는 방법에</a> 대한 몇 가지 지침을 제공했으므로 이 항목에 대해 오늘 많은 수준의 세부 정보를 제공하지 않습니다. 서비스 버스를 사용하려면 다음과 같이 HTTP 권한 부여 헤더에 WRAP 액세스 토큰을 제시해야 합니다. </p>  <pre class=\"code\"><span class=\"keyword\">Authorization</span>: <span class=\"string\">WRAP access_token=\"<i>&lt;Your Token Here&gt;</i>\"</span></pre>  <p>먼저 <a href=\"https://portal.appfabriclabs.com/\">AppFabric 포털</a>에서 조회할 수 있는 발급자 이름 및 키를 사용하여 ACS에서 토큰을 가져옵니다. </p>  <pre class=\"code\"><span class=\"keyword\">string</span> serviceNamespace = <span class=\"string\">\"contoso\"</span>;  <span class=\"keyword\">string</span> issuerName  = <span class=\"string\">\"owner\"</span>;  <span class=\"keyword\">string</span> issuerPassword = <span class=\"string\">\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=\"</span>;    <span class=\"keyword\">string</span> acsBaseAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\"-sb.accesscontrol.appfabriclabs.com/\"</span>;    <span class=\"comment\">// Note that the scheme is Http</span>  <span class=\"keyword\">string</span> relyingPartyAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\".servicebus.appfabriclabs.com/\"</span>;    <span class=\"comment\">// Create the body of the Post Request, formatted as a HTTP Form</span>  <span class=\"keyword\">string</span> postData = <span class=\"string\">\"wrap_scope=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(relyingPartyAddress) +                    <span class=\"string\">\"&amp;wrap_name=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(issuerName) +                    <span class=\"string\">\"&amp;wrap_password=\"</span> + <span class=\"user-type\">Uri</span>.EscapeDataString(issuerPassword);    <span class=\"keyword\">string</span> authorizationToken;  <span class=\"keyword\">using</span> (<span class=\"user-type\">WebClient</span> acsWebClient = new<span></span> <span class=\"user-type\">WebClient</span>())  {      <span class=\"comment\">// The response contains the access token and its expiry time formatted as an HTTP       // Form like: wrap_access_token=&lt;token&gt;&amp;wrap_expiry_time=2000</span>      <span class=\"keyword\">string</span> response = acsWebClient.UploadString(acsAddress, <span class=\"string\">\"POST\"</span>, postData);        <span class=\"keyword\">string</span>[] tokenVariables = response.Split(<span class=\"string\">'&amp;'</span>);      <span class=\"keyword\">string</span>[] tokenVariable = tokenVariables[0].Split(<span class=\"string\">'='</span>);      authorizationToken = <span class=\"user-type\">Uri</span>.UnescapeDataString(tokenVariable[1]);  }</pre>  <p>액세스 토큰은 만료 시간(현재 기본값: 20분)을 포함하며, 만료될 때까지 동일한 토큰을 반복해서 사용할 수 있습니다. 그러나 만료 시간이 경과하면 Access Control Service에서 새 토큰을 요청해야 합니다. 이제 서비스 버스 호출에 사용할 WebClient를 만듭니다. 권한 부여 헤더를 올바르게 설정하여 초기화합니다. 서비스 버스에 대한 호출에 이 헤더가 있어야 합니다.</p>  <pre class=\"code\"><span class=\"user-type\">WebClient</span> webClient = <span class=\"keyword\">new</span> <span class=\"user-type\">WebClient</span>();  webClient.Headers[<span class=\"string\">\"Authorization\"</span>] = <span class=\"string\">\"WRAP access_token=\\\"\"</span> + authorizationToken + <span class=\"string\">\"\\\"\"</span>;</pre>  <h3>새 큐 만들기</h3>  <p>10월 CTP에서는 지속성 Service Bus 엔터티 만들기, 열거 및 삭제에 대한 명시적 RESTful 인터페이스인 네임스페이스 관리의 개념을 도입했습니다(5월 CTP에서는 큐, 토픽 및 구독). 이 개념은 몇 가지 변경 사항으로 5월 CTP로 전달됩니다. 설정된 RESTful 패턴을 계속 사용합니다(HTTP GET을 사용하여 검색/열거; 만들 HTTP PUT; HTTP DELETE를 제거)하여 Atom 피드 및 항목과 상호 작용합니다. 관리 네임스페이스(이전의 https:// your-namespace-mgmt.servicebus.appfabriclabs.com/&lt;)와 서비스 네임&gt;스페이스(여전히 https://&lt; your-namespace.servicebus.appfabriclabs.com&gt;)를 결합하여 작업을 간소화했습니다.</p>  <p>큐는 서비스 네임스페이스의 어느 곳에나 존재할 수 있습니다. 큐에 대한 설명을 네임스페이스의 '빈' URI에 배치하여 만듭니다. 요청에 대한 올바른 콘텐츠 형식(<b>Content-Type: application/atom+xml</b>)을 지정한 다음, 이를 정의하는 Atom 항목이 포함된 새 큐의 Uri(보안 https 체계 사용)에 <b>HTTP PUT</b> 을 실행해야 합니다.</p>  <pre class=\"code\"><span class=\"comment\">// Note that the scheme is Https</span>  <span class=\"keyword\">string</span> serviceAddress = <span class=\"string\">\"https://\"</span> + serviceNamespace + <span class=\"string\">\".servicebus.appfabriclabs.com/\"</span>;    <span class=\"keyword\">string</span> queueName = <span class=\"string\">\"MyFirstQueue\"</span>;  <span class=\"keyword\">string</span> putData = <span class=\"string\">@\"&lt;entry xmlns=\"\"https://www.w3.org/2005/Atom\"\"&gt;                       &lt;title type=\"\"text\"\"&gt;\"</span> + queueName + <span class=\"string\">@\"&lt;/title&gt;                       &lt;content type=\"\"application/xml\"\"&gt;                         &lt;QueueDescription xmlns:i=\"\"https://www.w3.org/2001/XMLSchema-instance\"\" xmlns=\"\"\"\" /&gt;                       &lt;/content&gt;                     &lt;/entry&gt;\"</span>;    <span class=\"keyword\">string</span> queueAddress = serviceAddress + queueName;    webClient.Headers[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">\"application/atom+xml\"</span>;  <span class=\"keyword\">string</span> response = webClient.UploadString(queueAddress, <span class=\"string\">\"PUT\"</span>, putData);</pre>  <p>요청에 대한 응답에는 <a href=\"https://msdn.microsoft.com/en-us/library/microsoft.servicebus.messaging.queuedescription.aspx\">큐 설명</a>의 모든 설정 가능한 속성을 포함하여 새로 만든 큐(아래)에 대한 Atom 항목이 포함됩니다. 기존 큐에 대한 업데이트는 허용되지 않지만 새 큐를 만들 때 큐 설명에 이러한 속성을 포함할 수 있습니다.</p>  <pre class=\"xml code\">&lt;<span class=\"element\">entry</span> <span class=\"attribute\">xmlns</span>=\"https://www.w3.org/2005/Atom\"&gt;    &lt;<span class=\"element\">id</span>&gt;https://willpe.servicebus.appfabriclabs.com/MyFirstQueue&lt;/<span class=\"element\">id</span>&gt;    &lt;<span class=\"element\">title</span> <span class=\"attribute\">type</span>=\"text\"&gt;<span class=\"element-content\">MyFirstQueue</span>&lt;/<span class=\"element\">title</span>&gt;    &lt;<span class=\"element\">published</span>&gt;<span class=\"element-content\">2011-05-17T20:26:00Z</span>&lt;/<span class=\"element\">published</span>&gt;    &lt;<span class=\"element\">updated</span>&gt;<span class=\"element-content\">2011-05-17T20:26:00Z</span>&lt;/<span class=\"element\">updated</span>&gt;    &lt;<span class=\"element\">author</span>&gt;      &lt;<span class=\"element\">name</span>&gt;<span class=\"element-content\">willpe</span>&lt;/<span class=\"element\">name</span>&gt;    &lt;/<span class=\"element\">author</span>&gt;    &lt;<span class=\"element\">link</span> <span class=\"attribute\">rel</span>=\"self\" <span class=\"attribute\">href</span>=\"https://willpe.servicebus.appfabriclabs.com/MyFirstQueue\"/&gt;    &lt;<span class=\"element\">content</span> <span class=\"attribute\">type</span>=\"application/xml\"&gt;      &lt;<span class=\"element\">QueueDescription</span> <span class=\"attribute\">xmlns</span>=\"\" <span class=\"attribute\">xmlns:i</span>=\"https://www.w3.org/2001/XMLSchema-instance\"&gt;        &lt;<span class=\"element\">LockDuration</span>&gt;<span class=\"element-content\">PT30S</span>&lt;/<span class=\"element\">LockDuration</span>&gt;        &lt;<span class=\"element\">MaxQueueSizeInBytes</span>&gt;<span class=\"element-content\">104857600</span>&lt;/<span class=\"element\">MaxQueueSizeInBytes</span>&gt;        &lt;<span class=\"element\">RequiresDuplicateDetection</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">RequiresDuplicateDetection</span>&gt;        &lt;<span class=\"element\">RequiresSession</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">RequiresSession</span>&gt;        &lt;<span class=\"element\">DefaultMessageTimeToLive</span>&gt;<span class=\"element-content\">P10675199DT2H48M5.4775807S</span>&lt;/<span class=\"element\">DefaultMessageTimeToLive</span>&gt;        &lt;<span class=\"element\">DeadLetteringOnMessageExpiration</span>&gt;<span class=\"element-content\">false</span>&lt;/<span class=\"element\">DeadLetteringOnMessageExpiration</span>&gt;        &lt;<span class=\"element\">DuplicateDetectionHistoryTimeWindow</span>&gt;<span class=\"element-content\">PT10M</span>&lt;/<span class=\"element\">DuplicateDetectionHistoryTimeWindow</span>&gt;      &lt;/<span class=\"element\">QueueDescription</span>&gt;    &lt;/<span class=\"element\">content</span>&gt;  &lt;/<span class=\"element\">entry</span>&gt;</pre>  <h3>큐에 메시지 보내기</h3>  <p>REST 엔드포인트를 사용하여 메시지를 보내는 것은 매우 간단합니다. 단지 HTTP 메시지 본문을 인증 헤더가 있는 큐의 들어오는 메시지 URI에 게시합니다(메시지 본문에 올바른 콘텐츠 형식 지정).</p>  <pre class=\"code\"><span class=\"keyword\">string</span> messageBody = \"Hello World!\";  <span class=\"keyword\">string</span> sendAddress = serviceAddress + queueName + <span class=\"string\">\"/Messages\"</span>;    webClient.Headers[<span class=\"string\">\"Content-Type\"</span>] = <span class=\"string\">\"text/plain\"</span>;  webClient.UploadString(sendAddress, <span class=\"string\">\"POST\"</span>, messageBody);</pre>  <h3>큐에서 메시지 받기</h3>  <p><b>잠금 피킹</b> 또는 <b>수신 및 삭제</b> 의미 체계를 사용하여 메시지를 받을 수 있습니다. 둘 다 REST를 통해 지원되지만 지금은 수신 및 삭제를 사용합니다. 이 모드에서 수신하는 것은 수신 시간 제한이 있는 메시지 큐의 헤드에 HTTP 삭제 요청을 실행하는 것만큼 간단합니다.</p>  <pre class=\"code\"><span class=\"keyword\">string</span> receiveAddress = serviceAddress + queueName + <span class=\"string\">\"/Messages/Head?timeout=30\"</span>;  <span class=\"keyword\">string</span> receivedMessageBody = webClient.UploadString(receiveAddress, <span class=\"string\">\"DELETE\"</span>, <span class=\"keyword\">string</span>.Empty);</pre>  <p>receivedMessageBody에는 이전에 보낸 일반 텍스트(깔끔한!)가 포함되어 있습니다. 응답 헤더를 살펴보고 메시지의 더 많은 속성을 찾을 수도 있습니다.</p>  <pre class=\"code\"><span class=\"keyword\">X-MS-MESSAGE-ID</span>: <span class=\"string\">d78afc3299b54ab2bd0e97b183ab1f77</span>  <span class=\"keyword\">X-MS-DELIVERY-COUNT</span>: <span class=\"string\">0</span>  <span class=\"keyword\">X-MS-SEQUENCE-NUMBER</span>: <span class=\"string\">2</span>  <span class=\"keyword\">X-MS-SIZE</span>: <span class=\"string\">12</span>  <span class=\"keyword\">Content-Type</span>: <span class=\"string\">text/plain</span></pre>  <h3>큐 삭제</h3>  <p>마지막으로 큐를 삭제해야 합니다. 이 작업은 큐의 주소에 대한 간단한 HTTP 삭제를 통해 수행됩니다.</p>  <pre class=\"code\">webClient.UploadString(queueAddress, <span class=\"string\">\"DELETE\"</span>, <span class=\"keyword\">string</span>.Empty);</pre>  <p>AppFabric Service Bus 메시징의 새로운 REST 기능을 사용하는 방법을 간단히 소개합니다. 할 수 있는 일이 많고, 다음 주에 더 많은 기능을 다룰 예정이지만, 팀에 피드백을 보내기에는 너무 이르지 않습니다 - <a href=\"https://social.msdn.microsoft.com/Forums/en-US/appfabricctp/\">AppFabric CTP 포럼</a> 을 방문하여 의견을 알려주세요!</p>  <p>특히 빌드하는 애플리케이션에서 HTTP를 사용하는 방법에 대해 여러분의 의견을 듣고 싶습니다.</p>  <ul>  <li>Service Bus 사용하려는 플랫폼 및 디바이스는 무엇입니까? </li>  <li>애플리케이션을 성공적으로 만들기 위해 HTTP를 통해 지원하는 데 가장 중요한 Service Bus 기능은 무엇인가요? </li>  </ul>  <p><b>HTTP 기능 설문 조사를 통해 Service Bus 미래를 형성하세요!</b></p>"
