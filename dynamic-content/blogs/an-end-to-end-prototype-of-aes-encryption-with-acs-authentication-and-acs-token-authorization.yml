### YamlMime:Yaml
ms.openlocfilehash: fef8ddb325f1602551e7f67c89aa5b964c2c8d5e
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139903122"
Slug: an-end-to-end-prototype-of-aes-encryption-with-acs-authentication-and-acs-token-authorization
Title: ACS 인증 및 ACS 토큰 권한 부여를 사용하는 AES 암호화의 엔드투엔드 프로토타입
Summary: 이것은 저자의 이전 게시물 ACS 인증 및 ACS 토큰 권한 부여와 PlayReady 보호의 엔드 투 엔드 프로토 타입의 "속편"입니다.
Content: "<h1>소개</h1>\n이것은 저자의 이전 게시물 <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">ACS 인증 및 ACS 토큰 권한 부여와 PlayReady 보호의 엔드 투 엔드 프로토 타입의</a> \"속편\"입니다.\n\n경우에 따라 완전한 DRM 보호가 의무화되거나 경제적 의미가 없을 수 있습니다. 대신 AES 암호화가 대안이 될 수 있습니다. 그러나 AES 암호화는 DRM과 매우 다르며 그렇지 않습니다. DRM과 AES 암호화의 차이점은 다음 표에서 요약할 수 있습니다.\n<table border=\"0\" width=\"599\" cellspacing=\"0\" cellpadding=\"1\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"215\"><strong>비교</strong></td>\n<td valign=\"top\" width=\"188\"><strong>PlayReady와 같은 DRM</strong></td>\n<td valign=\"top\" width=\"194\"><strong>AES-128과 같은 암호화</strong></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">콘텐츠 보호 및 파일 보호</td>\n<td valign=\"top\" width=\"188\">콘텐츠</td>\n<td valign=\"top\" width=\"194\">콘텐츠</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">권한 있는 사용자가 신뢰할 수 있나요?</td>\n<td valign=\"top\" width=\"188\">아니요, 권한 있는 사용자가 보호된 콘텐츠로 수행할 수 있는 작업은 DRM 라이선스에 포함된 제한 사항 및 권한으로 제한됩니다.</td>\n<td valign=\"top\" width=\"194\">예, 권한 있는 사용자는 콘텐츠를 사용하여 모든 디스플레이 디바이스로 복사, 저장, 공유 및/또는 내보내기 등의 작업을 수행할 수 있습니다.</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">보호할 콘텐츠의 특성</td>\n<td valign=\"top\" width=\"188\">비디오와 같은 공유 관심사의 콘텐츠에 적용 가능</td>\n<td valign=\"top\" width=\"194\">개인 콘텐츠에 적용할 수 있는 사용자는 공유하지 않을 수 있습니다.</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">클라이언트 디바이스에서 암호를 해독한 후 콘텐츠가 보호되나요?</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">날짜/시간별로 콘텐츠 액세스를 제한할 수 있나요?</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">애플리케이션 허용 목록</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">도메인 바인딩 및 관리</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">암호화 키 회전</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">정전</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">출력 보호</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">라이선스 체인</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">예</td>\n</tr>\n</tbody>\n</table>\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Services Content Protection</a>은 동적 AES 암호화 기능 덕분에 \"1 클릭\" AES 암호화를 현실로 만듭니다.\n\n이 블로그에서는 토큰 권한 부여를 사용하여 부드러운 스트리밍 자산의 AES 암호화에 대한 엔드투엔드 프로토타입을 제공합니다. 권한 부여 토큰은 PlayReady 보호를 위한 엔드투엔드 프로토타입에 사용된 것과 동일한 ACS 2.0 네임스페이스에서 발급됩니다.\n\n&nbsp;\n<h1>엔드 투 엔드 프로토타입</h1>\n<h2>디자인 및 기능</h2>\n이러한 노력의 목표는 다음을 다루는 엔드 투 엔드 프로토타입을 제공하는 것입니다.\n<ul>\n <li>AMS의 자산에 대한 토큰 제한을 사용한 AES-128 동적 암호화;</li>\n <li>암호 해독 키를 배달하기 위한 키 배달 서비스를 Azure Media Services.</li>\n <li>SWT 권한 부여 토큰을 발급하는 <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">STS인 Azure ACS</a>(Microsoft Azure Active Directory Access Control)</li>\n <li>OSMF 플레이어\n<ol>\n <li>는 ACS 서비스 ID에 의해 인증됩니다.</li>\n <li>ACS에서 권한 부여 토큰을 가져옵니다.</li>\n <li>는 ACS 토큰을 사용하여 AMS 키 배달 서비스에서 암호 해독 키를 획득하고</li>\n <li>암호 해독 및 비디오 재생.</li>\n</ol>\n</li>\n</ul>\n이 엔드 투 엔드 프로토타입의 디자인은 다음 다이어그램에 설명되어 있습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/Blog_Secure_Delivery_AES.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"Blog_Secure_Delivery_AES\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_AES_thumb.jpg\" alt=\"Blog_Secure_Delivery_AES\" width=\"631\" height=\"469\" border=\"0\"></a>\n\n&nbsp;\n\n엔드 투 엔드 프로토타입은 Azure 및 Azure Media Services 호스트됩니다. 프로토타입과 관련된 정보는 다음과 같습니다.\n<ul>\n <li>AES 동적 암호화에서 부드러운 스트리밍 자산의 URL;</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\">키 배달 URL</a>;</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net/\">SWT 권한 부여 토큰을 발급하는 Azure ACS 네임스페이스의 URL</a>입니다.</li>\n <li>OSMF 플레이어의 URL입니다.</li>\n</ul>\n&nbsp;\n<h2>어떻게 실행하나요?</h2>\n<ol>\n <li><a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">OSMF용 적응 스트리밍 플러그 인</a>을 사용하여 빌드된 OSMF 플레이어를 찾습니다. 필요한 정보는 플레이어 페이지 UI에 이미 있습니다.</li>\n <li>\"재생\" 단추를 클릭할 때마다 ACS에서 새 권한 부여 토큰이 요청되고 OSMF 플러그 인에서 새 권한 부여 토큰을 사용하여 재생을 위한 암호 해독 키를 요청합니다. ACS 2.0 네임스페이스의 권한 부여 토큰이 플레이어 페이지에 표시됩니다. 플레이어 스크린샷은 다음과 같습니다.</li>\n</ol>\n<blockquote><a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/OMFPlayer.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"OMFPlayer\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/OMFPlayer_thumb.jpg\" alt=\"OMFPlayer\" width=\"631\" height=\"341\" border=\"0\"></a></blockquote>\n&nbsp;\n<h1>구현</h1>\n구현에는 다음이 포함됩니다.\n<ol>\n <li>Azure Media Services .NET API를 사용하여 부드러운 스트리밍 자산에 대한 동적 AES-128 암호화를 구성합니다.\n<ul>\n <li>콘텐츠 키 ID 및 콘텐츠 키를 생성합니다.</li>\n <li>암호 해독 키 배달 서비스 구성;</li>\n <li>자산 배달 정책을 통해 동적 AES 암호화 구성;</li>\n <li>자산을 게시합니다.</li>\n</ul>\n</li>\n <li>플레이어 클라이언트를 인증하고 권한 부여 토큰을 발급하도록 Azure ACS 2.0 네임스페이스를 설정합니다.</li>\n <li>ACS 인증, 권한 부여 토큰 요청, 암호 해독 키 요청 및 비디오 재생을 처리하는 OSMF 플레이어를 개발합니다.</li>\n</ol>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">OSMF용 Microsoft 적응 스트리밍 플러그 인</a>은 주문형 및 라이브 모두에 대한 부드러운 스트리밍 콘텐츠의 AES 암호화를 지원하므로 이 프로토타입에 OSMF 플레이어를 사용하기로 결정했습니다.\n\n&nbsp;\n<h2>동적 AES 암호화 구성</h2>\n첫 번째 단계는 봉투 형식 콘텐츠 키를 만드는 것입니다. 코드는 다음과 같습니다.\n<div align=\"left\">\n<pre class=\"prettyprint\">static public IContentKey CreateEnvelopeTypeContentKey(CloudMediaContext objCloudMediaContext)\n{\n    // Create envelope encryption content key\n    Guid keyId = Guid.NewGuid();\n    byte[] contentKey = CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16);\n\n    IContentKey objIContentKey = objCloudMediaContext.ContentKeys.Create(keyId, contentKey, \"myContentKey\", ContentKeyType.EnvelopeEncryption);\n\n    return objIContentKey;\n}</pre>\n</div>\n다음으로, 권한 부여 정책을 만들고 위에서 만든 콘텐츠 키에 추가합니다. <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2331/8475.Blog_5F00_Secure_5F00_Delivery_5F00_API.jpg\" target=\"_blank\">이 다이어그램</a>에 표시된 것처럼 각 IContentKey에는 단일 IContentKeyAuthorizationPolicy 인스턴스가 있습니다. 다음 코드는 IContentKeyAuthorizationPolicy를 만들고 IContentKey에 연결합니다.\n<pre class=\"prettyprint\">public static IContentKey AddAuthorizationPolicyToContentKey(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    // Create ContentKeyAuthorizationPolicy with restrictions and create authorization policy             \n    IContentKeyAuthorizationPolicy policy = objCloudMediaContext.ContentKeyAuthorizationPolicies.CreateAsync(\"Open Authorization Policy\").Result;\n\n    List&lt;ContentKeyAuthorizationPolicyRestriction&gt; restrictions = new List&lt;ContentKeyAuthorizationPolicyRestriction&gt;();\n\n    ContentKeyAuthorizationPolicyRestriction restriction = new ContentKeyAuthorizationPolicyRestriction\n    {\n        Name = \"Authorization Policy with Token Restriction\",\n        KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\n        Requirements = ContentKeyAuthorizationHelper.CreateRestrictionRequirements()\n    };\n\n    restrictions.Add(restriction);\n\n    IContentKeyAuthorizationPolicyOption policyOption = objCloudMediaContext.ContentKeyAuthorizationPolicyOptions.Create(\"myDynamicEncryptionPolicy\", ContentKeyDeliveryType.BaselineHttp, restrictions, \"\");\n\n    policy.Options.Add(policyOption);\n\n    // Add ContentKeyAutorizationPolicy to ContentKey\n    objIContentKey.AuthorizationPolicyId = policy.Id;\n    IContentKey IContentKeyUpdated = objIContentKey.UpdateAsync().Result;\n\n    return IContentKeyUpdated;\n}</pre>\n&nbsp;\n\n위에서 ContentKeyAuthorizationHelper.CreateRestrictionRequirements() 메서드는 아래와 같이 정의됩니다.\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n&nbsp;\n\n<strong>참고:</strong> ACS 2.0 네임스페이스에 사용되는 <strong>동일한</strong> (기본) 대칭 해시 키가 (동적) AES 암호화 권한 부여 정책을 구성하는 데도 사용되는지 확인하세요.\n\n다음으로 자산 배달에 사용할 IAssetDeliveryPolicy를 만들어야 합니다.\n<pre class=\"prettyprint\">public static IAssetDeliveryPolicy CreateAssetDeliveryPolicy(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    Uri keyAcquisitionUri = objIContentKey.GetKeyDeliveryUrl(ContentKeyDeliveryType.BaselineHttp);\n\n    string envelopeEncryptionIV = Convert.ToBase64String(CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16));\n\n    // The following policy configuration specifies: \n    //   key url that will have KID=&lt;Guid&gt; appended to the envelope and\n    //   the Initialization Vector (IV) to use for the envelope encryption.\n    Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; assetDeliveryPolicyConfiguration = new Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; \n            {\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, keyAcquisitionUri.ToString()},\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64, envelopeEncryptionIV}\n            };\n\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = objCloudMediaContext.AssetDeliveryPolicies.Create(\n                \"SmoothHLSDynamicEncryptionAssetDeliveryPolicy\",\n                AssetDeliveryPolicyType.DynamicEnvelopeEncryption,\n                AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.HLS,\n                assetDeliveryPolicyConfiguration);\n\n    Console.WriteLine();\n    Console.WriteLine(\"Adding Asset Delivery Policy: \" + objIAssetDeliveryPolicy.AssetDeliveryPolicyType);\n    Console.WriteLine(\"Key Delivery URL = {0}\", keyAcquisitionUri.ToString());\n\n    return objIAssetDeliveryPolicy;\n}</pre>\n&nbsp;\n\n마지막으로 위의 모든 항목을 결합하여 자산에 대한 AES 동적 암호화를 추가하는 다음과 같은 전체 흐름을 형성합니다.\n<pre class=\"prettyprint\">public static void DynamicAesEncryptionFlow(CloudMediaContext objCloudMediaContext, IAsset objIAsset)\n{\n    //Create IContentKey\n    IContentKey objIContentKey = CreateEnvelopeTypeContentKey(objCloudMediaContext);\n\n    //add AuthorizationPolicy to IContentKey\n    objIContentKey = AddAuthorizationPolicyToContentKey(objCloudMediaContext, objIContentKey);\n\n    //create asset delivery policy\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = CreateAssetDeliveryPolicy(objCloudMediaContext, objIContentKey);\n\n    //Associate IContentKey with IAsset\n    objIAsset.ContentKeys.Add(objIContentKey);\n\n    // Add AssetDelivery Policy to the asset\n    objIAsset.DeliveryPolicies.Add(objIAssetDeliveryPolicy);\n}</pre>\n이 작업을 실행한 후에는 API를 통해 프로그래밍 방식으로 또는 Azure Portal을 사용하여 자산을 게시해야 합니다.\n\n&nbsp;\n<h2>ACS 설정</h2>\n블로그에 설정한 것과 동일한 ACS 2.0 네임스페이스를 사용할 수 있습니다. <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">ACS 인증 및 ACS 토큰 권한 부여를 사용하는 PlayReady Protection의 엔드투엔드 프로토타입</a>, 동일한 대칭 확인 키, 동일한 서비스 ID, 동일한 발급자 및 범위 등이 있습니다.\n\nACS 서비스 ID를 설정할 때 암호 또는 대칭 키 자격 증명 유형을 선택할 수 있습니다. 두 경우 모두 프로토타입(아래 토큰 요청 코드)에서 지원됩니다.\n\n&nbsp;\n<h2>플레이어 코드</h2>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\" target=\"_blank\">OSMF용 Microsoft 적응 스트리밍 플러그 인</a> 은 AES-128 암호화된 부드러운 스트리밍의 주문형 및 라이브 재생을 모두 지원합니다. 따라서 목적에 맞게 OSMF 플레이어를 사용합니다. OSMF 플레이어의 흐름은 다음과 같습니다.\n<ol>\n <li>테스트 자산의 클라이언트 매니페스트에 표시된 것처럼 AES-128 암호화된 콘텐츠를 나타내고 키 배달 URL을 포함하는 부드러운 스트리밍 매니페스트를 다운로드합니다.</li>\n <li>권한 부여 토큰 요청;</li>\n <li>권한 부여 토큰을 사용하여 암호 해독 키 요청</li>\n <li>암호 해독 및 재생.</li>\n</ol>\n먼저 ACS 네임스페이스에서 권한 부여 토큰을 요청하는 코드는 다음과 같습니다.\n<pre class=\"prettyprint\">public string GetAcsToken()\n{\n    string issuer   = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n    string scope    = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string username = System.Configuration.ConfigurationManager.AppSettings[\"Username\"];\n    string password = System.Configuration.ConfigurationManager.AppSettings[\"Password\"];\n\n    string tokenToReturn = null;\n\n    using (WebClient client = new WebClient())\n    {\n        //  Create the authentication request to get a token\n        client.BaseAddress = (new Uri(issuer)).AbsoluteUri;\n\n        NameValueCollection objNameValueCollection = null;\n        switch (System.Configuration.ConfigurationManager.AppSettings[\"CredentialType\"].ToLower())\n        {\n            case \"password\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"client_credentials\"},\n                    {\"client_id\",     username},\n                    {\"client_secret\", password},\n                    {\"scope\",         scope}\n                };\n                break;\n            case \"symmetrickey\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"\"},\n                    {\"assertion\",     this.CreateToken(username, password)},\n                    {\"scope\",         scope}\n                };\n                break;\n            default:\n                break;\n        }\n\n        byte[] responseBytes = null;\n\n        try\n        {\n            responseBytes = client.UploadValues(new Uri(issuer + \"/v2/OAuth2-13/\"), \"POST\", objNameValueCollection);\n        }\n        catch (WebException we)\n        {\n            Stream stream = we.Response.GetResponseStream();\n            StreamReader reader = new StreamReader(stream);\n\n            throw;\n        }\n\n        using (var responseStream = new MemoryStream(responseBytes))\n        {\n            OAuth2TokenResponse tokenResponse = (OAuth2TokenResponse)new DataContractJsonSerializer(typeof(OAuth2TokenResponse)).ReadObject(responseStream);\n            tokenToReturn = tokenResponse.AccessToken;\n        }\n    }\n\n    return tokenToReturn;\n}\n\npublic string CreateToken(string issuer, string signingKey)\n{\n    System.Text.StringBuilder sb = new System.Text.StringBuilder();\n    // add the issuer name \n    sb.AppendFormat(\"Issuer={0}\", System.Web.HttpUtility.UrlEncode(issuer));\n    string signature = this.GenerateSignature(sb.ToString(), signingKey);\n    sb.AppendFormat(\"&amp;HMACSHA256={0}\", signature);\n    return sb.ToString();\n} \n\nprivate string GenerateSignature(string unsignedToken, string signingKey)\n{\n    System.Security.Cryptography.HMACSHA256 hmac = new System.Security.Cryptography.HMACSHA256(Convert.FromBase64String(signingKey));\n    byte[] locallyGeneratedSignatureInBytes = hmac.ComputeHash(System.Text.Encoding.ASCII.GetBytes(unsignedToken));\n    string locallyGeneratedSignature = System.Web.HttpUtility.UrlEncode(Convert.ToBase64String(locallyGeneratedSignatureInBytes));\n    return locallyGeneratedSignature;\n}</pre>\n&nbsp;\n\nOAuth2TokenResponse 형식은 다음과 같이 정의됩니다.\n<pre class=\"prettyprint\">[DataContract]\npublic class OAuth2TokenResponse\n{\n    [DataMember(Name = \"access_token\")]\n    public string AccessToken { get; set; }\n\n    [DataMember(Name = \"expires_in\")]\n    public int ExpirationInSeconds { get; set; }\n}</pre>\n&nbsp;\n\n플레이어를 호스트하는 ASP.NET 웹 페이지는 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;%@ Page Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"Aes128OSMFPlayer.aspx.cs\" Inherits=\"SilverlightApplication.Web.OSMF.Aes128OSMFPlayer\" %&gt;\n\n&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"https://www.w3.org/1999/xhtml\"&gt;\n&lt;head runat=\"server\"&gt;\n    &lt;title&gt;AES Encryption | OSMF Player&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        .auto-style1 {\n            height: 17px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body style=\"font-family:Verdana;font-size:11px\"&gt;\n    &lt;form id=\"form1\" runat=\"server\"&gt;\n        &lt;div&gt;\n            &lt;h3&gt;End-to-End Prototype of AES Encryption with ACS Authorization Token for Smooth Streaming&lt;/h3&gt;\n            &lt;table&gt;&lt;tr&gt;&lt;td&gt;Source URL: &lt;/td&gt;&lt;td&gt;\n                &lt;asp:TextBox ID=\"txtSrcUrl\" runat=\"server\" Width=\"913px\"&gt;https://willzhanmediaservice.origin.mediaservices.windows.net/474c4840-4753-48ec-b3aa-9d05daef612a/LyncSkypeSizzleVideo750k.ism/manifest&lt;/asp:TextBox&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Key Delivery URL:&lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\"&gt;https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086&lt;/a&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;&lt;td class=\"auto-style1\"&gt;Authorization Token:&lt;/td&gt;&lt;td class=\"auto-style1\"&gt;&lt;%=authorizationToken %&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Token Issuer: &lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\"&gt;https://willzhanacs.accesscontrol.windows.net&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                &lt;asp:Button ID=\"cmdPlay\" runat=\"server\" OnClick=\"cmdPlay_Click\" Text=\"Play\" /&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                    &lt;object width=\"920\" height=\"640\"&gt;\n                        &lt;param name=\"movie\" value=\"StrobeMediaPlayback.2.0.swf\"&gt;&lt;/param&gt;\n                        &lt;param name=\"flashvars\" value=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowFullScreen\" value=\"true\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowscriptaccess\" value=\"always\"&gt;&lt;/param&gt;\n                        &lt;param name=\"wmode\" value=\"direct\"&gt;&lt;/param&gt;\n                        &lt;embed src=\"StrobeMediaPlayback.2.0.swf\"\n                            type=\"application/x-shockwave-flash\"\n                            allowscriptaccess=\"always\"\n                            allowfullscreen=\"true\"\n                            wmode=\"direct\"\n                            width=\"920\"\n                            height=\"640\"\n                            flashvars=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;\n                        &lt;/embed&gt;\n                    &lt;/object&gt;\n                &lt;/td&gt;&lt;/tr&gt;\n                &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\n그리고 해당 코드 숨김은 다음과 같습니다.\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.UI;\nusing System.Web.UI.WebControls;\n\nnamespace SilverlightApplication.Web.OSMF\n{\n    public partial class Aes128OSMFPlayer : System.Web.UI.Page\n    {\n        protected string authorizationToken;\n        protected string autoPlay;\n        protected string srcUrl;\n        protected void Page_Load(object sender, EventArgs e)\n        {\n            if (!Page.IsPostBack)\n            {\n                this.Play();\n            }\n        }\n\n        protected void cmdPlay_Click(object sender, EventArgs e)\n        {\n            this.Play();\n        }\n\n        protected void Play()\n        {\n            //Request authorization token from ACS 2.0 namespace\n            WCFService objWCFService = new WCFService();\n            string token = objWCFService.GetAcsToken();\n            token = string.Format(\"Bearer={0}\", token);\n\n            //URL-encode the token before using it\n            authorizationToken = System.Web.HttpUtility.UrlEncode(token);\n\n            srcUrl = txtSrcUrl.Text;\n            autoPlay = true.ToString();\n        }\n    }\n}</pre>\n&nbsp;\n<h1>마무리</h1>\n모든 주요 구성 요소를 포함하는 Azure Media Services AES 암호화 솔루션의 엔드 투 엔드 프로토타입을 발표했습니다.\n<ol>\n <li>콘텐츠 키 ID 및 콘텐츠 키 생성</li>\n <li>Azure Media Services; 스트리밍 원본</li>\n <li>Azure Media Services Content Protection을 통한 AES 암호화;</li>\n <li>Azure Media Services Content Protection을 통한 AES 키 배달;</li>\n <li>Azure ACS 2.0을 통한 STS(보안 토큰 서비스)는 플레이어 클라이언트를 인증하고 권한 부여 토큰을 발급합니다.</li>\n <li>ACS 인증, ACS 권한 부여, 암호 해독 키 획득 및 비디오 재생을 처리하는 Azure IaaS VM에서 호스트되는 비디오 플레이어 애플리케이션입니다.</li>\n</ol>\n&nbsp;\n\n<strong>업데이트:</strong>\n\n2015년 1월 6일: OSMF 플러그 인 플레이어는 보다 일반적인 시나리오에서 AES 암호화 테스트를 위해 향상되었습니다. 이제 이 블로그에 설명된 엔드투엔드 구현에 사용되는 ACS 네임스페이스 대신 모든 Azure ACS 네임스페이스에서 작동합니다. 테스트할 ACS 네임스페이스 매개 변수/비밀을 사용자로 바꿀 수 있습니다.\n\n2015년 1월 23일: AMS Content Protection에서 JWT 지원이 릴리스됨에 따라 이 프로토타입은 STS 및 IdP로 Azure Active Directory(AAD)를 사용하여 JWT에 토큰 제한을 포함하도록 확장되었습니다. AMS 일괄 처리 작업(동적 PlayReady 보호 또는 AES 암호화 설정): AAD 테넌트만 알고 있지만 플레이어 앱에 대해서는 아무것도 알 수 없습니다(플레이어가 괜찮습니다). AAD 테넌트: 플레이어 앱을 알고 있지만 AMS 일괄 처리 작업에 대해서는 아무것도 알지 않습니다. 플레이어 앱: AAD 테넌트만 알고 있지만 AMS 또는 AMS 일괄 처리 작업에 대해서는 아무것도 알지 않습니다. 순서대로 AAD 테넌트와 플레이어 앱은 서로를 알고 있습니다. AMS 일괄 처리 작업은 테넌트에 AAD 알고 있지만 플레이어가 콘텐츠를 사용하는 것은 상관하지 않습니다.\n\n&nbsp;\n\n<b>승인: </b> 이러한 노력에 큰 도움을 준 Microsoft Azure Media Services 팀의 퀸틴 번스, 조지 트리포노프, 밍페이 얀에게 특별한 감사의 말씀을 전합니다."
