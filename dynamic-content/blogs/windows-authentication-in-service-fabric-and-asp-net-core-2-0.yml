### YamlMime:Yaml
ms.openlocfilehash: 8dbe37dd714ab571463f580f09de64d277b8f290
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901950"
Slug: windows-authentication-in-service-fabric-and-asp-net-core-2-0
Title: Service Fabric 및 ASP.NET Core 2.0의 Windows 인증
Summary: 최근에 저는 고객을 위한 Service Fabric 솔루션을 개발했는데, 여기서 우리 팀은 ASP.NET Core 2.0 프레임워크를 기반으로 구축된 기존의 신뢰할 수 있는(상태 비국적) 서비스에 대한 보안 통신 기능을 구성해야 했습니다. 이 문서에서는 주요 측면을 강조하고 이러한 필수 구성 요소를 고려하여 SF(Service Fabric) Reliable Service 상태 비저장 서비스를 올바르게 구성하는 방법을 설명합니다.
Content: "<p>최근에 저는 고객을 위한 Service Fabric 솔루션을 개발했는데, 여기서 우리 팀은 ASP.NET Core 2.0 프레임워크를 기반으로 구축된 기존의 신뢰할 수 있는(상태 비국적) 서비스에 대한 보안 통신 기능을 구성해야 했습니다. 좀 더 구체적으로 말하자면, <strong>Windows 인증</strong> 기능을 구성하고 <strong>WebListener</strong>를 웹 서버로 선택하여 원격 Windows 클라이언트에서 HTTP 요청을 처리해야 했습니다.</p> <p>일부 ASP.NET 패키지 및 라이브러리의 이름과 이전 버전(1.x)과 관련하여 최신 버전의 ASP.NET 사용하여 상태 비저장 서비스에서 weblistener를 구성하는 방식에 약간의 차이가 있음을 알 수 있습니다. 이 문서에서는 이러한 측면을 강조하고 이러한 요구 사항을 고려하여 SF(Service Fabric) Reliable Service 상태 비저장 서비스를 올바르게 구성하는 방법을 설명합니다.</p> <p>Windows Service Fabric SDK(v5.7.198)의 최신 릴리스에서 제공하는 기능, 개선 사항 및 지원을 활용할 것입니다.</p> <p>그 중에서도 다음 기능에 집중하고 싶습니다.</p> <ul> <li><strong>ASP.NET Core 2.0 지원:</strong> <code>Microsoft.ServiceFabric.AspNetCore.</code>* 이제 NuGet 패키지는 최신 클라우드 지원 웹 애플리케이션을 빌드하기 위한 오픈 소스 및 플랫폼 간 프레임워크의 최신 주 버전인 ASP.NET Core 2.0을 지원합니다. </li></ul> <p>완전히 문서화된 릴리스 정보 페이지는 <a href=\"https://blogs.msdn.microsoft.com/azureservicefabric/2017/08/09/release-of-sdk-2-7-198-and-runtime-5-7-198-for-windows\">Azure Service Fabric 팀 블로그</a>를 방문하세요.</p> <p>다음 섹션에서는 Visual Studio 제공하는 <strong>상태 비주택</strong> ASP.NET Core 프로젝트 템플릿을 사용하여 상태 비주택 서비스로 패키지된 간단한 ASP.NET Core 2.0 애플리케이션을 빌드합니다. 그런 다음, Windows 인증된 호출을 수행하도록 애플리케이션에 대한 보안을 구성합니다.</p> <p>몇 가지 가정:</p> <ul> <li>샘플이 로컬 SF 클러스터에 빌드 및 배포되므로 SF SDK 및 런타임의 최신 버전이 웹 플랫폼 설치 관리자를 통해 로컬 컴퓨터에 설치되고 클러스터가 1노드/5노드 구성으로 시작되었는지 확인합니다.  <li>최신<a href=\"https://www.microsoft.com/net/core\" target=\"_blank\"> .NET Core SDK </a>가 설치됨(v2.0.0)  <li>ASP.NET Core 2.0을 지원하는 Visual Studio 2017이 설치됨(v15.3) </li></li></li></ul> <h2>Service Fabric 애플리케이션</h2> <p>1.관리자 권한으로 Visual Studio 엽니다.<br>2.Service Fabric 애플리케이션을 만들고 이름을 <strong>MyApplication</strong>으로 지정합니다.</p> <p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/ba05be9b-4b35-474e-9286-e0d65e4fa76f.jpg\"><img title=\"service-fabric-application\" style=\"background-image: none; float: none; margin-left: auto; display: block; margin-right: auto; border-image: none\" border=\"0\" alt=\"service-fabric-application\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f9993162-fe74-4c40-bbcd-323c203487e5.jpg\" width=\"1024\" height=\"709\"></a><br>3.상태 비국적 ASP.NET Core 서비스를 만들고 이름을 <strong>MyAspNetService</strong>로 지정합니다.</p> <p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/de8d1f8d-f48d-4e42-9a57-f66675141c72.jpg\"><img title=\"my-asp-net-service\" style=\"background-image: none; float: none; margin-left: auto; display: block; margin-right: auto; border-image: none\" border=\"0\" alt=\"my-asp-net-service\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/eb27a399-6ed5-404c-957b-f98a94740c22.jpg\" width=\"1020\" height=\"768\"></a><br>4.다음 대화 상자에서 <strong>ASP.NET Core 2.0</strong>을 선택해야 합니다. 이 예제에서는 <strong>빈</strong> 프로젝트 템플릿과 <strong>인증 없음</strong> 을 인증 방법으로 사용했습니다(프로그래밍 방식으로 설정하겠습니다).</p> <p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/27800507-89d7-41ba-be1a-d3029ef7c348.png\"><img title=\"빈\" style=\"background-image: none; float: none; margin-left: auto; display: block; margin-right: auto; border-image: none\" border=\"0\" alt=\"empty\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/1b3703f5-fcf2-421b-8b49-9c15901cfc40.png\" width=\"1024\" height=\"668\"></a></p> <p>Visual Studio 애플리케이션 및 서비스 프로젝트를 설정할 때까지 기다린 다음, 목적에 사용되는 SF 상태 비저장 서비스를 나타내는 클래스가 포함된 MyAspNetService.cs 파일로 이동합니다.</p> <p>개발자가 이 서비스 인스턴스에 대한 다양한 수신기를 만들기 위해 재정의할 수 있는 메서드의 <code>CreateServiceInstanceListeners(…)</code> 서명 및 본문은 다음과 같습니다.</p><pre class=\"prettyprint\">protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()\n{\nreturn new ServiceInstanceListener[]\n{\nnew ServiceInstanceListener(serviceContext =&gt;\nnew KestrelCommunicationListener(serviceContext, \"ServiceEndpoint\", (url, listener) =&gt;\n{\nServiceEventSource.Current.ServiceMessage(serviceContext, $\"Starting Kestrel on {url}\");\n\n새 WebHostBuilder()를 반환합니다. UseKestrel() . ConfigureServices( services =&gt; services    \n                                            . AddSingletonStatelessServiceContext&lt;&gt;(serviceContext)) . UseContentRoot(Directory.GetCurrentDirectory()) . UseStartupStartup&lt;&gt;() . UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None) . UseUrls(url) . Build(); } ) ) }; }\n</pre>\n\n\n<p>볼 수 있듯이 <strong>Kestrel</strong> 을 기반으로 하는 통신 수신기는 구성된 유일한 서비스 엔드포인트 <code>(ServiceEndpoint)</code>에 대한 기본 수신기로 이미 설정되었습니다. ASP.NET Core 아래에 간략하게 설명된 두 개의 서버 구현이 함께 제공됩니다. <strong>WebListener</strong>는 Windows 인증을 지원하므로 웹 서버로 선택했습니다.</p>\n<h3>Kestrel</h3>\n<p>Kestrel은 플랫폼 간 아키텍처에서 비동기 I/O 작업을 위해 <strong>libuv</strong> 라이브러리를 기반으로 하는 플랫폼 간 HTTP 서버입니다. 앞에서 설명한 것처럼 Kestrel은 ASP.NET Core 새 프로젝트 템플릿에 기본적으로 포함된 웹 서버입니다.</p>\n<p>다음 기능을 지원합니다.</p>\n<ul>\n<li>HTTPS\n<li>Websocket을 활성화하는 데 사용되는 불투명 업그레이드\n<li>Nginx 뒤의 고성능을 위한 Unix 소켓 </li></li></li></ul>\n<h3>WebListener</h3>\n<p>WebListener는 커널 모드 드라이버를 기반으로 <code>Http.</code><code>Sys</code> 하는 Windows 전용 HTTP 서버입니다.</p>\n<p>WebListener는 다음과 같은 기능을 지원합니다.</p>\n<ul>\n<li>Windows 인증\n<li>포트 공유\n<li>SNI를 사용하는 HTTPS\n<li>TLS를 통한 HTTP/2(Windows 10)\n<li>직접 파일 전송\n<li>응답 캐싱\n<li>WebSockets(Windows 8)\n<li>지원되는 Windows 버전:\n<ul>\n<li>Windows 7 및 Windows Server 2008 R2 이상 </li></ul></li></li></li></li></li></li></li></li></ul>\n<p><a href=\"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener\" target=\"_blank\">ASP.NET Core WebListener 웹 서버 구현에</a> 대해 자세히 알아봅니다.</p>\n<p>다음과 같이 메서드 <code>CreateServiceInstanceListeners(…)</code> 를 수정합니다.</p><pre class=\"prettyprint\">protected override IEnumerable&lt;ServiceInstanceListener&gt; CreateServiceInstanceListeners()\n{\nreturn new ServiceInstanceListener[]\n{\nnew ServiceInstanceListener(serviceContext =&gt;\nnew WebListenerCommunicationListener(serviceContext, \"ServiceEndpoint\", (url, listener) =&gt;\n{\nServiceEventSource.Current.ServiceMessage(serviceContext, $\"Starting WebListener on {url}\");\nreturn new WebHostBuilder()\n.UseHttpSys(\noptions =&gt;\n{\noptions.Authentication.Schemes = AuthenticationSchemes.Negotiate; // Microsoft.AspNetCore.Server.HttpSys\n                                                  options.Authentication.AllowAnonymous = false;\n                                                  /* Additional options */\n                                                  //options.MaxConnections = 100;\n                                                  //options.MaxRequestBodySize = 30000000;\n                                                  //options.UrlPrefixes.Add(\"https://localhost:5000\");\n                                              }\n                                      )\n                                      .ConfigureServices(\n                                           services =&gt; services\n                                               .AddSingleton&lt;StatelessServiceContext&gt;(serviceContext))\n                                      .UseContentRoot(Directory.GetCurrentDirectory())\n                                      .UseStartup&lt;Startup&gt;()\n.UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)\n                                      .UseUrls(url)\n                                      .Build();\n}\n)\n)\n};\n}\n</pre>\n\n<p>성공적인 빌드를 수행하려면 다음 NuGet 패키지가 필요합니다.</p>\n<ul>\n<li><code>Microsoft.ServiceFabric.AspNetCore.WebListener (v2.7.198)</code> \n<li><code>Microsoft.AspNetCore.Server.</code><code>HttpSys</code><code> (v2.0.0)</code> </li></li></ul>\n<p>사용 지역은 다음과 같습니다.</p><pre class=\"prettyprint\">using Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Server.HttpSys;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.ServiceFabric.Services.Communication.AspNetCore;\nusing Microsoft.ServiceFabric.Services.Communication.Runtime;\nusing Microsoft.ServiceFabric.Services.Runtime;\nusing System.Collections.Generic;\nusing System.Fabric;\nusing System.IO;</pre>\n<h2>고려 사항</h2>\n<ul>\n<li>앞서 언급한 새 패키지 <code>Microsoft.AspNetCore.Server.WebListener</code> <code>Microsoft.AspNetCore.Server.</code><code>Microsoft.Net.Http.Server</code><code>HttpSys</code>에 패키지가 <strong>병합</strong>되었습니다. 네임스페이스가 일치하도록 업데이트되었습니다. 이는 대신 호출 <code>UseHttpSys()</code> 확장 메서드에 <code>UseWebListener()</code>반영됩니다. </li></ul>\n<ul>\n<li>Windows 인증은 다음을 설정하여 <strong>HttpSys 옵션</strong>에 의해 수행됩니다. </li></ul>\n<p><code>options.Authentication.Schemes </code>열거형에 <code> AuthenticationSchemes.Negotiate</code></p>\n<p><code>options.Authentication.AllowAnonymous </code>을(를) 없음으로 지정합니다.</p>\n<p>ASP.NET Core HTTP.sys 웹 서버 구현에 대해 자세히 알아봅니다.</p>\n<ul>\n<li>다음과 관련하여 코드에 추가 옵션(주석 처리됨)을 제공했습니다.\n<ul>\n<li>최대 클라이언트 연결\n<li>최대 요청 본문 크기\n<li>URL 및 포트 구성 옵션 </li></li></li></ul></li></ul>\n<h2>게시 및 테스트</h2>\n<p>애플리케이션을 게시하고 서비스 인스턴스가 로컬 클러스터 환경에서 실행되고 나면 서비스 프로젝트의 ServiceManifest.xml 구성된 엔드포인트에 대한 HTTP 요청을 시뮬레이션할 수 있습니다(예 https://localhost:8234):</p>\n<p>클러스터:</p>\n<p><a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/411f4d44-d952-404e-a119-1971237cc159.jpg\"><img title=\"클러스터\" style=\"background-image: none; float: none; margin-left: auto; display: block; margin-right: auto; border-image: none\" border=\"0\" alt=\"cluster\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f38f33e2-3bd9-4797-807a-81c8b7d2bdf0.jpg\" width=\"1024\" height=\"432\"></a></p><pre class=\"prettyprint\">Snippet from ServiceManifest.xml:\n\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;ServiceManifest Name=\"MyAspNetServicePkg\"\n                 Version=\"1.0.0\"\n                 xmlns=\"\"\n                 xmlns:xsd=\"https://www.w3.org/2001/XMLSchema\"\n                 xmlns:xsi=\"https://www.w3.org/2001/XMLSchema-instance\"&gt;\n  &lt;ServiceTypes&gt;\n    &lt;!-- This is the name of your ServiceType. \n         This name must match the string used in RegisterServiceType call in Program.cs. --&gt;\n    &lt;StatelessServiceType ServiceTypeName=\"MyAspNetServiceType\" /&gt;\n  &lt;/ServiceTypes&gt;\n\n  &lt;!-- Code package is your service executable. --&gt;\n  &lt;CodePackage Name=\"Code\" Version=\"1.0.0\"&gt;\n    &lt;EntryPoint&gt;\n      &lt;ExeHost&gt;\n        &lt;Program&gt;MyAspNetService.exe&lt;/Program&gt;\n        &lt;WorkingFolder&gt;CodePackage&lt;/WorkingFolder&gt;\n      &lt;/ExeHost&gt;\n    &lt;/EntryPoint&gt;\n  &lt;/CodePackage&gt;\n\n  &lt;!-- Config package is the contents of the Config directoy under PackageRoot that contains an \n       independently-updateable and versioned set of custom configuration settings for your service. --&gt;\n  &lt;ConfigPackage Name=\"Config\" Version=\"1.0.0\" /&gt;\n\n  &lt;Resources&gt;\n    &lt;Endpoints&gt;\n      &lt;!-- This endpoint is used by the communication listener to obtain the port on which to \n           listen. Please note that if your service is partitioned, this port is shared with \n           replicas of different partitions that are placed in your code. --&gt;\n      &lt;Endpoint Protocol=\"http\" Name=\"ServiceEndpoint\" Type=\"Input\" Port=\"8234\" /&gt;\n    &lt;/Endpoints&gt;\n  &lt;/Resources&gt;\n&lt;/ServiceManifest&gt;</pre>\n\n<p>내 <a href=\"https://github.com/alessandro-avila/azure-service-fabric-aspnetcore20-getting-started\" target=\"_blank\">GitHub 리포지토리</a>에서 완전히 작동하는 예제에 도달할 수 있습니다. -AA</p>"
