### YamlMime:Yaml
ms.openlocfilehash: 769bf37143745122f1ed03f44d7f562f38ec4aa7
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139900468"
Slug: sql-azure-horizontal-partitioning-part-2
Title: 'SQL Azure 가로 분할: 2부'
Summary: '[이 문서는 SQL Azure 팀에서 제공했습니다.] SQL Azure 현재 1GB 및 10GB 데이터베이스를 지원하며, 2010년 6월 28일에는 50GB 지원이 지원됩니다. 더 많은 양을 저장하려는 경우...'
Content: <p>[이 문서는 SQL Azure 팀에서 제공했습니다.]</p><p>SQL Azure 현재 1GB 및 10GB 데이터베이스를 지원하며, 2010년 6월 28<sup>일에</sup>는 50GB 지원이 지원됩니다. 더 많은 양의 데이터를 SQL Azure 저장하려는 경우 테이블을 여러 SQL Azure 데이터베이스로 나눌 수 있습니다. 이 문서에서는 데이터 액세스 계층을 사용하여 LINQ를 사용하여 서로 다른 SQL Azure 데이터베이스에 있는 두 테이블을 조인하는 방법을 설명합니다. 이 기술은 데이터를 SQL Azure 수평 분할합니다. </p>  <p>수평 분할 버전에서는 파티션 집합의 모든 데이터베이스에 모든 테이블이 있습니다. 이 예제 &ndash; 에서는 행의 기본 키에 해시 기본 분할 스키마를 사용합니다. 중간 계층은 작성 중인 데이터의 기본 키를 기반으로 각 행을 쓸 데이터베이스를 결정합니다. 이렇게 하면 개별 테이블 증가에 관계없이 모든 데이터베이스에서 데이터를 균등하게 나눌 수 있습니다. 데이터 액세스는 기본 키를 기반으로 데이터를 찾는 방법을 알고 결과를 결합하여 하나의 결과 집합을 호출자에게 반환합니다.</p>  <p>이는 해시 기반 분할로 간주됩니다. 범위 기반의 또 다른 가로 분할 스타일이 있습니다. 정수를 기본 키로 사용하는 경우 기본 키가 증가함에 따라 중간 계층을 구현하여 데이터베이스를 연속 순서대로 채울 수 있습니다. 다양한 유형의 분할에 대한 자세한 내용은 여기에서 확인할 수 <a href="https://social.technet.microsoft.com/wiki/contents/articles/scaling-out-with-sql-azure.aspx">있습니다</a>.</p>  <h2>성능 향상</h2>  <p>데이터베이스 분할을 통해 얻을 수 있는 성능 향상도 있습니다. SQL Azure 여러 물리적 컴퓨터에 데이터베이스를 분산하므로 워크로드를 분할하여 더 많은 CPU 및 RAM 리소스를 얻을 수 있습니다. 예를 들어 데이터베이스를 10-1GB SQL Azure 데이터베이스에 분할하면 CPU 및 메모리 리소스의 10배가 됩니다. TicketDirect의 사례 연구(<a href="https://www.microsoft.com/casestudies/Case_Study_Detail.aspx?CaseStudyID=4000005890">여기에서 찾을</a> 수 있음)는 최대 부하 동안 수백 개의 SQL Azure 데이터베이스에서 워크로드를 분할합니다. </p>  <h2>고려 사항</h2>  <p>데이터베이스를 수평 분할할 때 단일 데이터베이스에 모든 데이터를 포함하는 일부 기능이 손실됩니다. 이 기술을 사용할 때는 다음과 같은 몇 가지 고려 사항이 있습니다.</p>  <ul>  <li>데이터베이스 전체의 외세 키는 지원되지 않습니다. 즉, 한 데이터베이스의 조회 테이블의 기본 키는 다른 데이터베이스의 테이블에 있는 외래 키에서 참조할 수 없습니다. 이는 외래 키에 대한 데이터베이스 간 지원을 SQL Server&rsquo; 유사한 제한 사항입니다.</li>  <li>클라이언트 쪽에서 Microsoft Distributed Transaction Manager를 사용하는 경우에도 두 데이터베이스에 걸쳐 있는 트랜잭션을 가질 수 없습니다. 즉, 다른 데이터베이스에 대한 삽입이 실패하는 경우 한 데이터베이스에 삽입을 롤백할 수 없습니다. 이 제한은 예외를 catch하고 성공적으로 완료된 문에 대해 실행 취소&rdquo; 스크립트를 실행하는 &ldquo;데 필요한 클라이언트 쪽 코딩 &ndash; 을 통해 완화될 수 있습니다.</li>  <li>모든 기본 키는 uniqueidentifier여야 합니다. 이를 통해 중간 계층에서 기본 키의 고유성을 보장할 수 있습니다.</li>  <li>아래 표시된 예제 코드에서는 파티션 집합에 있는 데이터베이스 수를 동적으로 변경할 수 없습니다&rsquo;. 데이터베이스 수는 <b>ConnectionStringNames</b> 속성의 <b>SqlAzureHelper</b> 클래스에서 하드 코딩됩니다.</li>  <li>SQL Server 데이터를 수평 분할된 데이터베이스로 가져오려면 아래 코드와 같이 기본 키의 해시를 에뮬레이트하여 각 행을 한 번에 하나씩 이동해야 합니다.</li>  </ul>  <h2>코드</h2>  <p>이 코드는 SQL Azure 여러 동시 요청을 수행하고 결과를 결합하여 해당 리소스를 활용하는 방법을 보여 줍니다. 이 게시물을 읽기 전에 Uniqueidentifier 및 클러스터형 인덱스 및 연결 및 SQL Azure 사용에 대한 이전 문서를 숙지해야 합니다. 수평 분할을 수행하기 위해 수직 분할 블로그 게시물에서 사용한 것과 동일한 <b>SQLAzureHelper </b>클래스를 사용합니다.</p>  <p>코드에는 다음과 같은 목표가 있습니다.</p>  <ul>  <li>앞으로 커서만 사용하여 성능을 최대화합니다.</li>  <li>Linq를 사용하여 여러 응답을 전체 응답에 결합합니다.</li>  <li>기본 키 요청에 대해 하나의 데이터베이스에만 액세스합니다.</li>  <li>모든 데이터베이스에서 행 데이터를 균등하게 나눕니다.</li>  </ul>  <h2>계정 테이블</h2>  <p>사용 중인 예제 테이블은 Accounts로 명명되었으며 Date 열에 클러스터형 인덱스가 빌드된 uniqueidentifier의 기본 키가 있습니다. 다음 두 데이터베이스에서 이 스크립트를 사용하여 만들었습니다.</p>  <pre class="csharpcode"><span class="kwrd">CREATE</span> <span class="kwrd">TABLE</span> [dbo].[Accounts](      [Id] [uniqueidentifier] <span class="kwrd">NOT</span> <span class="kwrd">NULL</span>,      [Name] [nvarchar](<span class="kwrd">max</span>) <span class="kwrd">NULL</span>,      [<span class="kwrd">Date</span>] [datetime] <span class="kwrd">NULL</span>,   <span class="kwrd">CONSTRAINT</span> [PK_Accounts] <span class="kwrd">PRIMARY</span> <span class="kwrd">KEY</span> <span class="kwrd">NONCLUSTERED</span>   (      [Id] <span class="kwrd">ASC</span>  )  )      <span class="kwrd">ALTER</span> <span class="kwrd">TABLE</span> [dbo].[Accounts] <span class="kwrd">ADD</span>  <span class="kwrd">CONSTRAINT</span> [DF__Accounts__Date__7C8480AE]  <span class="kwrd">DEFAULT</span> (getdate()) <span class="kwrd">FOR</span> [<span class="kwrd">Date</span>]      <span class="kwrd">CREATE</span> <span class="kwrd">CLUSTERED</span> <span class="kwrd">INDEX</span> [idxDate] <span class="kwrd">ON</span> [dbo].[Accounts]   (      [<span class="kwrd">Date</span>] <span class="kwrd">ASC</span>  )</pre>  <p>    </p>  <h2>기본 키로 분할</h2>  <p>분할하는 테이블은 uniqueidentifier를 기본 키로 사용하고 <b>Guid.NewGuid()</b> 에 의해 생성되기 때문에 상당히 임의 기본 키가 있습니다. 기본 키는 해당 키에 대한 행이 포함된 데이터베이스를 파악하기 위해 해시됩니다. 코드는 다음과 같습니다.</p>  <pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Names of the Databases In Horizontal Partition</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> String[] ConnectionStringNames =   { <span class="str">"Database001"</span>, <span class="str">"Database002"</span> };    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Connections Strings In the Horizontal Partition</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> IEnumerable&lt;String&gt; ConnectionStrings()  {      <span class="kwrd">foreach</span> (String connectionStringName <span class="kwrd">in</span> ConnectionStringNames)          <span class="kwrd">yield</span> <span class="kwrd">return</span> ConfigurationManager.  ConnectionStrings[connectionStringName].ConnectionString;  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Return the Index to the Database For the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">private</span> <span class="kwrd">static</span> <span class="kwrd">int</span> DatabaseIndex(Guid primaryKey)  {      <span class="kwrd">return</span> (BitConverter.ToInt32(primaryKey.ToByteArray(), 0));  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Returns the Connectiong String Name for the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">private</span> <span class="kwrd">static</span> String ConnectionStringName(Guid primaryKey)  {      <span class="kwrd">return</span> (ConnectionStringNames[DatabaseIndex(primaryKey) %   ConnectionStringNames.Length]);  }    <span class="rem">/// &lt;summary&gt;</span>  <span class="rem">/// Returns the Connection String For the Primary Key</span>  <span class="rem">/// &lt;/summary&gt;</span>  <span class="rem">/// &lt;param name="primaryKey"&gt;&lt;/param&gt;</span>  <span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span>  <span class="kwrd">public</span> <span class="kwrd">static</span> String ConnectionString(Guid primaryKey)  {      <span class="kwrd">return</span> (ConfigurationManager.ConnectionStrings[ConnectionStringName(primaryKey)]  .ConnectionString);  } </pre>  <p>    </p>  <p><b>ConnectionString()</b> 메서드는 기본 키를 참조할 때 사용할 연결 문자열을 반환합니다. 애플리케이션 또는 웹 사이트에 대한 .config 파일에서 연결 문자열을 구성합니다. .config 파일에서 참조하는 데이터베이스 배열은 <b>ConnectionStrings</b> 속성에 포함됩니다.</p>  <h2>단일 행 가져오기</h2>  <p>블로그 게시물에 정의된 <b>SQLAzureHelper </b>클래스를 기반으로 빌드하고 있습니다. 클래스의 이면에는 SQL Azure 연결할 다목적 액세스 계층이 있어야 합니다. <b>SQLAzureHelper </b>클래스 내에서 기본 키를 사용하여 예제 데이터베이스에서 계정 이름을 찾는 코드는 다음과 같습니다.</p>  <pre class="csharpcode"><span class="kwrd">static</span> String AccountName(Guid id)  {      var accountDataReader = SQLAzureHelper.ExecuteReader(          SQLAzureHelper.ConnectionString(id),          sqlConnection =&gt;          {              String sql = <span class="str">@"SELECT [Name] FROM [Accounts] WHERE Id = @Id"</span>;              SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection);              sqlCommand.Parameters.AddWithValue(<span class="str">"@Id"</span>, id);              <span class="kwrd">return</span> (sqlCommand.ExecuteReader());          });        <span class="kwrd">return</span> ((from row <span class="kwrd">in</span> accountDataReader select (<span class="kwrd">string</span>)row[<span class="str">"Name"</span>]).          FirstOrDefault());  }</pre>  <p>    </p>  <p>기본 키를 사용하여 연결 문자열과 <b>SqlCommand</b>에 대한 매개 변수를 계산합니다.</p>  <h2>단일 행 삽입 </h2>  <p>단일 행을 삽입할 때 데이터베이스에 연결하기 전에 기본 키를 알아야 합니다. 이 작업을 수행하기 위해 SQL Azure NewID() 대신 C# 코드에서 <b>Guid.NewGuid</b><b>()</b>를 호출합니다. <b>ExecutionContext</b> 클래스를 사용하는 코드는 다음과 같습니다.</p>  <pre class="csharpcode"><span class="kwrd">static</span> Guid InsertAccount(String name)  {      Guid id = Guid.NewGuid();        SQLAzureHelper.ExecuteNonQuery(           SQLAzureHelper.ConnectionString(id),           sqlConnection =&gt;           {               String sql = <span class="str">@"INSERT INTO [Accounts] ([Id], [Name]) VALUES (@Id, @Name)"</span>;               SqlCommand sqlCommand = <span class="kwrd">new</span> SqlCommand(sql, sqlConnection);               sqlCommand.Parameters.AddWithValue(<span class="str">"@Name"</span>, name);               sqlCommand.Parameters.AddWithValue(<span class="str">"@Id"</span>, id);               sqlCommand.ExecuteNonQuery();           });        <span class="kwrd">return</span> (id);  }</pre>  <p>    </p>  <h2>요약</h2>  <p>3부에서는 여러 응답에서 병합된 결과 집합을 가져오는 방법과 여러 SQL Azure 데이터베이스를 동시에 호출하는 흥미로운 다중 스레드 측면을 포함하여 여러 행을 분할된 테이블에 삽입하는 방법을 보여 줍니다. 질문, 우려 사항, 의견이 있나요? 아래에 게시하고 우리는 그들을 해결하기 위해 노력할 것입니다.</p>
