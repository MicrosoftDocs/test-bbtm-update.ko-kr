### YamlMime:Yaml
ms.openlocfilehash: a95161ff2159e1a2beb17088a3c8da181437bd53
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139898031"
Slug: deep-dive-on-set-body-policy
Title: 세트 본문 정책에 대한 심층 분석
Summary: 집합 본문 정책은 요청 또는 응답 본문을 변경하는 데 사용됩니다. 정책이 인바운드 정책 섹션에 있는 경우 백 엔드 API에 전달된 요청 페이로드를 변경합니다. 그러나 아웃바운드 섹션에 있는 경우 API Management에서 반환한 응답 페이로드를 클라이언트로 변경합니다.
Content: >-
  <p>집합 본문 정책은 요청 또는 응답 본문을 변경하는 데 사용됩니다. 정책이 인바운드 정책 섹션에 있는 경우 백 엔드 API에 전달된 요청 페이로드를 변경합니다. 그러나 아웃바운드 섹션에 있는 경우 API Management에서 반환한 응답 페이로드를 클라이언트로 변경합니다.</p>


  <h2>새 본문 빌드</h2>


  <p>가장 간단한 형태로 구문은 상당히 직선입니다. 다음 정책은 기존 본문을 Hello World 문자열로 대체합니다.</p>


  <blockquote>

  <pre>

  &lt;set-body&gt;Hello World&lt;/set-body&gt;</pre>

  </blockquote>


  <p>정책을 사용할 수 있는 횟수에는 제한이 없지만 정책의 이후 인스턴스는 이전 정책의 내용을 재정의합니다. 본문 콘텐츠는 어떤 방식으로든 추가되거나 스트리밍되지 않습니다. set-body의 내부 텍스트는 메모리 스트림에서 버퍼링되어 받는 사람에게 전달됩니다.</p>


  <p>정적 텍스트를 사용하여 본문을 설정하는 것은 특히 유용하지 않으므로 식을 사용하여 콘텐츠를 동적으로 확인할 수 있습니다. 다음 예제에서는 기존 페이로드를 사용하고 문자열의 모든 인스턴스를 기쁘게 업데이트합니다.</p>


  <blockquote>

  <pre>

  &lt;set-body&gt;


  @(context.Body.As&lt;String&gt;().Replace(&quot;sad&quot;,&quot;happy&quot;))


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>모든 표준 단일 줄 @(...) 또는 여러 줄 @{...} 식은 여기에서 사용할 수 있습니다. 식은 UTF-8로 인코딩된 문자열을 반환해야 합니다. 현재 Content-Type 헤더에 문자 집합 매개 변수가 있는 경우 utf8 값으로 바뀝니다.</p>


  <p>본문에 배치되는 콘텐츠가 받은 것과 완전히 다른 미디어 형식인 경우 Content-Type 헤더를 set-header 정책으로 업데이트해야 합니다.</p>


  <p>집합 본문 정책이 성공적으로 적용되면 항목이 추적 로그에 기록됩니다.</p>


  <h2>사용할 수 있는 위치</h2>


  <p>인바운드 및 아웃바운드 섹션에서 사용할 뿐만 아니라 오류 및 백 엔드 정책 섹션에서도 사용할 수 있습니다. 반환-응답, 선택, 송신 요청, 송신-단방향 요청과 같은 여러 다른 정책 내에 포함할 수 있습니다.</p>


  <h2>복합 본문 만들기</h2>


  <p>임의의 C# 코드를 사용하여 새 본문을 생성하는 기능은 많은 유연성을 제공하지만 일부 시나리오에서는 유지 관리가 가장 쉽지 않은 상당히 복잡한 문자열 연결 코드로 이어질 수 있습니다. 특히 입력 요청 본문에서 일부 정보를 추출하고 전달하기 전에 다시 포맷하는 것이 목표인 경우 특히 그렇습니다.</p>


  <p>다른 방법은 Liquid 템플릿을 사용하여 새 페이로드를 생성하는 다른 세트 본문 모드를 사용하는 것입니다.</p>


  <h2>Liquid 템플릿</h2>


  <p>집합 본문 정책에서 Liquid 템플릿을 사용하려면 템플릿 특성을 요소에 추가해야 합니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  QueryString: {{context.Request.OriginalUrl.QueryString}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>위의 예제에서 Liquid 식의 C# 식에 사용되는 컨텍스트 개체와 유사한 개체 모델을 사용할 수 있음을 알 수 있습니다. 아쉽게도 구문은 동일하지 않습니다. Liquid 바인딩 구문은 맵 및 배열 값에 액세스하는 것으로 제한됩니다. 따라서 헤더 값에 액세스하는 것은 다음과 같습니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  Calling User Agent: {{context.Request.Headers.User-Agent}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>간단한 점 표기법을 사용하거나 대괄호와 문자열 키를 사용하여 지도 액세스할 수 있습니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  Calling User Agent: {{context.Request.Headers[&quot;User-Agent&quot;]}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>헤더 개체는 실제로 문자열 배열의 맵이므로 위의 바인딩 결과는 모든 헤더 값을 함께 연결하는 것입니다. 단일 헤더 값에 액세스하기 위해 배열 인덱스 연산자를 사용할 수 있습니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  First Via: {{context.Request.Headers.Via[0]}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <h2>기존 본문 조작</h2>


  <p>Liquid 템플릿은 페이로드의 형식을 변경하는 데 편리할 수 있습니다. 다음 정책을 고려합니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  orderid: {{body.order.id}}


  date: {{body.order.orderdate}}


  customer:


  id: {{body.order.customer.id}}


  name: {{body.order.customer.name}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>본문 바인딩 개체를 사용하여 XML 또는 JSON 기반 페이로드의 조각에 액세스할 수 있습니다. XML 바인딩은 현재 요소 값에 액세스하는 것으로 제한됩니다. 더 구체적으로 말하자면, 텍스트 노드만 포함하는 요소 내의 텍스트 노드에만 액세스할 수 있습니다.&nbsp; 혼합 콘텐츠 또는 XML 특성 값을 포함하는 요소의 텍스트 노드에는 액세스할 수 없습니다.&nbsp; 점 연산자를 사용하여 개체 및 대괄호를 탐색하여 배열로 인덱싱할 수 있습니다. 본문을 해석하는 방법을 바인더에 나타내기 위해 요청에서 Content-Type 헤더를 보내야 합니다. 애플리케이션/json 또는 +json으로 끝나는 미디어 형식을 사용하여 JSON 및 애플리케이션/xml로 처리하거나 +xml로 끝나는 모든 미디어 형식을 사용하여 본문을 XML로 처리할 수 있습니다.</p>


  <p>위의 템플릿은 다음 페이로드 중 하나에 동일하게 바인딩할 수 있습니다.</p>


  <blockquote>

  <pre>

  &lt;Order&gt;


  &lt;Id&gt;2323&lt;/Id&gt;


  &lt;Date&gt;2017-10-01&lt;/Date&gt;


  &lt;Customer&gt;


  &lt;Id&gt;4545&lt;/Id&gt;


  &lt;Name&gt;Copper Clogs&lt;/Name&gt;


  &lt;/Customer&gt;


  &lt;Order&gt;


  {


  &quot;order&quot;: {


  &quot;id&quot;:&quot;2323&quot;,


  &quot;date&quot;: &quot;2017-10-01&quot;,


  &quot;customer&quot;: {


  &quot;id&quot;: &quot;4545&quot;,


  &quot;name&quot;: &quot;Copper Clogs&quot;


  }


  }


  }</pre>

  </blockquote>


  <h2>값 변환</h2>


  <p>바인딩을 사용하여 페이로드에서 값을 추출할 수 있는 것 외에도 Liquid는 필터를 호출하는 것을 사용하여 개별 값을 변환할 수 있습니다. 날짜 렌더링 방법을 제어하는 필터의 일반적인 사용 중 하나입니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  date: {{body.order.orderdate | Date:&quot;yyyy-MM-dd&quot;}}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>원래 Liquid 프로젝트는 루비 기반 프로젝트였으며 템플릿 언어에 존재하는 특정 Rubyisms가 있습니다. 그러나 사용하는 라이브러리는 .net 포트인 <a href="file:///C:/Users/mibudz/OneDrive%20-%20Microsoft/API%20Management/Blog%20(old)/apimanagement/www.dotliquid.org">dotLiquid</a> 로, 원래 구문의 일부 변형을 허용합니다. 위 예제의 날짜 형식은 Liquid 네이티브 Ruby 스타일 날짜 형식 문자열이 아닌 .net 스타일 날짜 형식입니다. 또 다른 .Net 스타일 문제는 낙타 대/소문자 대신 파스칼 대/소문자 필터를 사용하는 것입니다. 이렇게 하면 Liquid 설명서를 찾고 필터에 날짜를 사용하고 작동하지 않는 예제를 찾을 때 사람들이 정기적으로&#39;.</p>


  <p>현재 필터 구현의 또 다른 까다로운 측면은 특정 문자를 이스케이프해야 한다는 것입니다. 매개 변수는 작은따옴표나 큰따옴표를 사용하여 따옴표로 묶을 수 있지만\ 문자를 사용하여 특수 문자를 이스케이프해야 합니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  date: {{body.path | Replace: &#39;/&#39;,&#39;\\&#39; }}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <h2>사물 컬렉션</h2>


  <p>페이로드에서 항목 컬렉션을 처리하기 위해 for 루프 태그가 대부분의 용도로 작동합니다. 다음 예제에서는 YAML에서 주문 항목 설명 목록을 만듭니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;Liquid&quot;&gt;


  orderid: {{body.order.id}}


  date: {{body.order.orderdate}}


  customer:


  id: {{body.order.customer.id}}


  name: {{body.order.customer.name}}


  items:


  {%for item in body.order.items %} - {{ item.description }}{% endfor %}


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>그러나 JSON을 작성하고 XML 기반 페이로드에서 읽을 때 몇 가지 추가 문제가 있습니다. JSON에서는 목록의 항목을 쉼표로 구분해야 합니다. 아쉽게도 Liquid에서는 목록의 마지막 항목 이후의 후행 쉼표를 방지하는 간단한 방법이 없습니다. 이 문제를 해결하기 위해 사용자 지정 루핑 메커니즘을 만들었습니다.</p>


  <blockquote>

  <pre>

  &lt;set-body template=&quot;liquid&quot;&gt;


  {


  &quot;items&quot;: [


  {%JSONArrayFor item in body.order.items %}&quot;{{ item.description }}&quot;{% endJSONArrayFor %}


  ]


  }


  &lt;/set-body&gt;</pre>

  </blockquote>


  <p>XML에 다른 유형의 컬렉션이 포함되어 있을 때 XML을 JSON으로 변환할 때 직면하는 두 번째 과제입니다. TaxItem 요소만 추출하려는 다음과 같은 페이로드를 고려합니다.</p>


  <blockquote>

  <pre>

  &lt;Order&gt;


  &lt;Items&gt;


  &lt;ProductItem&gt;P1&lt;/ProductItem&gt;


  &lt;ProductItem&gt;P2&lt;/ProductItem&gt;


  &lt;ServiceItem&gt;S1&lt;/ServiceItem&gt;


  &lt;TaxItem&gt;T1&lt;/TaxItem&gt;


  &lt;TaxItem&gt;T2&lt;/TaxItem&gt;


  &lt;TaxItem&gt;T3&lt;/TaxItem&gt;


  &lt;/Items&gt;


  &lt;/Order&gt;


  The JSONArrayFor has a where clause that can filter XML elements that will be looped over.


  &lt;set-body template=&quot;liquid&quot;&gt;


  {


  &quot;items&quot;: [


  {% JSONArrayFor item in body.order.items where TaxItem %}


  &quot;{{ item }}&quot;


  {% endJSONArrayFor %}


  ]


  }


  &lt;/set-body&gt;</pre>

  </blockquote>


  <h2>Cost</h2>


  <p>set-body를 사용하려면 새로 생성된 본문을 버퍼링하고 이전 본문을 모두 사용해야 합니다. 즉, 청크 인코딩을 사용하여 콘텐츠 스트리밍에 의존하는 HTTP 상호 작용의 경우 집합 본문에 허용할 수 없는 비용이 발생할 수 있습니다. 언제나처럼 로드 중인 정책을 테스트한 후 프로덕션 환경에 배치합니다.</p>


  <h2>요약</h2>


  <p>API Management 게이트웨이의 주요 역할은 백 엔드 API에 대한 페이&ccedil;드를 제공하는 것입니다. 요청 및 응답 본문을 변환할 수 있다는 것은 이를 달성하기 위한 핵심입니다. 집합 본문 정책의 다양한 기능은 가장 효과적인 방법으로 HTTP 페이로드를 조작하는 다양한 도구를 제공합니다.</p>
