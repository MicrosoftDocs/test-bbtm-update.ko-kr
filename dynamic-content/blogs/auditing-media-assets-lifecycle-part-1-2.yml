### YamlMime:Yaml
ms.openlocfilehash: 474a7fff4b7c1e3acfa589370f66f4bdf2d2438d
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901831"
Slug: auditing-media-assets-lifecycle-part-1-2
Title: 미디어 자산 감사 수명 주기 - 1부
Summary: 미디어 자산의 수명 주기를 감사하는 데 도움이 되는 일련의 블로그의 1부(샘플 코드 포함)
Content: "높은 가치의 콘텐츠를 다루는 미디어 애플리케이션은 일반적으로 <a href=\"https://www.mpaa.org/\">MPAA</a>, <a href=\"https://www.cdsaonline.org/\">CDSA</a> 또는 동등한 규정 준수 요구 사항을 준수해야 합니다. 관련 감사 프로세스의 일부로 애플리케이션 및 서비스를 통해 전파되는 미디어 자산의 수명 주기를 보여 주는 감사 보고서를 생성하라는 메시지가 표시될 수 있습니다. 이 블로그(여러 부분으로 나뉘어 있음)에서는 미디어 자산이 Media Services 통해 흐르는 감사 보고서를 생성하는 방법을 설명합니다. 이 블로그의 1부에서는 미디어 자산이 만들어지고 삭제된 시기를 보여 주는 자산 감사 보고서를 만들 수 있도록 하는 데 중점을 줍니다.\n\n&nbsp;\n<h2>Media Services 미디어 자산</h2>\n미디어 자산을 <a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#create_an_asset\">만들</a> 때 Media Services GUID를 생성하고 해당 GUID를 사용하여 미디어 자산 ID를 만듭니다. 미디어 자산 ID의 접두사에는 \"nb:cid:UUID:\", GUID가 옵니다. 이러한 ID는 URN 형식입니다. 여기서 \"nb\"는 실제로 내부적으로 Media Services 코드 이름(Nimbus)을 의미하며 cid는 콘텐츠 ID를 의미합니다.즉, 미디어 자산 ID는 \"nb:cid:UUID:&lt;GUID&gt;\" 형식을 사용합니다. 그런 다음 Media Services 자산에 대한 레코드를 만들고 내부적으로 저장합니다. Media Services \"asset-&lt; 지정한 Storage 계정의 GUID&gt;\"입니다. 자산이 만들어지면 스토리지 컨테이너에 미디어 파일을 업로드할 수 있습니다. 미디어 자산을 <a href=\"https://msdn.microsoft.com/en-us/library/hh974277.aspx#delete_an_asset\">삭제</a>하면 Media Services 내부 데이터베이스에서 자산 레코드를 삭제하고 스토리지 컨테이너도 삭제합니다. 이 경우 Media Services API를 사용하여 자산이 삭제되지 않은 한 자산의 생성 시간을 결정할 수 있지만 미디어 애플리케이션에서 추적하지 않는 한 자산의 삭제 시간을 확인할 수 있는 방법은 없습니다.\n\n&nbsp;\n<h2>Storage 로그를 통해 미디어 자산 만들기 및 삭제 추적</h2>\n미디어 자산은 Storage 컨테이너로 표시되므로 Storage 로그를 사용하여 미디어 자산의 생성 및 삭제 시간을 결정할 수 있습니다. 이렇게 하려면 Storage 계정에서 Storage 로깅을 사용하도록 설정해야 합니다. 방법: 이에 대해 알아보도록 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/storage-monitor-storage-account/#configurelogging\">로깅 구성</a> 을 참조하세요. 선택한 보존 정책은 감사 보고서에서 얼마나 멀리 돌아갈 수 있는지에 대한 기능을 결정합니다. 0을 선택하면 로그가 삭제되지 않으며 로깅을 사용하도록 설정한 날짜까지 거슬러 올라갈 수 있습니다. Azure Storage <strong>$logs라는 컨테이너</strong>의 스토리지 계정에 로그를 저장합니다. 로그 저장 및 로그 명명 규칙에 대한 자세한 내용은 <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh343262.aspx\">Storage Analytics 로깅</a> MSDN 페이지에서 확인할 수 있습니다.\n\n&nbsp;\n<h2>샘플 코드</h2>\n아래에 제공된 샘플 코드는 Media Services Assets 컬렉션과 Storage 로그를 모두 사용하여 <strong>AssetAudit</strong>이라는 Azure Storage 테이블을 생성합니다. 이 테이블은 자산 생성 및 삭제 시간을 보여 주는 자산 감사 보고서를 생성하는 데 사용할 수 있습니다. 대략적으로 논리는 다음과 같습니다.\n<ul>\n <li>코드는 Media Services API를 사용하여 모든 자산을 열거합니다.</li>\n <li>열거된 각 자산에 대해 Asset.Created 속성을 사용하여 <strong>AssetAudit</strong> 테이블에 테이블 항목을 만듭니다.</li>\n <li>그런 다음, $logs/Blob 아래의 모든 Blob을 열거합니다.</li>\n <li>각 Blob에 대해 파일을 다운로드하고 <a href=\"https://msdn.microsoft.com/en-us/library/azure/hh343259.aspx\">Storage Analytics 로그 형식</a> MSDN 페이지에 설명된 로그 항목 형식에 따라 구문 분석합니다.</li>\n <li>이 코드는 \"asset-\"로 시작하는 개체에서 발생한 작업을 찾습니다.</li>\n <li>CreateContainer 및 DeleteContainer 작업 유형을 필터링하고 <strong>AssetAudit</strong> 테이블에 해당 항목을 만듭니다.</li>\n</ul>\n샘플의 App.Config 파일은 다음과 같습니다.\n<pre class=\"prettyprint\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;configuration&gt;\n  &lt;startup&gt;\n    &lt;supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /&gt;\n  &lt;/startup&gt;\n  &lt;appSettings&gt;\n    &lt;add key=\"MediaServicesAccountName\" value=\"&lt;MediaAccountName&gt;\" /&gt;\n    &lt;add key=\"MediaServicesAccountKey\" value=\"&lt;MediaAccountKey&gt;\" /&gt;\n    &lt;add key=\"StorageConnectionString\" value=\"DefaultEndpointsProtocol=https;AccountName=&lt;StorageAccountName&gt;;AccountKey=&lt;StorageAccountKey&gt;\"/&gt;\n  &lt;/appSettings&gt;\n  &lt;runtime&gt;\n    &lt;assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\"&gt;\n      &lt;dependentAssembly&gt;\n        &lt;assemblyIdentity name=\"Microsoft.WindowsAzure.Storage\" publicKeyToken=\"31bf3856ad364e35\" culture=\"neutral\" /&gt;\n        &lt;bindingRedirect oldVersion=\"0.0.0.0-4.1.0.0\" newVersion=\"4.1.0.0\" /&gt;\n      &lt;/dependentAssembly&gt;\n    &lt;/assemblyBinding&gt;\n  &lt;/runtime&gt;\n&lt;/configuration&gt;</pre>\n위의 App.Config MediaAccountName&gt; 및 &lt;MediaAccountKey&gt;를 Media Services 계정 이름 및 키로 바꿉&lt;다. 또한 StorageAccountName&gt; 및 &lt;StorageAccountKey&gt;를 Media Services 계정과 연결된 스토리지 계정의 이름 및 키로 바꿉&lt;니다.\n\n코드는 다음과 같습니다.\n<pre class=\"prettyprint\">using System;\nusing System.Linq;\nusing System.Configuration;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.WindowsAzure;\nusing Microsoft.WindowsAzure.Storage;\nusing Microsoft.WindowsAzure.Storage.Blob;\nusing Microsoft.WindowsAzure.Storage.Table;\nusing Microsoft.WindowsAzure.MediaServices.Client;\n\nnamespace AssetAuditing\n{\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    public class AssetAuditEntity : TableEntity\n    {\n        public string OperationType { get; set; }\n    }\n\n    /// &lt;summary&gt;\n    /// \n    /// &lt;/summary&gt;\n    class Program\n    {\n        // Read values from the App.config file.\n        private static readonly string _mediaServicesAccountName = ConfigurationManager.AppSettings[\"MediaServicesAccountName\"];\n        private static readonly string _mediaServicesAccountKey = ConfigurationManager.AppSettings[\"MediaServicesAccountKey\"];\n        private static readonly string _storageConnectionString = ConfigurationManager.AppSettings[\"StorageConnectionString\"];\n        private static string _lastLogFile = ConfigurationManager.AppSettings[\"LastLogFile\"];\n\n        // Field for service context.\n        private static CloudMediaContext _context = null;\n        private static MediaServicesCredentials _cachedCredentials = null;\n        private static CloudStorageAccount _cloudStorage = null;\n\n        private static CloudBlobClient _blobClient = null;\n        private static CloudTableClient _tableClient = null;\n        private static CloudTable _assetAuditTable = null;\n\n        /// &lt;summary&gt;\n        /// \n        /// &lt;/summary&gt;\n        /// &lt;param name=\"args\"&gt;&lt;/param&gt;\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create and cache the Media Services credentials in a static class variable.\n                _cachedCredentials = new MediaServicesCredentials(_mediaServicesAccountName, _mediaServicesAccountKey);\n\n                // Used the chached credentials to create CloudMediaContext.\n                _context = new CloudMediaContext(_cachedCredentials);\n\n                _cloudStorage = CloudStorageAccount.Parse(_storageConnectionString);\n\n                _blobClient = _cloudStorage.CreateCloudBlobClient();\n                _tableClient = _cloudStorage.CreateCloudTableClient();\n\n                _assetAuditTable = _tableClient.GetTableReference(\"AssetAudit\");\n                _assetAuditTable.CreateIfNotExists();\n\n                ProcessAssetData();\n                ParseStorageLogs();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses all the storage log files under $logs container\n        /// It skips the files that have already been parsed in the last run based on the entry in app.config\n        /// &lt;/summary&gt;\n        static void ParseStorageLogs()\n        {\n            try\n            {\n                // Enumerate all blobs under $logs/blob\n                foreach (CloudBlockBlob _blobItem in _blobClient.ListBlobs(\"$logs/blob\", true))\n                {\n                    // The blobs will be enumerated in ascending order\n                    // Since the logs are organized in chronological order, you can compare the blob name with the last processed logfile to make sure you are not reprocessing it                    \n                    if (String.Compare(_blobItem.Name, _lastLogFile) &gt; 0)\n                    {\n                        try\n                        {\n                            Console.WriteLine(\"Processing \" + _blobItem.Name);\n                            string _logs = GetBlobData(_blobItem);  // Download the blob\n\n                            // Get individual loglines by looking for the newline separator\n                            List&lt;string&gt; _logLines = ParseDelimitedString(_logs, \"\\n\");\n\n                            for (int i = 0; i &lt; _logLines.Count; i++)\n                            {\n                                // Separate out the log items by looking for the ; separator\n                                List&lt;string&gt; _logLineItems = ParseDelimitedString(_logLines[i], \";\");\n                                if (_logLineItems.Count &gt; 0)\n                                {\n                                    // Parse each log line\n                                    ParseLogLine(_logLineItems);\n                                }\n                            }\n\n                            // Stored the blob name as the last log file that was processed\n                            _lastLogFile = _blobItem.Name;\n                            SaveLastLogFileInConfig();\n                        }\n                        catch (Exception x)\n                        {\n                            Console.WriteLine(x.Message + x.InnerException.StackTrace);\n                        }\n                    }\n                    else\n                    {\n                        Console.WriteLine(\"Skipping \" + _blobItem.Name);\n                    }\n                }\n\n                SaveLastLogFileInConfig();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function loops through all the assets (1000 at a time) in the Media Services account and logs the Asset Create time in the AssetAudit Table\n        /// &lt;/summary&gt;\n        static void ProcessAssetData()\n        {\n            try\n            {\n                int skipSize = 0;\n                int batchSize = 1000;\n                int currentSkipSize = 0;\n\n                while (true)\n                {\n                    // Enumerate through all assets (1000 at a time)\n                    foreach (IAsset asset in _context.Assets.Skip(skipSize).Take(batchSize))\n                    {\n                        currentSkipSize++;\n                        Console.WriteLine(\"Processing Asset \" + asset.Id);\n\n                        // Enter the Create time of the asset in the AssetAudit table\n                        InsertAssetData(asset.Id, asset.Created.ToString(\"o\"), \"Create\");\n                    }\n\n                    if (currentSkipSize == batchSize)\n                    {\n                        skipSize += batchSize;\n                        currentSkipSize = 0;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function saves the last log file parsed in the app config\n        /// &lt;/summary&gt;\n        static void SaveLastLogFileInConfig()\n        {\n            var configFile = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);\n            var settings = configFile.AppSettings.Settings;\n            if (settings[\"LastLogFile\"] == null)\n            {\n                settings.Add(\"LastLogFile\", _lastLogFile);\n            }\n            else\n            {\n                settings[\"LastLogFile\"].Value = _lastLogFile;\n            }\n\n            configFile.Save(ConfigurationSaveMode.Modified);\n            ConfigurationManager.RefreshSection(configFile.AppSettings.SectionInformation.Name);\n        }\n\n        /// &lt;summary&gt;\n        /// This function downloads the blob and loads the data in it as a string\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_blobItem\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        static string GetBlobData(CloudBlockBlob _blobItem)\n        {\n            MemoryStream ms = new MemoryStream();\n            _blobItem.DownloadToStream(ms);\n\n            byte[] buffer = new byte[ms.Length];\n            ms.Seek(0, SeekOrigin.Begin);\n            ms.Read(buffer, 0, (int)ms.Length);\n\n            string _logs = Encoding.UTF8.GetString(buffer);\n\n            ms.Dispose();\n\n            return _logs;\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses a string and generates a list of substrings separated by the specified delimiter\n        /// The function ignores the delimiter insides quotes\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_stringToParse\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"strDelimiter\"&gt;&lt;/param&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static List&lt;string&gt; ParseDelimitedString(string _stringToParse, string strDelimiter)\n        {\n            List&lt;string&gt; _parsedStrings = new List&lt;string&gt;();\n            if (!String.IsNullOrEmpty(_stringToParse))\n            {\n                int j = 0;\n                int i = _stringToParse.IndexOf(strDelimiter);\n                while (i &gt;= 0)\n                {\n                    if (_stringToParse.Length &gt; 0)\n                    {\n                        // This piece of code is to check if the substring starts with a quote\n                        // If it does then the code finds the matching pair and looks the delimiter beyond that\n                        if (_stringToParse[j] == '\\\"')\n                        {\n                            i = _stringToParse.IndexOf(\"\\\"\", j + 1);\n                            if (i &gt; 0)\n                            {\n                                i = _stringToParse.IndexOf(strDelimiter, i);\n                            }\n                        }\n                    }\n\n                    string _str = _stringToParse.Substring(j, i - j);\n                    _parsedStrings.Add(_str);\n\n                    j = i + strDelimiter.Length;\n                    i = _stringToParse.IndexOf(strDelimiter, j);\n                }\n\n                _parsedStrings.Add(_stringToParse.Substring(j, _stringToParse.Length - j));\n            }\n\n            return _parsedStrings;\n        }\n\n        /// &lt;summary&gt;\n        /// This function parses a line of log\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_logLineItems\"&gt;&lt;/param&gt;\n        static void ParseLogLine(List&lt;string&gt; _logLineItems)\n        {\n            try\n            {\n                // Check to make sure we are dealing 1.0 logs and that all the log items are parsed out properly\n                if ((_logLineItems[0] == \"1.0\") &amp;&amp; (_logLineItems.Count == 30))\n                {\n                    // Parsing out the necessary log items. We dont need all the items for this sample\n                    string _requestedObjectKey = _logLineItems[12];\n\n                    string _assetPrefix = \"\\\"/\" + _cloudStorage.Credentials.AccountName + \"/asset-\";\n                    int _assetIdIndex = _requestedObjectKey.IndexOf(_assetPrefix);\n                    if (_assetIdIndex == 0)\n                    {\n                        Console.WriteLine(\"Processing ObjectKey=\" + _requestedObjectKey);\n\n                        _assetIdIndex += _assetPrefix.Length;\n                        int j = _requestedObjectKey.IndexOf(\"/\", _assetIdIndex);\n                        if (j &lt; 0)\n                        {\n                            j = _requestedObjectKey.Length - 1;\n                        }\n                        string _assetId = _requestedObjectKey.Substring(_assetIdIndex, j - _assetIdIndex);\n                        _assetId = \"nb:cid:UUID:\" + _assetId;\n\n                        string _timeStamp = _logLineItems[1];\n                        string _operationType = _logLineItems[2];\n                        string _requestStatus = _logLineItems[3];\n                        string _authType = _logLineItems[7];\n\n                        string _requesterIpAddress = _logLineItems[15];\n\n                        Console.WriteLine(\"Processing Asset Id:\" + _assetId + \" TimeStamp:\" + _timeStamp + \" OperationType:\" + _operationType);\n\n                        switch (_operationType)\n                        {\n                            case \"CreateContainer\":\n                                _operationType = \"Create\";\n                                InsertAssetData(_assetId, _timeStamp, _operationType);\n                                break;\n\n                            case \"DeleteContainer\":\n                                _operationType = \"Delete\";\n                                InsertAssetData(_assetId, _timeStamp, _operationType);\n                                break;\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.Message + ex.InnerException.StackTrace);\n            }\n        }\n\n        /// &lt;summary&gt;\n        /// This function adds an entry in the AssetAudit table\n        /// For Create operations, it checks if the entry already exists. This is to avoid duplicate entries as there are two sources of data\n        /// The Assets collection and the Storage logs may have slightly different timestamps due to clock skew between different Azure role instances\n        /// &lt;/summary&gt;\n        /// &lt;param name=\"_assetId\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"_timeStamp\"&gt;&lt;/param&gt;\n        /// &lt;param name=\"_operationType\"&gt;&lt;/param&gt;\n        static void InsertAssetData(string _assetId, string _timeStamp, string _operationType)\n        {\n            try\n            {\n                bool _insert = true;\n                if (_operationType == \"Create\")\n                {\n                    // If operationtype is Create, then check if an entry already exists for the given asset id\n\n                    TableQuery&lt;AssetAuditEntity&gt; query = new TableQuery&lt;AssetAuditEntity&gt;().Where(TableQuery.GenerateFilterCondition(\"PartitionKey\", QueryComparisons.Equal, _assetId));\n                    query.Take(1);\n\n                    TableQuerySegment&lt;AssetAuditEntity&gt; tqs = _assetAuditTable.ExecuteQuerySegmented(query, null);\n                    if ((tqs != null) &amp;&amp; (tqs.Results != null))\n                    {\n                        if (tqs.Results.Count &gt; 0)\n                        {\n                            if (tqs.Results[0].OperationType == \"Create\")\n                            {\n                                _insert = false;\n                            }\n                        }\n                    }\n                }\n\n                if (_insert)\n                {\n                    AssetAuditEntity _asset = new AssetAuditEntity();\n                    _asset.PartitionKey = _assetId;\n                    _asset.RowKey = _timeStamp;\n                    _asset.OperationType = _operationType;\n\n                    TableOperation op = TableOperation.Insert(_asset);\n                    _assetAuditTable.Execute(op);\n                }\n            }\n            catch (Exception ex)\n            {                \n                Console.WriteLine(ex.Message);                \n            }\n        }\n\n    }\n}</pre>\n위의 코드에서 함수에 대한 간략한 설명은 다음과 같습니다.\n\n<strong>ProcessAssetData</strong>\n\n이 함수는 제공된 Media Services 계정의 모든 자산을 반복합니다. 기본적으로 Media Services Assets 컬렉션에 1000개의 자산을 반환합니다. 이 함수는 Skip 및 Take를 사용하여 모든 자산이 열거되었는지 확인합니다(계정에 자산이 1000개 이상 있는 경우).\n\n<strong>ParseStorageLogs</strong>\n\n이 함수는 <strong>$logs/Blob</strong> 아래의 모든 Blob을 열거하고 처리된 Blob을 마지막으로 처리된 로그 파일로 저장하여 코드가 반복적으로 실행되는 경우 다시 처리되지 않도록 합니다.\n\n<strong>SaveLastLogFileInConfig</strong>\n\n이 함수는 마지막으로 처리된 로그 파일 이름을 App.Config 저장하여 프로그램을 다시 실행하는 경우 검색할 수 있도록 합니다.\n\n<strong>GetBlobData</strong>\n\n이 함수는 Storage Blob을 다운로드하고 콘텐츠를 문자열로 읽습니다.\n\n<strong>ParseDelimitedString</strong>\n\n이 함수는 제공된 구분 기호를 기반으로 문자열을 구문 분석합니다. 구문 분석된 데이터는 문자열 컬렉션으로 반환됩니다.\n\n<strong>ParseLogLine</strong>\n\n이 함수는 각 로그 줄을 구문 분석하여 \"asset-\"로 시작하는 컨테이너에 대한 CreateContainer 및 DeleteContainer 작업을 추출합니다.\n\n<strong>InsertAssetData</strong>\n\n이 함수는 AssetAudit 테이블에 항목을 추가합니다.\n\n&nbsp;\n<h2>자산 감사 데이터</h2>\n위의 코드를 실행하면 AssetAudit 테이블이 만들어집니다. 다음은 사용한 테스트 계정에 대한 이 테이블의 내용 스크린샷입니다. 자산에 대해 일치하는 만들기 및 삭제 쌍을 강조 표시했습니다. 이러한 항목은 위의 코드가 Media Services 더 이상 항목이 없으므로 실행된 경우에만 Storage 로그에서 캡처할 수 있습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-07_16h24_01.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-07_16h24_01\" alt=\"2014-07-07_16h24_01\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-07_16h24_01_thumb.png\" width=\"644\" height=\"359\" border=\"0\" /></a>\n\n<a href=\"https://office.microsoft.com/en-us/excel-help/introduction-to-microsoft-power-query-for-excel-HA104003940.aspx?CTT=5&amp;origin=HA104003813\">Excel 파워 쿼리</a>를 사용하여 위의 테이블 데이터를 Excel 로드할 수도 있습니다. Excel 사용하면 추가 필터링을 수행하거나 추가 분석을 위해 피벗 테이블에 위의 항목을 로드할 수 있습니다. 파워 쿼리에 Excel 사용한 적이 없는 경우 \"<a href=\"https://office.microsoft.com/en-us/excel/download-microsoft-power-query-for-excel-FX104018616.aspx\">Excel 위해 Microsoft 파워 쿼리 다운로드</a>\" 웹 페이지에서 다운로드할 수 있습니다. 설치되면 Excel 시작할 수 있으며 \"파워 쿼리\"라는 탭이 표시됩니다. 해당 탭을 클릭한 다음 \"다른 원본에서\" 단추를 클릭하면 아래 스크린샷과 같이 \"Windows Azure Table Storage\"라는 메뉴 항목이 표시됩니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-06_00h21_51.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-06_00h21_51\" alt=\"2014-07-06_00h21_51\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-06_00h21_51_thumb.png\" width=\"1028\" height=\"540\" border=\"0\" /></a>\n\n&nbsp;\n\n<strong>AssetAudit</strong> 테이블에서 데이터를 가져오려면 위의 메뉴 항목을 선택하고 지침을 따릅니다. 테이블이 오른쪽의 \"탐색기\" 창에 로드되면 <strong>AssetAudit </strong>테이블을 두 번 클릭하면 새 창이 열립니다. 해당 창의 스크린샷은 다음과 같습니다.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/07/2014-07-07_16h35_30.png\"><img style=\"padding-top: 0px;padding-left: 0px;padding-right: 0px;border-width: 0px\" title=\"2014-07-07_16h35_30\" alt=\"2014-07-07_16h35_30\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2014-07-07_16h35_30_thumb.png\" width=\"644\" height=\"462\" border=\"0\" /></a>\n\n\"콘텐츠\"라는 레이블이 지정된 열 옆에 있는 단추를 클릭한 다음 확인을 클릭합니다. 그런 다음 맨 위에 있는 \"닫기 적용 &amp; \" 단추를 클릭할 수 있습니다. 그러면 현재 창이 닫히고 테이블 데이터가 Excel 로드됩니다. 이제 Excel 사용하여 적합한 방식으로 데이터를 분석할 수 있습니다.\n\n&nbsp;\n<h2>고려 사항</h2>\n마지막으로 애플리케이션에 이 샘플 코드를 사용하는 것이 좋습니다.\n<ul>\n <li>이 블로그에 제공된 샘플 코드는 단일 스토리지 계정에 모든 자산이 있는 Media Services 계정으로 작동하도록 설계되었지만 여러 스토리지 계정으로 작업하도록 쉽게 조정할 수 있습니다.</li>\n <li>감사는 Storage 로그와 연결된 보존 정책으로 제한됩니다.</li>\n <li>디버거에서 샘플을 실행하면 App.Config 파일이 마지막으로 처리된 로그 Blob으로 업데이트되지 않습니다. 이 문제는 디버거 외부에서 샘플을 실행할 때만 발생합니다.</li>\n <li>예외는 콘솔에만 인쇄됩니다. 이러한 오류를 Azure 테이블 또는 로컬 파일에 기록하여 오류를 확인할 수 있습니다(있는 경우).</li>\n</ul>"
