### YamlMime:Yaml
ms.openlocfilehash: eeec37f1e5029e7d49a3211cb89c933d22d96bbf
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139897200"
Slug: real-time-feature-engineering-for-machine-learning-with-documentdb
Title: DocumentDB를 사용하여 Machine Learning 위한 Real-Time 기능 엔지니어링
Summary: Machine Learning 솔루션을 위해 DocumentDB에 저장된 데이터를 활용하고 싶었던 적이 있나요? 이 블로그 게시물에서는 Azure DocumentDB에서 기계 학습 애플리케이션에 대한 이벤트 모델링, 기능화 및 유지 관리 기능을 시작하는 방법을 보여 줍니다.
Content: "<blockquote>\n<p>Machine Learning 솔루션을 위해 DocumentDB에 저장된 데이터를 활용하고 싶었던 적이 있나요? 이 블로그 게시물에서는 Azure DocumentDB에서 기계 학습 애플리케이션에 대한 이벤트 모델링, 기능화 및 유지 관리 기능을 시작하는 방법을 보여 줍니다.</p>\n</blockquote>\n\n<h2>Machine Learning 및 RFM</h2>\n\n<p>기계 학습 분야는 기계 &ndash; 학습이 일상 생활에 영향을 미치는 모든 방법을 정확히 파악하기가 어렵습니다. 스트리밍 음악 서비스를 구동하는 권장 엔진부터 작물 수확량을 예측하는 모델에 이르기까지 기계 학습은 예측을 위해 우리 주변에 사용됩니다. 컴퓨터에서 데이터의 패턴을 생각하고 인식하는 방법을 가르치는 방법인 기계 학습은 인간이 수행할 메모리 용량과 계산 능력을 갖지 못하는 거대한 데이터 세트 &ndash; 로부터 인사이트를 얻는 데 점점 더 많이 사용되고 있습니다.</p>\n\n<p>이벤트 모델링 및 기계 학습의 세계에서 RFM은 이상한 개념이 아닙니다. 3차원(<strong>Recency</strong>, <strong>Frequency</strong>, <strong>Monetary</strong>)에 의해 구동되는 RFM은 기계 학습 모델에서 자주 사용되는 고객을 분할하기 위한 간단하면서도 강력한 방법입니다. RFM의 추론은 대부분의 시나리오에서 직관적이고 일관적입니다. 어제 무언가를 구입한 고객은 1년 동안 아무것도 구입하지 않은 고객보다 다른 구매를 할 가능성이 더 높습니다. 또한 자주 구매하는 소비 고객도 RFM 기술을 사용하여 가치 있는 것으로 분류됩니다.</p>\n\n<p>RFM 기능의 속성:</p>\n\n<ul>\n <li>RFM 기능 값은 <strong>기본 데이터베이스 작업을</strong> 사용하여 계산할 수 있습니다.</li>\n <li>새 이벤트가 도착하면 원시 값을 <strong>온라인으로 업데이트</strong> 할 수 있습니다.</li>\n <li>RFM 기능은 <strong>기계 학습 모델</strong>에서 유용합니다.</li>\n</ul>\n\n<p>원시 데이터에서 가져온 인사이트는 시간이 지남에 따라 유용하지 않으므로 의사 결정에 도움이 되도록 거의 실시간으로 RFM 기능을 계산할 수 있는 것이 중요합니다[1]. 따라서 다양한 문제에 RFM 기능을 사용할 수 있도록 이벤트 로그를 보내고 거의 실시간으로 자동으로 기능을 제공할 수 있는 일반적인 솔루션이 이상적입니다.</p>\n\n<h2>DocumentDB는 어디에 적합하나요?</h2>\n\n<p><a href=\"https://azure.microsoft.com/services/documentdb/\">Azure DocumentDB</a> 는 낮은 대기 시간 및 높은 처리량으로 원활하게 확장되는 고가용성 글로벌 분산 앱을 위한 매우 빠른 행성 규모의 NoSQL 데이터베이스 서비스입니다. JavaScript의 언어 통합 트랜잭션 실행을 통해 개발자는 JavaScript에서 기본적으로 저장 프로시저, 트리거 및 UDF(사용자 정의 함수)를 작성할 수 있습니다.</p>\n\n<p>이러한 기능 덕분에 DocumentDB는 앞서 언급한 시간 제약 조건을 충족하고 이벤트 로그를 수집하고 고객을 정확하게 분할하는 기계 학습 모델을 학습시키는 데 적합한 형식으로 RFM 기능으로 구성된 데이터 세트에 도착하는 사이에 누락된 부분을 채울 수 있습니다. JavaScript 저장 프로시저를 사용하여 RFM 기능의 계산을 지원하는 데 사용되는 기능화 논리 및 확률적 데이터 구조를 구현했기 때문에 이 논리는 데이터베이스 스토리지 파티션에서 직접 제공되고 실행됩니다. 이 게시물의 나머지 부분에는 변동 예측 시나리오를 위해 DocumentDB에서 이벤트 모델링 및 기능 데이터 유지 관리를 시작하는 방법을 보여 줍니다.</p>\n\n<p>문서 목록을 DocumentDB에 업로드 및 추천하고 RFM 기능 메타데이터를 업데이트하는 방법의 엔드 투 엔드 코드 샘플은 <a href=\"https://github.com/Azure-Samples/documentdb-dotnet-rfm\">GitHub</a> 호스트됩니다.</p>\n\n<h2>시나리오</h2>\n\n<p>기계 학습 및 이벤트 모델링 공간에 대한 다이빙을 시작하기 위해 해결하기로 선택한 첫 번째 시나리오는 연례 데이터 마이닝 및 지식 검색 대회인 2015 KDD Cup의 문제입니다. 이 대회의 목표는 중국에서 가장 큰 MOOC(대규모 오픈 코스) 플랫폼 중 하나인 XuetangX에서의 이전 활동을 기반으로 학생이 코스에서 중퇴할지 여부를 예측하는 것이었습니다.</p>\n\n<p>데이터 세트는 다음과 같이 구조화됩니다.</p>\n\n<p><img alt=\"Real-Time Feature Engineering for Machine Learning with DocumentDB\" border=\"0\" height=\"160\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/5ba050d2-0974-4feb-8c26-0c90b723ae9f.jpg\" style=\"border: 0px currentColor; border-image: none; padding-top: 0px; padding-right: 0px; padding-left: 0px; margin-right: auto; margin-left: auto; float: none; display: block; background-image: none;\" title=\"DocumentDB를 사용하여 Machine Learning 위한 Real-Time 기능 엔지니어링\" width=\"480\"></p>\n\n<p align=\"center\">그림 1. KDD Cup 2015의 주최자뿐만 아니라 데이터 세트를 사용할 수 있도록 XuetangX의 주최자에게 감사드립니다.</p>\n\n<p>각 이벤트는 학생이 완료한 작업에 대해 자세히 설명합니다. 예를 들어 비디오를 보거나 특정 질문에 대답하는 것이 있습니다. 모든 이벤트는 타임스탬프, 과정 ID(cid), 학생 ID(uid) 및 각 과정-학생 쌍에 대해 고유한 등록 ID(eid)로 구성됩니다.</p>\n\n<h2>접근 방식</h2>\n\n<h3>이벤트 로그 모델링</h3>\n\n<p>첫 번째 단계는 DocumentDB에서 이벤트 로그를 문서로 모델링하는 방법을 결정하는 것이었습니다. 우리는 두 가지 주요 접근 방식을 고려했습니다. 첫 번째 방법에서는 엔터티 이름, 엔터티 값, 기능 이름의&gt; 조합을 &lt;각 문서의 기본 키로 사용했습니다. 이 전략의 기본 키 예는 eid, 1, &ldquo;cat&gt;&rdquo;입니다&lt;&rdquo;.&rdquo; 즉, 학생 등록 ID가 1인 시점을 추적하려는 각 기능에 대해 별도의 문서를 만들었습니다. 많은 수의 기능의 경우 삽입할 문서가 많을 수 있습니다. 두 번째 반복에서 엔터티 이름, 엔터티 값을&gt; 기본 키로 사용하여 &lt;대량 접근 방식을 취했습니다. 이 전략의 예제 기본 키는 eid, 1&gt;입니다&lt;&rdquo;.&rdquo; 이 방법에서는 단일 문서를 사용하여 학생 등록 ID가 1일 때 모든 기능 데이터를 추적했습니다.</p>\n\n<p>첫 번째 방법은 추가 기능 이름 특성이 있으므로 삽입 중에 충돌 횟수를 최소화하여 기본 키를 더 고유하게 만듭니다. 그러나 많은 기능의 경우 각 기능에 대해 추가 문서를 삽입해야 하므로 결과 처리량이 최적이 아닙니다. 두 번째 방법은 이벤트 로그를 대량으로 기능화하고 삽입하여 처리량을 최대화하여 충돌 가능성을 높입니다. 이 블로그 게시물에서는 더 간단한 코드와 더 적은 수의 구성을 제공하는 첫 번째 방법을 안내하기로 결정했습니다.</p>\n\n<h3>1단계</h3>\n\n<p>RFM 기능 메타데이터 업데이트를 담당하는 저장 프로시저를 만듭니다.</p>\n\n<pre class=\"prettyprint\">\nprivate static async Task CreateSproc()\n{\n    string scriptFileName = @&quot;updateFeature.js&quot;;\n    string scriptName = &quot;updateFeature&quot;;\n    string scriptId = Path.GetFileNameWithoutExtension(scriptFileName);\n\n    var client = new DocumentClient(new Uri(Endpoint), AuthKey);\n    Uri collectionLink = UriFactory.CreateDocumentCollectionUri(DbName, CollectionName);\n\n    var sproc = new StoredProcedure\n    {\n        Id = scriptId,\n        Body = File.ReadAllText(scriptFileName)\n    };\n    Uri sprocUri = UriFactory.CreateStoredProcedureUri(DbName, CollectionName, scriptName);\n\n    bool needToCreate = false;\n\n    try\n    {\n        await client.ReadStoredProcedureAsync(sprocUri);\n    }\n    catch (DocumentClientException de)\n    {\n        if (de.StatusCode != HttpStatusCode.NotFound)\n        {\n            throw;\n        }\n        else\n        {\n            needToCreate = true;\n        }\n    }\n\n    if (needToCreate)\n    {\n        await client.CreateStoredProcedureAsync(collectionLink, sproc);\n    }\n}</pre>\n\n<h3>2단계</h3>\n\n<p>각 이벤트를 추천합니다. 이 예제에서 각 학생 작업은 { 엔터티 형식의 12개 행으로 확장됩니다. <strong>{ name: , value: &ldquo; &ldquo;&hellip;}, feature: { name: &ldquo; &ldquo;, value: &hellip;} } </strong>- 이전에 만든 저장 프로시저를 사용하여 DocumentDB 컬렉션에 삽입해야 합니다. 이 프로세스를 일괄 처리로 수행했으며, 그 크기는 구성할 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\nprivate static string[] Featurize(RfmDoc doc)\n{\n    List&lt;string&gt; result = new List&lt;string&gt;();\n\n    var entities = new Tuple&lt;string, object&gt;[] { new Tuple&lt;string, object&gt;(&quot;eid&quot;, doc.Eid), new Tuple&lt;string, object&gt;(&quot;cid&quot;, doc.Cid), \n        new Tuple&lt;string, object&gt;(&quot;uid&quot;, doc.Uid) };\n    var features = new Tuple&lt;string, object&gt;[] { new Tuple&lt;string, object&gt;(&quot;time&quot;, doc.Time), new Tuple&lt;string, object&gt;(&quot;src_evt&quot;, doc.SourceEvent), \n        new Tuple&lt;string, object&gt;(&quot;cat&quot;, doc.Cat), new Tuple&lt;string, object&gt;(&quot;obj&quot;, doc.Obj) };\n\n    foreach (var entity in entities)\n    {\n        foreach (var feature in features)\n        {\n            StringBuilder eb = new StringBuilder();\n            StringBuilder fb = new StringBuilder();\n            StringWriter eWriter = new StringWriter(eb);\n            StringWriter fWriter = new StringWriter(fb);\n\n            JsonSerializer s = new JsonSerializer();\n            s.Serialize(eWriter, entity.Item2);\n            string eValue = eb.ToString();\n\n            s.Serialize(fWriter, feature.Item2);\n            string fValue = fb.ToString();\n\n            var value = string.Format(CultureInfo.InvariantCulture, &quot;{{\\&quot;entity\\&quot;:{{\\&quot;name\\&quot;:\\&quot;{0}\\&quot;,\\&quot;value\\&quot;:{1}}},\\&quot;feature\\&quot;:{{\\&quot;name\\&quot;:\\&quot;{2}\\&quot;,\\&quot;value\\&quot;:{3}}}}}&quot;,\n                entity.Item1, eValue, feature.Item1, fValue);\n            result.Add(value);\n        }\n    }\n\n    return result.ToArray();\n}</pre>\n\n<h3>3단계</h3>\n\n<p>1단계에서 만든 저장 프로시저를 실행합니다.</p>\n\n<pre class=\"prettyprint\">\nprivate static async Task&lt;StoredProcedureResponse&lt;string&gt;&gt; UpdateRFMMetadata(DocumentClient client, string metaDoc)\n{\n    object metaDocObj = JsonConvert.DeserializeObject(metaDoc);\n\n    int retryCount = 100;\n    while (retryCount &gt; 0)\n    {\n        try\n        {\n            Uri sprocUri = UriFactory.CreateStoredProcedureUri(DbName, CollectionName, &quot;updateFeature&quot;);\n            var task = client.ExecuteStoredProcedureAsync&lt;string&gt;(\n                sprocUri,\n                metaDocObj);\n            return await task;\n        }\n        catch (DocumentClientException ex)</pre>\n\n<p>저장 프로시저는 { 엔터티 형식의 행을 입력으로 사용합니다<b>. { name: &ldquo; &rdquo;, value: &hellip;}, feature: { name: , value: &ldquo; &rdquo;&hellip;} }</b> 및 관련 기능 메타데이터를 업데이트하여 <b>양식 { 엔터티의 문서를 생성합니다. { name: &quot;&quot;, value:&quot; &quot;}, feature: { name: { name: &quot;&quot;, value: ...}, isMetadata: true, aggregates: { &quot;count&quot;: ..., &quot;min&quot;: ... } }</b>. DocumentDB에 삽입되는 문서의 기능 이름에 따라 미리 정의된 집계의 하위 집합이 업데이트됩니다. 예를 들어 문서의 &ldquo;기능 이름이 cat&rdquo; (범주)인 경우 count_unique_hll 집계를 사용하여 고유한 범주 수를 추적합니다. 또는 문서의 기능 이름이 시간&rdquo;인 &ldquo;경우 최소 및 최대 집계가 활용됩니다. 다음 코드 조각은 고유 개수 및 최소 집계가 업데이트되는 방법을 보여 줍니다. 이러한 집계를 유지 관리하는 데 사용하는 데이터 구조에 대한 자세한 설명은 다음 섹션을 참조하세요.</p>\n\n<pre class=\"prettyprint\">\ncase AGGREGATE.count_unique_hll:\n    if (aggData === undefined) aggData = metaDoc.aggregates[agg] = new CountUniqueHLLData();\n    aggData.hll = new HyperLogLog(aggData.hll.std_error, murmurhash3_32_gc, aggData.hll.M);\n\n    let oldValue = aggData.value = aggData.hll.count();\n    aggData.hll.count(doc.feature.value); // add entity to hll\n    aggData.value = aggData.hll.count();\n\n    if (aggData.value !== oldValue &amp;&amp; !isUpdated) isUpdated = true;\n    break;\ncase AGGREGATE.min:\n    if (aggData === undefined) aggData = metaDoc.aggregates[agg] = new AggregateData();\n    if (aggData.value === undefined) aggData.value = doc.feature.value;\n    else if (doc.feature.value &lt; aggData.value) {\n        aggData.value = doc.feature.value;\n        if (!isUpdated) isUpdated = true;\n    }\n    break;</pre>\n\n<h2>확률적 데이터 구조</h2>\n\n<p>JavaScript에서 다음 세 가지 확률적 데이터 구조를 구현했으며, 각 구조는 이전 섹션에서 만든 저장 프로시저의 일부로 조건부로 업데이트할 수 있습니다.</p>\n\n<h3>HyperLogLog</h3>\n\n<p>다중 집합의 각 요소에 해시 함수를 적용하고(원래 집합과 동일한 카디널리티를 사용하여 균일하게 분산된 난수의 새 다중 집합 가져오기) 새 집합 <em>n</em>에서 각 숫자의 이진 표현에서 선행 0의 최대 수를 계산하여 다중 집합의 고유 요소 수를 근사화합니다. 예상 카디널리티는 2^<em>n</em> [2]입니다.</p>\n\n<h3>BloomFilter</h3>\n\n<p>요소가 집합의 멤버인지 여부를 테스트합니다. 가양성도 가능하지만 거짓 부정은 가능하지 않습니다. 오히려 블룸 필터는 <em>요소가 집합의</em> 멤버인지 묻는 메시지가 표시될 때 <em>집합에서 반환하거나 집합에 반환하지 않습니다</em> . 블룸 필터에 요소를 추가하려면 요소가 <em>k</em> 해시 함수에 공급되어 <em>k</em> 배열 위치에 도착합니다. 각 위치의 비트는 1로 설정됩니다. 요소가 집합에 있는지 여부를 테스트하기 위해 요소는 <em>k 배열 위치에</em> 도착하기 위해 각 <em>k</em> 해시 함수에 다시 공급됩니다. 비트 중 하나가 0인 경우 요소는 [3] 집합에 없습니다.</p>\n\n<h3>Count-Min 스케치</h3>\n\n<p>이벤트 스트림을 수집하고 집합에 있는 고유 멤버의 빈도를 계산합니다. 스케치는 특정 이벤트 유형의 빈도에 대해 쿼리될 수 있습니다. 블룸 필터와 마찬가지로 이 데이터 구조는 일부 해시 함수를 사용하여 이벤트를 값 &ndash; 에 매핑합니다. 그러나 이러한 해시 함수를 사용하여 이벤트가 데이터 세트 [4]에 있는지 여부 대신 이벤트 빈도를 추적합니다.</p>\n\n<p>위의 각 데이터 구조는 특정 확률로 실제 값의 특정 범위 내에서 예상치를 반환합니다. 이러한 확률은 희생하려는 메모리의 양에 따라 조정이 가능합니다. 다음 코드 조각에서는 eid = 1을 사용하여 학생의 고유 개체 수에 대한 HyperLogLog 근사치를 검색하는 방법을 보여  제공합니다.</p>\n\n<pre class=\"prettyprint\">\nprivate static void OutputResults()\n{\n    var client = new DocumentClient(new Uri(Endpoint), AuthKey);\n    Uri collectionLink = UriFactory.CreateDocumentCollectionUri(DbName, CollectionName);\n\n    string queryText = &quot;select c.aggregates.count_unique_hll[\\&quot;value\\&quot;] from c where c.id = \\&quot;_en=eid.ev=1.fn=obj\\&quot;&quot;;\n    var query = client.CreateDocumentQuery(collectionLink, queryText);\n\n    Console.WriteLine(&quot;Result: {0}&quot;, query.ToList()[0]);\n}</pre>\n\n<h2>결론</h2>\n\n<p>RFM 기능이 긍정적인 영향을 미칠 수 있는 시나리오 범위는 변동 예측을 훨씬 뛰어넘습니다. 여러 번, 다양한 기계 학습 대회 및 고객 시나리오에서 사용될 때 소수의 RFM 기능이 성공한 것으로 입증되었습니다.</p>\n\n<p>RFM의 기능을 DocumentDBs&rsquo; 서버 쪽 프로그래밍 기능과 결합하면 시너지 효과가 발생합니다. 이 게시물에서는 DocumentDB 저장 프로시저를 사용하여 이벤트 모델링 및 기능 데이터 유지 관리를 시작하는 방법을 보여 줍니다. 이제 개발자는 사례별로 추가 기능 메타데이터를 유지 관리하기 위해 <a href=\"https://github.com/Azure-Samples/documentdb-dotnet-rfm\">GitHub</a>&nbsp; 호스트되는 샘플에 기능을 추가할 수 있는 도구를 갖추기를 바랍니다. DocumentDB에서 추천하는 데이터에 대해 다양한 기계 학습 모델을 실험할 수 있는 Azure Machine Learning 이러한 유형의 솔루션을 통합하는 방법을 자세히 설명하는 향후 게시물에 대해 계속 지켜봐 주시기 바랍니다.</p>\n\n<p>DocumentDB의 데이터베이스 스토리지 파티션에서 직접 배송 및 실행할 수 있는 데이터베이스 프로그램 애플리케이션 논리를 작성하는 방법에 대한 자세한 내용은 <a href=\"https://azure.microsoft.com/documentation/articles/documentdb-programming/\">DocumentDB 서버 쪽 프로그래밍( 저장 프로시저, 데이터베이스 트리거 및 UDF</a>)을 참조하세요. 트위터에서 우리를 팔로우하여 최신 DocumentDB 뉴스 및 기능을 최신 상태로 유지하세요 <a href=\"https://twitter.com/DocumentDB\">@DocumentDB</a>.</p>\n\n<p>마지막으로, 추가 ML 지원에 대한 문의 및 기계 학습을 위해 DocumentDB를 사용하는 방법을&rsquo; 보여 주시려면 아래 의견을 보내주세요<a href=\"mailto:askdocdb@microsoft.com\">askdocdb@microsoft.com</a>.</p>\n\n<h2>참조</h2>\n\n<p>[1] 오쉬리, 갈. &ldquo;RFM: 이벤트 모델링에 대한 간단하고 강력한 접근 방식입니다.&rdquo; <i>Cortana 인텔리전스 및 Machine Learning 블로그</i>(2016). <a href=\"https://blogs.technet.microsoft.com/machinelearning/2016/05/31/rfm-a-simple-and-powerful-approach-to-event-modeling/\">https://blogs.technet.microsoft.com/machinelearning/2016/05/31/rfm-a-simple-and-powerful-approach-to-event-modeling/</a></p>\n\n<p>[2] <a href=\"https://gist.github.com/terrancesnyder/3398489\">https://gist.github.com/terrancesnyder/3398489</a>, <a href=\"https://stackoverflow.com/questions/5990713/loglog-and-hyperloglog-algorithms-for-counting-of-large-cardinalities\">https://stackoverflow.com/questions/5990713/loglog-and-hyperloglog-algorithms-for-counting-of-large-cardinalities</a></p>\n\n<p>[3] <a href=\"https://github.com/jasondavies/bloomfilter.js\">https://github.com/jasondavies/bloomfilter.js</a>, Copyright &copy; 2011, Jason Davies</p>\n\n<p>[4] <a href=\"https://github.com/mikolalysenko/count-min-sketch\">https://github.com/mikolalysenko/count-min-sketch</a>, MIT 라이선스(MIT), Copyright &copy; 2013 Mikola Lysenko</p>"
