### YamlMime:Yaml
ms.openlocfilehash: 680f54fcfae2653c5ab5fb7100ded35c31c17b02
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139898413"
Slug: columnstore-support-in-standard-tier-azure-sql-databases
Title: 표준 계층 Azure SQL Databases의 Columnstore 지원
Summary: S3 이상 가격 책정 계층의 표준 데이터베이스에 대한 columnstore 인덱스 기능의 일반 공급에 대해 발표하게 되어 기쁘게 생각합니다. 이러한 기능을 통해 많은 새롭고 가치 있는 기능을 사용할 수 있습니다...
Content: >-
  <p>S3 이상 가격 책정 계층, 100 eDTU 및 더 큰 탄력적 풀 및 모든 vCore 기반 데이터베이스(범용 및 중요 비즈니스용)의 표준 데이터베이스에 대한 클러스터형 및 비클러스터형 Columnstore 인덱스의 일반 공급에 대해 발표하게 되어 기쁘게 생각합니다. 이러한 기능을 사용하면 다음과 같은 다양한 새롭고 유용한 시나리오를 사용할 수 있습니다.</p>


  <ul>
      <li>테스트 목적으로 Premium 계층 데이터베이스에 대한 비용을 지불할 필요 없이 columnstore 기반 애플리케이션에 대한 기능 개발/테스트입니다. (물론 성능 테스트는 항상 대상 성능 구성에서 수행해야 합니다.)</li>
      <li>Premium 계층 데이터베이스 요구 사항에 있는 중요 업무용 성능 및 가용성 요구 사항이 없는 columnstore 기반 스토리지를 사용하여 애플리케이션을 배포합니다.</li>
      <li>이제 애플리케이션 공급업체는 columnstore 기능을 활용하는 애플리케이션을 개발하고 표준 및 Premium 성능 계층 모두에 배포할 수 있습니다.</li>
  </ul>


  <h2>Columnstore의 이점</h2>


  <p>Columnstore 인덱스는 수백만 및 수십억 개의 데이터 행에서 검사 및 집계를 수행하는 쿼리에 매우 효율적이도록 설계되었습니다. 근본적으로 다른 구조로, 행이 아닌 열별로 데이터를 물리적으로 그룹화합니다. OLTP 스타일 워크로드에서 쿼리는 일반적으로 한 번에 하나 또는 몇 개의 행에 액세스하므로 기존 인덱스 구조가 가장 효율적인 액세스 경로가 됩니다. 분석 쿼리의 경우 열별로 데이터를 구성한다는 것은 쿼리에 관련된 열에 대한 데이터만 읽어야 하며 다른 열은 메모리로 전혀 가져올 필요가 없다는 것을 의미합니다. 또한 약 100만 행(&ldquo;행 그룹)의 그룹이 압축되고 행 그룹에&rdquo; 대한 각 열의 값 범위에 대한 메타데이터가 유지됩니다. 따라서 쿼리를 충족하는 데이터가 포함된 행이 없다는 것을 알고 있으면 전체 행 그룹을 건너뛸 수 있습니다. 자세한 내용은 <a href="https://docs.microsoft.com/en-us/sql/relational-databases/indexes/columnstore-indexes-overview" target="_blank">columnstore 인덱스 설명서 페이지를</a> 참조하세요.</p>


  <p>마지막으로, 각 컨테이너의 데이터는 모두 동일한 열에서 온 데이터이므로 값이 매우 비슷한 경향이 있으며 물론 데이터 형식에서는 동일합니다. 이렇게 하면 매우 압축할 수 있습니다. 일반적으로 columnstore의 데이터 세트에서 공간의 90%를 압축할 수 있습니다.</p>


  <p>이 모든 것은 더 적은 공간에 더 많은 데이터를 저장하고 쿼리를 충족하기 위해 디스크에서 메모리로 훨씬 적은 데이터를 이동할 수 있음을 의미합니다. 집계를 수행할 때 데이터의 일괄 처리를 처리하는 기능과 결합하면 매우 인상적인 성능 향상이 제공됩니다. 고객은 columnstore 처리에 적합한 쿼리에 대한 실제 프로덕션 워크로드에서 100배 이상의 순서로 이익을 얻었습니다.</p>


  <h2>질문 및 답변</h2>


  <p><strong>Q. 이제 모든 표준 성능 수준이 지원되는가요?</strong></p>


  <p>A. columnstore 인덱스를 활용하는 쿼리는 성능을 향상하기 위해 최소 메모리 공간을 갖습니다. 최적의 환경을 보장하려면 S3 이상에서 제공된 메모리 또는 eDTU가 100개 이상인 탄력적 풀이 필요합니다.&nbsp; 모든 vCore 기반 옵션이 지원됩니다.</p>


  <p><strong>Q. 데이터베이스에 columnstore를 만든 다음 S3 아래로 축소하면 어떻게 됩니까?</strong></p>


  <p>A. 크기 조정 작업은 성공하지만 데이터베이스가 쿼리를 실행할 때 columnstore는 선택되지 않습니다.&nbsp; 인덱스가 테이블의 데이터 변경 내용을 따라가도록 업데이트된다는 예외를 제외하고 휴면 상태로 유지됩니다. 데이터베이스를 다시 S3 이상으로 확장하면 columnstore 인덱스가 자동으로 다시 사용되기 시작합니다. 이는 테이블에 클러스터형 columnstore 인덱스만 있고 S3 이하로 축소되는 경우를 의미합니다. 클러스터형 columnstore 인덱스는 데이터를 검색하는 데 사용할 수&rsquo; 없으므로 데이터베이스가 다시 확장될 때까지 데이터에 액세스할 수 없습니다.</p>


  <p><strong>Q. 이 기능을 사용하도록 설정하려면 어떻게 해야 하나요?</strong></p>


  <p>A. S3 성능 수준 이상의 데이터베이스의 경우 아무 작업도 필요하지 않습니다. 이제 Columnstore 인덱스 만들기는 다른 작업 없이 성공합니다.</p>
