### YamlMime:Yaml
ms.openlocfilehash: 3ad38443a621e386ab01a3bb8699cbac5ee5ab84
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139907512"
Slug: understanding-serverless-cold-start
Title: '서버리스 콜드 시작 이해 '
Summary: "\"콜드 스타트\"는 서버리스 아키텍처에 대한 큰 논의 지점이며 Azure Functions의 많은 사용자에게 모호함의 지점입니다. 이 게시물의 목표는 콜드 스타트가 무엇인지, 왜 발생하는지, 그리고 그 주변의 솔루션을 설계하는 방법을 이해하는 데 도움이 되는 것입니다. "
Content: >-
  <p><strong>2019년 6월 업데이트: </strong> 이제 동적 크기 조정 함수에 대한 콜드 시작 완화를 Premium 계획에서 사용할 수 있습니다. <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-premium-plan#pre-warmed-instances">여기에서 자세히 알아보세요</a>.</p>


  <p>콜드 스타트는 서버리스 아키텍처에 대한 큰 논의 지점이며 Azure Functions의 많은 사용자에게 모호함의 지점입니다. 이 게시물의 목표는 콜드 스타트가 무엇인지, 왜 발생하는지, 그리고 그 주변의 솔루션을 설계하는 방법을 이해하는 데 도움이 되는 것입니다. 이 설명을&rsquo; 제공하기 위해 Azure Functions가 백그라운드에서 작동하는 방식에 대한 몇 가지 기술적 세부 사항을 자세히 살펴보겠습니다.</p>


  <h2>소비 계획 및 전용 계획 비교</h2>


  <p>Azure Functions는 소비 및 전용의 두 가지 주요 버전으로 제공됩니다. 둘 사이의 차이는 중요합니다. 둘 중 하나를 선택하는 것은 애플리케이션의 동작뿐만 아니라 청구 방법&rsquo;도 결정합니다. 소비 계획은 서버리스&rdquo; 모델이며, 코드는 &ldquo;이벤트에 반응하고, 표시되는 모든 부하&rsquo;를 충족하도록 효과적으로 스케일 아웃하고, 코드가 실행되지 않으면&rsquo; 규모를 축소하고&rsquo;, 사용하는 항목에 대해서만 요금이 청구됩니다. 게다가, 이 모든 것은 Microsoft Azure 백그라운드에서 무엇을하고 있는지에 대해 생각하지 않고 발생합니다. 반면에 전용 계획에는 가상 머신의 임대 제어가 포함됩니다. 이 컨트롤은 해당 컴퓨터에서 원하는 대로 수행할 수 있음을 의미합니다. 항상&rsquo; 사용할 수 있으며 24/7을 실행해야 하는 함수가 있는 경우 재정적으로 더 합리적일 수 있습니다. &rsquo;궁금하고 더 자세한 설명을 원한다면 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-scale">설명서를</a> 확인하세요.</p>


  <h2>콜드 스타트란?</h2>


  <p>대체로 콜드 스타트는 사용되지 않은&rsquo; 애플리케이션을 시작하는 데 더 오래 걸리는 현상을 설명하는 데 사용되는 용어입니다. Azure Functions의 컨텍스트에서 대기 시간은 사용자가 함수를 기다려야 하는 총 시간입니다. 이벤트가 함수를 시작하는 시점부터 해당 함수가 이벤트에 응답하는 작업을 완료할 때까지입니다. 더 정확하게 말하면, 콜드 스타트는 최근에 호출되지 않은&rsquo; Functions의 대기 시간이 증가하는 것입니다. 전용 계획에서 Azure Functions를 사용하는 경우 Functions 호스트는 항상 실행되므로 콜드 시작은 실제로 문제가 되지 않습니다&rsquo;. 따라서 범위는 서버리스 소비 모델을 실행하는 Functions로 좁혀집니다. 더&rsquo; 깊이 가자.</p>


  <h2>함수를 작성하면 어떻게 됩니까?</h2>


  <p>&rsquo;첫 번째 함수를 작성한다고 가정합니다. Youve&rsquo;는 함수 앱을 프로비전하고, 템플릿 중 하나를 기반으로 함수를 만들고, 비즈니스 요구에 맞게 수정하고 있습니다. 이제 저장하고 지정된 트리거가 함수를 시작할 때까지 기다립니다. 나중에 함수가 트리거됩니다. 이 프로세스가 시작되면 아직 아무것도 실행하지 않았기&rsquo; 때문에 모든 코드와 구성이 Azure Storage 파일로만 존재합니다. 코드를 실행하기 위해 계속 수행해야 하는 작업을 광범위하게 일시 중지하고 생각해 보겠습니다&rsquo;.</p>


  <ol>
   <li>
   <p>Azure는 용량이 있는 서버에 애플리케이션을 할당해야 합니다.</p>
   </li>
  </ol>


  <ol start="2">
   <li>
   <p>그런 다음, Functions 런타임이 해당 서버에서 시작해야 합니다.</p>
   </li>
  </ol>


  <ol start="3">
   <li>
   <p>그런 다음 코드를 실행해야 합니다.</p>
   </li>
  </ol>


  <p>1단계와 2단계를 제대로 수행하면 시간이 걸릴 수 있으며, 서버를 회전시키고 구성하는 데 시간이 걸립니다. 사용자를 위해 이 환경을 개선하려면 매번&rsquo; 처음부터 시작하는 대신 서버 풀을 따뜻하게 유지하고 해당 풀에서 작업자를 끌어들이는 방법을 구현했습니다. 즉, 언제든지 Functions 런타임 가동 및 실행으로 미리 구성된 유휴 작업자가 있습니다. 이러한 &ldquo;사전 준비 된 사이트를&rdquo; 만드는 것은 우리에게 우리의 차가운 시작 시간에 측정 가능한 개선을 주었다. 이제 상황이 3~4배 더 빠릅니다. &rsquo;이제 다시 돌아가서 리소스가 아직 할당되지 않은&rsquo; 경우 함수 실행을 트리거할 때 발생하는 일에 대한 자세한 보기를 살펴보겠습니다.</p>


  <h2>콜드 스타트 중에 발생하는 작업</h2>


  <p style="text-align: center;"><img src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4cca2941-3df2-49aa-bb73-495dc64b2ead.jpeg"></p>


  <ol>
   <li>
   <p>Azure는 미리 구성된 서버를 웜 작업자 풀에서 앱에 할당합니다. 이 서버에는 이미 Functions 런타임이 실행되고 있지만 지정되지 않았습니다.</p>
   </li>
   <li>이 작업자는 앱과 관련된 방식으로 Functions 런타임을 구성하여 특수화됩니다. 이 전문화를 수행하는 몇 가지 작업은 다음과 같습니다. <ul>
    <li>Azure Functions 인프라는 할당된 작업자&rsquo;에 Azure Files 콘텐츠를 탑재합니다.</li>
    <li>
    <p>함수 앱과 관련된 앱 설정이 작업자에 적용됩니다.</p>
    </li>
   </ul>
   </li>
   <li>Functions 런타임이 다시 설정되고 필요한 확장이 작업자에 로드됩니다. 로드할 확장을 파악하기 위해 런타임은 함수 앱에서 함수의 function.json 파일을 읽습니다. 예를 들어 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/durable-functions-overview">지속성 함수</a>를 사용하거나 입력 또는 출력 바인딩이 있는 경우 이 문제가 발생&rsquo;합니다.</li>
   <li>함수 자체는 언어 공급자에 의해 메모리에 로드됩니다. 이 작업은 애플리케이션의 크기에 따라 다양한 시간이 소요됩니다.</li>
   <li>
   <p>코드가 실행됩니다.</p>
   </li>
  </ol>


  <p>&rsquo;최근에 함수를 실행한 경우 1-4단계가 이미 발생했으며 리소스가 이미 할당되었으며 사이트가 따뜻합니다. 당신이 상상할 수 있듯이,이 시나리오에서 상황이 상당히 빠릅니다. 약 20분 동안 비활성 상태인 후 리소스의 할당을 취소합니다. 그 후에는 다음 호출이 콜드 시작되고 이 전체 프로세스가 다시 수행됩니다.위에서 설명한 것입니다.</p>


  <h2>팀이 더 이상 개선하고 있습니까?</h2>


  <p>그렇습니다! 이 게시물은 단순히 특정 시점(2018년 2월) 작업의 작동 방식을 분석한 것이며, 많은 세부 사항이 변경될 수 있습니다. 증거로, 우리는 최근에 런타임에 대한 업데이트를 발표했으며 일반 공급 언어를&rsquo; 위해 콜드 시작 시간에 추가로 50 % 개선되었습니다. 나는 여기에 슈퍼 깊은 이동하지 않습니다&rsquo;,하지만이 업데이트는 우리의 네이티브 이미지 생성의 회귀를 수정. 자세한 내용은 <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank">NGEN</a> 을 참조하거나<a href="https://github.com/Azure/azure-webjobs-sdk-script/releases/tag/v1.0.11490" target="_blank"> 릴리스</a> 자체를 확인하세요. 완전히 오픈 소스가 제공됩니다.</p>


  <h2>긴 콜드 시작을 방지하기 위해 코드를 개선하려면 어떻게 해야 하나요?</h2>


  <p>콜드 스타트를 유발하기 위해 백그라운드에서 발생하는 일에&rsquo; 대한 기준이 이해되었으므로 이를 방지하기 위해 솔루션을 설계하는 방법을 해결할 수 있습니다.</p>


  <p>언어: 무엇보다도 C#, F#, JavaScript와 같은 일반 공급 언어를 사용합니다. 대부분의 실험 언어는 완전히 지원되지 않고&rsquo; 최적화되어 실제로 모든 실행에서 새로운 프로세스를 실행하여 대기 시간에 큰 영향을 줍니다. &rsquo;또한 2.0 런타임에서 실행되는 모든 언어는 미리 보기 상태이며 완전히 최적화되지 않았다는&rsquo; 점에 유의해야 합니다. 이러한 언어는 나중에 더 잘 수행될 것으로 기대하지만 지금은 위에서 언급한 GA 언어를 고수합니다. 자세한 내용은 <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions" target="_blank">설명서를 참조하세요</a>.</p>


  <h2>경량 코드 작성</h2>


  <p>종속성: 코드를 배포하면 종속성이 애플리케이션에 파일로 추가됩니다. 위의 4단계에서 설명한 것처럼 앱에 필요한 모든 코드는 결국 메모리에 로드되어 더 큰 애플리케이션에서 더 오래 걸립니다. 따라서 많은 종속성이&rsquo; 있는 경우 Azure Files의 I/O 작업에 대한 시간이 늘어나고 더 큰 앱을 메모리에 로드하는 데 필요한 시간이 길어지므로 콜드 시작 시간이 길어질 수 있습니다. 이것은 우리가 JavaScript에서 함수를 작성하는 사람들을 위해 항상 볼 수있는 것입니다, npm 트리는 거대 얻을 수 있습니다. 이렇게 하면 앱 크기가 증가할 뿐만 아니라 Azure Files에서 처리해야 하는 파일 수도 증가하므로 속도가 더 느려질 수 있습니다. 특히&rsquo; 이 시나리오에서는 도움이 되는 도구를 릴리스했습니다. <a href="https://github.com/Azure/azure-functions-pack/releases/tag/1.0.0" target="_blank">Funcpack</a>을 확인하여 자세히 알아보세요!</p>


  <p>효율적인 코드: 때로는 더 효율적인 코드를 작성하기만 하면 됩니다. 여기서 유의해야 할 몇 가지 방법이 있습니다. 먼저 가능한 한 많은 처리를 비동기 처리해 보세요. 코드가 완료되지&rsquo; 않도록 차단하는 중량급 동기 호출이 있는 경우 함수가 잘 수행되지 않습니다. 이러한 맥락에서 코드가 시작되기 전에 수행해야 하는 작업의 양을 최소화하고 많은 CPU를 사용하는 코드를 피합니다. 이에 대해 우려하는 경우&rsquo; <a href="https://azure.microsoft.com/en-us/services/application-insights/" target="_blank">애플리케이션 Insights</a> 사용해보는 것이 좋습니다. 이&rsquo; 도구는 환상적인 모니터링 도구이며 플랫폼 속도 저하로부터 애플리케이션 속도 저하를 격리하는 데 도움이 될 수 있습니다.</p>


  <h2>콜드 스타트를 완전히 피하십시오.</h2>


  <p>전용 모드: 앞에서 설명한 대로 App Service 계획에서 Functions를 실행하면 VM에서 발생하는 작업을 제어하므로 이러한 문제가 완화됩니다. 이는 약간 더 비싸고 서버리스가 아니지만&rsquo; 솔루션에 개별 호출 시 대기 시간이 짧은 경우 전용 모드를 사용하는 것이 좋습니다.</p>


  <h2>피드백</h2>


  <p>피드백은 항상 환영합니다. 다른 이유로 제품 팀에 직접 연락하거나 의견을 알려 주시려면 Twitter 또는 GitHub 참여하세요!</p>
