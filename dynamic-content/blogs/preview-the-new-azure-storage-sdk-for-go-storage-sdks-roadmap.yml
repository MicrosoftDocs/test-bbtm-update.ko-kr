### YamlMime:Yaml
ms.openlocfilehash: 7edd0a3c82e80fcb2a9ade51acf319ecab2ff693
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139897854"
Slug: preview-the-new-azure-storage-sdk-for-go-storage-sdks-roadmap
Title: 새 Azure Storage SDK for Go & Storage SDK 로드맵 미리 보기
Summary: Blob Storage 지원을 통해 차세대 Azure Storage Go용 SDK를 소개합니다.
Content: "<p>오늘 제공되는 <a href=\"https://godoc.org/github.com/Azure/azure-storage-blob-go/2016-05-31/azblob\" target=\"_blank\">설명서와 예제</a>를 통해 새롭게 디자인된 <a href=\"https://github.com/azure/azure-storage-blob-go\">Azure Storage Go용 SDK</a>를 발표하게 되어 기쁩니다. 이 새로운 SDK는 Azure Storage SDK에 대한 차세대 디자인 철학을 따르도록 재설계되었으며 OpenAPI 사양의 오픈 소스 코드 생성기인 <a href=\"https://github.com/Azure/autorest\">AutoRest</a>에서 생성된 코드를 기반으로 합니다.</p>\n\n<p>Azure Storage 클라이언트 라이브러리는 지난 몇 년 동안 크게 발전하여 C++에서 JavaScript까지 다양한 개발 언어를 지원했습니다. 모든 플랫폼 및 프로그래밍 언어를 지원하기 위해 AutoRest를 사용하여 더 많은 언어로 새로운 기능 제공을 가속화하기로 결정했습니다. Go용 Storage SDK에서 AutoRest는 프로토콜 계층이라고 하는 것을 생성합니다. 새 SDK는 내부적으로 이를 사용하여 Storage 서비스와 통신합니다.</p>\n\n<p>현재 새 Azure Storage SDK for Go는 Blob Storage만 지원하지만 향후 파일 및 큐 지원을 릴리스할 예정입니다. 이러한 모든 서비스는 별도로 패키지되며, 최근에 <a href=\"https://github.com/Azure/azure-storage-python\">Python용 Azure Storage SDK</a>를 사용하여 시작했습니다. 나중에 모든 Storage 클라이언트 라이브러리에 대한 분할 패키지가 표시될 것으로 예상됩니다. 이렇게 하면 Storage 서비스 중 하나만 사용하는 경우 라이브러리 공간이 크게 줄어듭니다.</p>\n\n<h2>새로운 기능</h2>\n\n<ul>\n <li>계층화된 SDK 아키텍처: 하위 수준 및 상위 수준 API</li>\n <li>유연성을 높이기 위해 서비스당 하나의 SDK <a href=\"https://github.com/Azure/azure-storage-blob-go/tree/master/2016-05-31/\">패키지</a> (REST API) 버전이 있습니다. 이전 REST API 버전을 사용하도록 선택하고 애플리케이션을 중단하지 않도록 선택할 수 있습니다. 또한 여러 패키지를 나란히 로드할 수 있습니다.</li>\n <li>AutoRest에서 생성된 코드 기반</li>\n <li>공간을 줄이기 위해 Blob, 파일 및 큐 서비스에 대한 패키지 분할</li>\n <li>HTTP 요청 및 응답을 변경하기 위한 새로운 확장 가능한 미들웨어 <a href=\"https://github.com/azure/azure-pipeline-go\">파이프라인</a></li>\n <li>업로드 및 다운로드 작업에 대한 진행률 알림</li>\n</ul>\n\n<h2>계층화된 SDK 아키텍처</h2>\n\n<p>새로운 Storage SDK for Go는 프로그래밍 환경을 간소화하고 디버깅 기능을 향상시키는 3개의 계층으로 구성됩니다. 첫 번째 계층은 프라이빗 클래스 및 함수로 구성된 자동 생성된 계층입니다. 나중에 <a href=\"https://github.com/Azure/autorest\">AutoRest</a> 를 사용하여 이 계층을 생성할 수 있습니다. 기대해 주세요.</p>\n\n<p>두 번째 계층은 Azure Storage REST API 작업에 일대일로 매핑되는 상태 비저장 씬 래퍼입니다. 예를 들어 BlobURL 개체는 <a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/put-blob\">PutBlob</a>, <a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/put-block\">PutBlock 및 PutBlockList</a>와 같은 <a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-list\"></a>메서드를 제공합니다. 이러한 API 중 하나를 호출하면 첫 번째 REST 호출이 실패할 경우 단일 REST API 요청과 여러 번 다시 시도됩니다.</p>\n\n<p>세 번째 계층은 편의를 위해 높은 수준의 추상화로 구성됩니다. 한 가지 예는 업로드되는 스트림의 크기에 따라 여러 PutBlock 작업을 호출하는 UploadBlockBlobFromStream입니다.</p>\n\n<p><img alt=\"\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/74d05caf-0e82-471d-a7b6-685b84435076.png\" style=\"margin-right: auto; margin-left: auto; float: none; display: block;\"></p>\n\n<h2>Hello World</h2>\n\n<p>다음은 새 Storage SDK for Go를 사용하는 Hello World 예제입니다. GitHub <a href=\"https://github.com/Azure/azure-storage-blob-go/blob/master/2016-05-31/azblob/zt_examples_test.go\">전체 예제</a>를 확인하세요.</p>\n\n<pre class=\"prettyprint\">\n// From the Azure portal, get your Storage account&#39;s name and key and set environment variables.\naccountName, accountKey := os.Getenv(&quot;ACCOUNT_NAME&quot;), os.Getenv(&quot;ACCOUNT_KEY&quot;)\n\n// Use your Storage account&#39;s name and key to create a credential object.\n credential := azblob.NewSharedKeyCredential(accountName, accountKey)\n\n// Create a request pipeline that is used to process HTTP(S) requests and responses.\np := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n\n // Create an ServiceURL object that wraps the service URL and a request pipeline.\n u, _ := url.Parse(fmt.Sprintf(&quot;https://%s.blob.core.windows.net&quot;, accountName))\nserviceURL := azblob.NewServiceURL(*u, p)\n\n // All HTTP operations allow you to specify a Go context.Context object to\n// control cancellation/timeout.\nctx := context.Background() // This example uses a never-expiring context.\n\n// Let&#39;s create a container\nfmt.Println(&quot;Creating a container named &#39;mycontainer&#39;&quot;)\n containerURL := serviceURL.NewContainerURL(&quot;mycontainer&quot;) \n _, err := containerURL.Create(ctx, azblob.Metadata{}, azblob.PublicAccessNone)\nif err != nil { // An error occurred\n   if serr, ok := err.(azblob.StorageError); ok { // This error is a Service-specific\n      switch serr.ServiceCode() { // Compare serviceCode to ServiceCodeXxx constants\n         case azblob.ServiceCodeContainerAlreadyExists:\n            fmt.Println(&quot;Received 409. Container already exists&quot;)\n            break\n         default:\n            // Handle other errors ...\n            log.Fatal(err)\n      }\n   }\n}\n\n// Create a URL that references a to-be-created blob in your \n// Azure Storage account&#39;s container.\nblobURL := containerURL.NewBlockBlobURL(&quot;HelloWorld.txt&quot;)\n\n// Create the blob with string (plain text) content.\ndata := &quot;Hello World!&quot;\nputResponse, err := blobURL.PutBlob(ctx, strings.NewReader(data), \n   azblob.BlobHTTPHeaders{ContentType: &quot;text/plain&quot;}, azblob.Metadata{}, \n   azblob.BlobAccessConditions{})\nif err != nil {\n   log.Fatal(err)\n}\nfmt.Println(&quot;Etag is &quot; + putResponse.ETag())\n\n</pre>\n\n<h2>새 파이프라인 패키지를 사용하여 진행률 보고</h2>\n\n<p>모든 Storage 클라이언트 라이브러리에 대해 자주 묻는 기능 중 하나는 전송 진행률을 바이트 단위로 추적하는 기능이었습니다. 이제 Go용 Storage SDK에서 사용할 수 있습니다. 다음은 예제입니다.</p>\n\n<pre class=\"prettyprint\">\n// From the Azure portal, get your Storage account&#39;s name and key and set environment variables.\naccountName, accountKey := os.Getenv(&quot;ACCOUNT_NAME&quot;), os.Getenv(&quot;ACCOUNT_KEY&quot;)\n\n// Create a request pipeline using your Storage account&#39;s name and account key.\ncredential := azblob.NewSharedKeyCredential(accountName, accountKey)\np := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n\n// From the Azure portal, get your Storage account blob service URL endpoint.\ncURL, _ := url.Parse(\n   fmt.Sprintf(&quot;https://%s.blob.core.windows.net/mycontainer&quot;, accountName))\n\n// Create a ContainerURL object that wraps the container URL and a request \n// pipeline to make requests.\ncontainerURL := azblob.NewContainerURL(*cURL, p)\n\nctx := context.Background() // This example uses a never-expiring context\n// Here&#39;s how to create a blob with HTTP headers and metadata (I&#39;m using \n// the same metadata that was put on the container):\nblobURL := containerURL.NewBlockBlobURL(&quot;Data.bin&quot;)\n\n// requestBody is the stream of data to write\nrequestBody := strings.NewReader(&quot;Some text to write&quot;)\n\n// Wrap the request body in a RequestBodyProgress and pass a callback function \n// for progress reporting.\n_, err := blobURL.PutBlob(ctx,\n   pipeline.NewRequestBodyProgress(requestBody,\n      func(bytesTransferred int64) {\n         fmt.Printf(&quot;Wrote %d of %d bytes.\\n&quot;, bytesTransferred, requestBody.Len())\n      }),\n   azblob.BlobHTTPHeaders{\n      ContentType: &quot;text/html; charset=utf-8&quot;,\n             ContentDisposition: &quot;attachment&quot;,\n   }, azblob.Metadata{}, azblob.BlobAccessConditions{})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Here&#39;s how to read the blob&#39;s data with progress reporting:\nget, err := blobURL.GetBlob(ctx, azblob.BlobRange{}, azblob.BlobAccessConditions{}, false)\nif err != nil {\n    log.Fatal(err)\n}\n\n// Wrap the response body in a ResponseBodyProgress and pass a callback function \n// for progress reporting.\nresponseBody := pipeline.NewResponseBodyProgress(get.Body(), \n   func(bytesTransferred int64) {\n      fmt.Printf(&quot;Read %d of %d bytes\\n.&quot;, bytesTransferred, get.ContentLength())\n   })\ndownloadedData := &amp;bytes.Buffer{}\ndownloadedData.ReadFrom(responseBody)\n// The downloaded blob data is in downloadData&#39;s buffer\n</pre>\n\n<h2>다음&#39;?</h2>\n\n<h3>go용 SDK Storage 로드맵:</h3>\n\n<ul>\n <li>일반 공급</li>\n <li>파일 및 큐 패키지</li>\n <li>보관 및 Blob 계층과 같은 새로운 Storage 기능 출시 예정</li>\n <li>더 높은 처리량을 위한 병렬 파일 전송과 같은 편리한 기능</li>\n</ul>\n\n<h3>Storage SDK의 나머지 부분에 대한 로드맵:</h3>\n\n<ul>\n <li>.NET 및 Java용 Blob, 파일 및 큐 서비스 및 기타 모든 Storage 클라이언트 라이브러리에 대한 패키지 분할</li>\n <li>AutoRest에 대한 OpenAPI(Swagger라고도 하는) 사양</li>\n <li>반응형 프로그래밍 모델을 사용하는 완전히 새로운 비동기 Java 클라이언트 라이브러리</li>\n</ul>\n\n<h2>개발자 설문 조사 &amp; 피드백</h2>\n\n<p><a href=\"https://aka.ms/AzureStorageDevSurvey\">5개 질문 설문 조사를</a> 통해 우리가&rsquo; 어떻게 하는지 알려주세요. 요청한 기능에&rsquo; 대해 적극적으로 작업하고 있으며, 연례 설문 조사는 로드맵에 영향을 줄 수 있는 가장 쉬운 방법 중 하나입니다!</p>\n\n<p>세르칸 굴러와 제프리 리히터</p>"
