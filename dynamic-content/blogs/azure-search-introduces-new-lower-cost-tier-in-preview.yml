### YamlMime:Yaml
ms.openlocfilehash: 9e5e859796aa9ad794d121704c49dd3a31a0a652
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139901764"
Slug: azure-search-introduces-new-lower-cost-tier-in-preview
Title: Azure Search는 미리 보기에서 새로운 저렴한 비용 계층을 도입합니다.
Summary: 고객 피드백에 따라 Azure Search가 기존 무료 계층과 표준 계층 간의 격차를 메우는 새로운 저렴한 기본 계층을 미리 보기에 도입했다고 발표하게 되어 기쁩니다.
Content: >-
  <p>Azure&rsquo; Search에 대한 새로운 기본 계층을 발표하게 되어 기쁩니다. 무료 계층과 표준 계층 간에 중간 지점이 없는 Azure Search에 대한 <a href="https://feedback.azure.com/forums/263029-azure-search/suggestions/6328668-provide-a-startup-friendly-billing-model">많은 피드백을</a> 받았습니다. 이 새로운 기본 계층은 이 격차를 해결하는 것을 목표로 합니다.</p>


  <p>기본은 표준의 프로덕션 클래스 특성이 필요하지만 용량 요구 사항이 낮은 경우에 적합합니다.</p>


  <p>기본 비용은 월 $75(참조로 미국 가격 책정 사용)이며 공개&rsquo; 미리 보기 중에는 검색 단위당 월 $37.50에 50% 할인된 가격으로 제공합니다. 자세한 내용 및 지역별 가격 책정은 <a href="https://azure.microsoft.com/en-us/pricing/details/search/">가격 책정 페이지를</a> 확인하세요.</p>


  <h2>무료, 기본 및 표준 비교</h2>


  <p>다음은&rsquo; 각 서비스 계층의 주요 측면을 요약한 표입니다. 요약하면 Basic을 더 작은 버전의 표준으로 생각할 수 있습니다. 무료는 리소스 격리를 보장하지 않고&rsquo; SLA 옵션을 제공하지 않으며&rsquo; 구독당 하나만 가질 수 있다는 측면에서 다릅니다. 이러한 이유로 무료는 프로덕션 워크로드에 적합하지 않습니다.</p>


  <table border="0" cellpadding="0" cellspacing="0">
      <tbody>
          <tr>
              <td valign="top" width="120">
              <p><a><b><font color="#000000">서비스 계층</font></b></a></p>
              </td>
              <td valign="top" width="126">
              <p><b>Free</b></p>
              </td>
              <td valign="top" width="126">
              <p><b>기본</b></p>
              </td>
              <td valign="top" width="156">
              <p><b>표준 S1</b></p>
              </td>
              <td valign="top" width="187">
              <p><b>표준 S2***</b></p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>가용성 SLA</b></p>
              </td>
              <td valign="top" width="126">
              <p>예</p>
              </td>
              <td valign="top" width="126">
              <p>예*</p>
              </td>
              <td valign="top" width="156">
              <p>예*</p>
              </td>
              <td valign="top" width="187">
              <p>예*</p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>최대 문서</b></p>
              </td>
              <td valign="top" width="126">
              <p>10000</p>
              </td>
              <td valign="top" width="126">
              <p>1백만</p>
              </td>
              <td valign="top" width="156">
              <p>1억 8천만</p>

              <p>(1,500만/파티션)</p>
              </td>
              <td valign="top" width="187">
              <p>&gt; 1억 8천만 명</p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>최대 파티션</b></p>
              </td>
              <td valign="top" width="126">
              <p>해당 없음</p>
              </td>
              <td valign="top" width="126">
              <p>1</p>
              </td>
              <td valign="top" width="156">
              <p>12</p>
              </td>
              <td valign="top" width="187">
              <p>12</p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>최대 복제본</b></p>
              </td>
              <td valign="top" width="126">
              <p>해당 없음</p>
              </td>
              <td valign="top" width="126">
              <p>3</p>
              </td>
              <td valign="top" width="156">
              <p>12</p>
              </td>
              <td valign="top" width="187">
              <p>12</p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>최대 스토리지</b></p>
              </td>
              <td valign="top" width="126">
              <p>50MB</p>
              </td>
              <td valign="top" width="126">
              <p>2GB</p>
              </td>
              <td valign="top" width="156">
              <p>300GB</p>

              <p>(25GB/파티션)</p>
              </td>
              <td valign="top" width="187">
              <p>&gt;서비스당 300GB</p>
              </td>
          </tr>
          <tr>
              <td valign="top" width="120">
              <p><b>구독당 최대 단위</b></p>
              </td>
              <td valign="top" width="126">
              <p>1</p>
              </td>
              <td valign="top" width="126">
              <p>15**</p>
              </td>
              <td valign="top" width="156">
              <p>15**</p>
              </td>
              <td valign="top" width="187">
              <p>15**</p>
              </td>
          </tr>
      </tbody>
  </table>


  <p>* 읽기-SLA에 대한 최소 2개의 복제본, 읽기-쓰기-SLA용 복제본 3개<br />

  ** Azure 지원을 호출하여 늘릴 수 있음<br />

  Azure 지원을 호출하여 S2를 프로비전할 수 있습니다.</p>


  <h2>성능: 예상할 사항</h2>


  <p>Azure Search&rsquo;의 인덱스 스키마, 검색 쿼리 및 기타 옵션의 변형을 감안할 때 일반 성능 번호와 같은 것은 없습니다. 즉, 다음은 자주 사용하는 테스트 워크로드의 Basic에 대한 몇 가지 샘플 번호입니다. 검색 가능하고 필터링 가능하며 패싯 가능한 필드가 혼합된 9개 필드 인덱스를 사용했습니다. 각 문서의 크기는 약 1KB입니다.</p>


  <p>단일 기본 검색 단위와 좋은 네트워크 연결을 사용했습니다. 결과:</p>


  <ul>
      <li><b>대량 인덱싱</b>: 서비스에서 분당 최대 1,5000개의 문서를 1000개 문서 일괄 처리로 인덱싱할 수 있었습니다. 이 작업을 열심히 푸시하면 쿼리 속도가 느려지지만 이 속도로 한 시간 동안 100만 개의 문서를 인덱싱할 수 있습니다.</li>
      <li><b>검색/인덱싱 조합</b>: 인덱스가 반만 개가 넘는 문서로 인덱싱을 로드하고 동시에 검색 및 인덱싱을 실행했습니다. 각각 10개의 변경 내용으로 몇 초마다 하나의 인덱싱 요청을 실행하여 전체 데이터 집합에 대한 일괄 업데이트가 아닌 앱&rsquo;의 데이터에 발생하는 일반적인 일반 업데이트를 시뮬레이션했습니다. 동시에 세 가지 패싯, 필터 및 상위 10개 일치 항목을 검색하는 검색을 실행했습니다. 균일한 분포를 사용하여 임의로 선택한 키워드를 사용하여 인덱스의 콜드 부분에 도달했는지 확인했습니다. 준비되면 초당 5개 이상의 쿼리를 달성했으며, 쿼리에 대한 대기 시간은 200ms이며, 그 결과(문서 100개) 일치 항목이 적고 카디널리티가 낮고 중간 카디널리티가 낮은 필드에 대한 패싯이 생성됩니다. 결과가 1000개 문서 중 10개와 일치하는 경우 QPS 및 대기 시간이 300-400밀리초 범위로 증가하기 시작할 것으로 예상할 수 있습니다. 전체 데이터 세트의 중요한 부분과 일치하는 쿼리는 상당한 대기 시간이 증가합니다.</li>
  </ul>


  <p>용량에 따라 매개 변수 내에서 작동하는 한 기본 검색 단위에서 뛰어난 성능을 얻을 수 있습니다.</p>


  <p>성능과 관련하여 주의해야 할 몇 가지 사항이 있습니다.</p>


  <ul>
      <li>많은 문서와 일치하는 쿼리를 방지하고 검색과 동시에 많은 인덱싱을 확인합니다.</li>
      <li>필요한 문서/필드만 가져옵니다($top 및 $select 사용).</li>
      <li>HTTP 클라이언트를 다시 사용하여 추가 대기 시간을 유발하는 연결을 다시 만들지 않도록 합니다.</li>
  </ul>


  <h2>기능 직접 사용해 보기</h2>


  <p>Azure Search 기본 및 가격 책정에 대한 자세한 내용은 <a href="https://azure.microsoft.com/en-us/pricing/details/search/">가격 책정 페이지를</a> 방문하거나 <a href="https://ms.portal.azure.com/#create/Microsoft.Search">여기를 클릭하여</a> 고유한 Basic Search 서비스를 만드세요.</p>
