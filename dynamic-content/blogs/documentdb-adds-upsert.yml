### YamlMime:Yaml
ms.openlocfilehash: 1ef48ca8ca1c1f8e122b45d59e2762c56cdcd016
ms.sourcegitcommit: d03bdc7fe5447adb6530886aab848b75fe8fa8ee
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/11/2022
ms.locfileid: "139899015"
Slug: documentdb-adds-upsert
Title: 'DocumentDB: 만들거나 만들지 않는 것이 질문입니다.'
Summary: Azure DocumentDB는 Atomic Upsert 추가를 발표하게 되어 기쁩니다.
Content: >-
  <p>현재 DocumentDB에 JSON 문서를 유지하는 방법에 대해 생각할 때는 중지하고 이 질문을 스스로에게 물어봐야 합니다. &ldquo;만들기를 수행해야 하나요, 아니면 바꾸기 작업을 수행해야 하나요?&rdquo;</p>


  <p>만들기 작업을 수행하고 레코드가 이미 있는 경우 오류가 발생합니다. 마찬가지로 바꾸기 작업을 수행하고 레코드가 없는&rsquo; 경우 오류가 발생합니다. 따라서 이 질문에 대한 답을 알 수 있는 유일한 방법은 먼저 ID로 읽기 또는 쿼리 작업을 수행하여 문서를 찾은 다음, 만들거나 바꿀지 결정하는 것입니다.</p>


  <p>일반적인 구현은 다음과 같습니다.</p>


  <pre class="prettyprint">

  using (DocumentClient client = new DocumentClient(new Uri(endpoint), authKey))

  {
      var docSpec = new { id = &quot;document id&quot;, foo = &quot;bar&quot; };

      var docExists = client.CreateDocumentQuery(UriFactory.CreateCollectionUri(databaseId, collectionId))
                          .Where(doc =&gt; doc.Id == &quot;document id&quot;)
                          .Select(doc =&gt; doc.Id)
                          .AsEnumerable()
                          .Any();

      //doc exists, so replace with the docSpec
      if (docExists)
      {
          Uri docUri = UriFactory.CreateDocumentUri(databaseId, collectionId, &quot;document id&quot;);
          await client.ReplaceDocumentAsync(docUri, docSpec);
      }
      //doc does not exist, so create a new document using docSpec
      else
      {
          Uri collUri = UriFactory.CreateCollectionUri(databaseId, collectionId);
          await client.CreateDocumentAsync(collUri, docSpec);
      }
  }</pre>


  <p>대부분의 경우 작동하지만 문제가 없는 것은 아닙니다. 첫 번째 문제는 레코드가 먼저 존재하는지 항상 데이터베이스에 요청하는 추가 요청 단위 비용이 든다는 것입니다.</p>


  <p>추가 쿼리 및 네트워크 왕복 비용을 무시하더라도 이 코드는 여전히 2단계 프로세스입니다. 또한 여전히 경주 상태가 발생할 위험이 있습니다. 두 프로세스가 동시에 정확히 동일한 질문을 하는 시나리오를 Imagine. SELECT * FROM c WHERE ID = &lsquo;문서 ID&rsquo; 및 두 프로세스 모두 0 결과에 대한 답변을 얻습니다. 이제 두 프로세스 모두 만들기 작업을 계속 진행합니다. 한 프로세스는 성공하고 다른 프로세스는 경주에서 우승한 다른 프로세스에 의해 이미 삽입된 레코드를 삽입하려고 했기 때문에 실패합니다.</p>


  <p>현재 DocumentDB는 백 엔드에서 원자성 Upsert 작업에 대한 지원 추가를 발표하게 되어 기쁩니다.</p>


  <p>Upsert는 이러한 두 가지 과제를 해결합니다. Upsert를 사용하면&rsquo; 먼저 문서가 있는지 여부를 묻고 수행할 작업을 결정할 필요가 없습니다. 이제 데이터베이스에서 이 결정을 내린다. 이렇게 하면 추가 요청 단위 요금이 절약 될뿐만 아니라 작업이 원자성이므로 경합 상태의 가능성도 제거됩니다.</p>


  <p>Upsert는 문서의 ID 속성을 사용하고 새 문서를 만들거나 기존 문서를 바꿀지 여부를 결정합니다. DocumentDB는 아직 문서에 대한 부분 업데이트를 지원하지 않습니다. 현재 문서의 전체 교체만 지원합니다. 따라서 문서가 이미 있는 경우(ID에 일치) 전체 문서가 Upsert 요청의 내용으로 바뀝니다.</p>


  <p>Upsert를 사용하면 위의 코드가 다음과 같이 변경됩니다.</p>


  <pre class="prettyprint">

  await client.UpsertDocumentAsync(UriFactory.CreateCollectionUri(databaseId, collectionId), docSpec);</pre>


  <p>아래의 REST 요청을 살펴보면 위의 코드는 새 사용자 지정 HTTP 헤더 x-ms-documentdb-is-upsert가 True로 설정된 문서 리소스의 POST로 변환됩니다. DocumentDB의 응답은 만들기 또는 바꾸기가 완료되었는지 여부를 알려줍니다. 만들기가 발생한 경우 HTTP 응답은 StatusCode 201이 됩니다. Replace가 발생한 경우 StatusCode는 200이 됩니다.</p>


  <p><img align="left" alt="image" height="175" src="https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/df6fcc5b-7ab3-404e-a5cd-1ea8c0f362f3.png" style="float: left; display: inline;" title="이미지" width="709"></p>


  <p>&nbsp;</p>


  <p>&nbsp;</p>


  <p>&nbsp;</p>


  <p>&nbsp;</p>


  <p>&nbsp;</p>


  <p>&nbsp;</p>


  <p>위와 같이 클라이언트 쪽 요청을 통해 Upsert 요청을 만드는 것 외에도 저장 프로시저 및 트리거를 빌드할 때 JavaScript 서버 쪽 SDK와 함께 기능을 사용할 수도 있습니다.</p>


  <p>Upsert 기능을 사용하려면 사용하는 플랫폼에 따라 최신 <a href="https://www.nuget.org/packages/Microsoft.Azure.DocumentDB/1.5.0" target="_blank">.NET</a>, <a href="https://www.npmjs.com/package/documentdb/" target="_blank">Node.js</a>, <a href="https://pypi.python.org/pypi/pydocumentdb/1.4.2" target="_blank">Python</a> 또는 <a href="https://mvnrepository.com/artifact/com.microsoft.azure/azure-documentdb/1.4.0" target="_blank">Java</a> SDK를 다운로드해야 합니다.</p>


  <p>모든 새로운 기능 릴리스와 마찬가지로 피드백을 받고 싶습니다. 아래에 의견을 남겨주세요. 도움이 필요하거나 질문이 있는 경우 MSDN 또는 <a href="https://stackoverflow.com/questions/tagged/azure-documentdb" target="_blank">StackovOverflow</a>의 <a href="https://social.msdn.microsoft.com/forums/azure/en-US/home?forum=AzureDocumentDB" target="_blank">개발자 포럼에</a> 문의하세요.</p>


  <p>Twitter <a href="https://twitter.com/DocumentDB">@DocumentDB</a>에서 팔로우하여 최신 DocumentDB 뉴스 및 기능을 최신 상태로 유지하세요.</p>


  <p>행복한 문서 upserting!</p>
