{
    "Slug": "announcing-general-availability-of-ios-offline-sync-sdk",
    "Title": "iOS 오프라인 동기화 SDK의 일반 공급 발표",
    "Summary": "Most mobile apps don't work without a network connection. Learn how to use Mobile Services offline sync on iOS, and create responsive and robust apps that work, even when your network doesn't.",
    "Content": "엘리베이터를 밟았다고 해서 모바일 앱이 갑자기 작동하지 않을 때 싫어하지 않습니까?또는 데드 존에 있는 경우에도 고객 데이터에 빠르게 액세스해야 하는 여행 영업 담당자일 수 있습니다. 최종 사용자는 네트워크가 작동하지 않는 경우에도 작동하는 앱을 원합니다. 안타깝게도 디바이스가 오프라인 상태일 때 많은 앱은 동기화 동작을 올바르게 구현하기가 매우 어렵기 때문에 기능이 제한되거나 없습니다. 디바이스에 캐시해야 하는 항목은 무엇인가요?앱에서 새 데이터를 가져와야 한다는 것을 어떻게 알 수 있나요?사용자가 오프라인 상태이지만 이미 로컬 편집을 수행한 동안 데이터가 수정되면 어떻게 되나요?\n\nMobile Services 오프라인 동기화는 이러한 모든 복잡성을 처리하는 플랫폼 간 클라이언트 SDK를 사용하여 이러한 문제를 해결하도록 설계되었습니다. 개발자는 Mobile Services 사용하여 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-get-started-offline-data/\" target=\"_blank\">iOS</a>, <a href=\"https://azure.microsoft.com/blog/2014/08/07/offline-support-in-azure-mobile-services-android-sdk/\" target=\"_blank\">Android</a>, <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-xamarin-ios-get-started-offline-data\" target=\"_blank\">Xamarin</a> 및 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-windows-store-dotnet-get-started-offline-data\" target=\"_blank\">Windows</a> 앱에서 네이티브 동기화 환경을 쉽게 제공할 수 있습니다.\n\n네이티브 iOS에 대한 이러한 새로운 동기화 기능을 추가하는 <a href=\"https://go.microsoft.com/fwLink/p/?LinkID=266533\" target=\"_blank\">Mobile Services iOS 2.0 SDK</a>의 일반 공급에 대해 발표하게 되어 기쁩니다. 오프라인 동기화는 Windows, Xamarin iOS 및 Xamarin Android용 관리되는 클라이언트 SDK 및 미리 보기 Android SDK에서 이미 사용할 수 있습니다. 이 기능을 더 쉽게 사용할 수 있도록 Azure Portal 빠른 시작을 업데이트했습니다. Objective-C iOS 빠른 시작은 이제 Windows, Xamarin iOS 및 Xamarin Android용과 함께 오프라인으로 사용할 수 있습니다.\n\n오프라인 동기화는 다음과 같은 다양한 이점을 제공합니다.\n<ul>\n    <li>서버 데이터를 디바이스에 로컬로 캐시하여 앱 응답성 향상</li>\n    <li>일시적인 네트워크 문제를 처리할 수 있는 강력한 앱 만들기</li>\n    <li>여러 디바이스 간에 데이터를 동기화하고 동일한 레코드를 두 개의 디바이스에서 수정할 때 충돌 감지</li>\n    <li>데이터 사용 감소, 특히 데이터 통신 연결의 경우</li>\n</ul>\n앱이 오프라인 모드일 때 사용자가 여전히 데이터를 만들고 수정할 수 있으며 이는 로컬 저장소에 저장됩니다. 앱이 다시 온라인 상태가 되면 로컬 변경 내용을 Mobile Services 백 엔드와 동기화할 수 있습니다. 동일한 레코드가 클라이언트와 백 엔드 모두에서 변경될 때 기능은 충돌을 감지하는 지원을 포함합니다. 충돌을 서버 또는 클라이언트에서 처리할 수 있습니다. 오프라인 동기화는 매우 간단합니다. 예를 들어 백 엔드 데이터베이스에 모든 모바일 클라이언트의 동기화 상태를 저장할 필요가 <em>없습니다</em> . Azure Mobile Services 이미 사용하고 있는 경우 다음 자습서에 따라 앱을 오프라인으로 사용하도록 설정할 수 있습니다.\n<ul>\n    <li><a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-get-started-offline-data\">Mobile Services 오프라인 데이터 동기화를 사용하여 시작</a></li>\n    <li><a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-handling-conflicts-offline-data/\">오프라인 데이터 동기화를 사용하여 충돌 처리</a></li>\n</ul>\n앱은 핵심 데이터를 사용하도록 설정하고 앱 데이터 개체와 <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-get-started-offline-data/#review-core-data\">SDK에 필요한 시스템 테이블 모두에</a> 대한 모델을 정의해야 합니다. 앱의 초기화 논리(예: iOS 빠른 시작의 <strong>QSTodoService.init)에서</strong> 모바일 서비스 로컬 저장소를 만들고 동기화 컨텍스트와 연결합니다.\n<pre class=\"prettyprint\">// create a Mobile Services local store based on the app's Core Data model\nMSCoreDataStore *store = [[MSCoreDataStore alloc] initWithManagedObjectContext:context]; \n\n// associate store with sync context \nself.client.syncContext = \n    [[MSSyncContext alloc] initWithDelegate:nil\n                                 dataSource:store \n                                   callback:nil]; \n        \n// Create an MSSyncTable instance to allow us to work with the TodoItem table\nself.syncTable = [_client syncTableWithName:@\"TodoItem\"];</pre>\n이제 앱은 모든 CRUD 작업에 <strong>MSTable이 아닌 이 MSSyncTable</strong> 인스턴스를 사용해야 합니다.<strong></strong> 읽기는 로컬 스토리지에서 가져오고 모든 만들기, 업데이트 및 삭제 작업은 서버로 전송될 큐에 대기됩니다. 이러한 지연된 변경 내용을 보내려면 <strong>pushWithCompletion 메서드를</strong> 사용합니다. 동기화 컨텍스트의 메서드이며 모든 수정 사항을 순서대로 재생합니다.\n<pre class=\"prettyprint\">[self.client.syncContext pushWithCompletion:^(NSError *error) { ... } ]</pre>\n서버에서 새 변경 내용을 가져오려면 <strong>pullWithQuery</strong> 메서드를 사용합니다.\n<pre class=\"prettyprint\">[self.syncTable pullWithQuery:query \n                      queryId:@\"allTodoItems\" \n                   completion:^(NSError *error) { ... } ]\n</pre>\n끌어오기 작업을 수행할 때 동기화 테이블에 보류 중인 변경 내용이 있는 경우 SDK는 먼저 모든 변경 내용을 푸시합니다. 증분 동기화를 사용하도록 설정하려면 <strong>queryID</strong> 매개 변수를 사용합니다. 쿼리 ID는 프로그램의 각 쿼리에 대해 고유해야 하는 설명 문자열입니다. SDK에서 내부적으로 마지막 끌어오기 작업에서 마지막으로 수정한 타임스탬프를 저장하는 데 사용됩니다. 후속 끌어오기 작업은 이 타임스탬프보다 최신 레코드만 검색합니다.\n\n<strong>pullWithQuery </strong>메서드를 사용하면 디바이스에 저장해야 하는 데이터의 특정 하위 집합을 지정할 수도 있습니다. 빠른 시작 예제에서는 간단한 데이터 모델이므로 모든 할 일 항목이 검색됩니다. 그러나 할 일 항목의 중요성을 나타내는 필드를 추가한다고 가정해 보겠습니다. 그런 다음 앱은 적절한 쿼리를 사용하여 높고 일반적인 중요도 항목만 끌어올 수 있습니다. 로컬 저장소는 핵심 데이터를 사용하므로 <strong>NSFetchedResultsController를</strong> 사용하여 키-값 관찰을 사용하여 뷰 컨트롤러와 통합할 수 있습니다. iOS 빠른 시작에서는 테이블 뷰를 Core Data 관리 개체 컨텍스트에 연결하여 이 예제를 보여  있습니다. iOS 및 다른 플랫폼의 오프라인 동기화에 대해 자세히 알아보려면 다음 리소스를 확인하세요.\n<ul>\n    <li>자습서: <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-get-started-offline-data\">Mobile Services 오프라인 데이터 동기화로 시작</a> <a href=\"https://azure.microsoft.com/en-us/documentation/articles/mobile-services-ios-handling-conflicts-offline-data/\">오프라인 데이터 동기화와의 충돌 처리</a></li>\n    <li><a href=\"https://channel9.msdn.com/Shows/Cloud+Cover/Episode-155-Offline-Storage-with-Donna-Malayeri\">오프라인 동기화의 클라우드 커버 에피소드</a>(Windows, Xamarin 및 iOS 표시)</li>\n    <li><a href=\"https://chrisrisner.com/LensRocket-for-iOS-Source-Code-Released\">iOS 샘플 앱 – LensRocket</a></li>\n    <li><a href=\"https://azure.microsoft.com/en-us/documentation/videos/azure-mobile-services-offline-enabled-apps-with-donna-malayeri/\">오프라인 동기화의 Azure Friday 짧은 비디오</a>(Windows)</li>\n</ul>"
}