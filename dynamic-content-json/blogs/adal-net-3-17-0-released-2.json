{
    "Slug": "adal-net-3-17-0-released-2",
    "Title": "ADAL.NET 3.17.0 릴리스됨",
    "Summary": "ADAL.NET (Microsoft.IdentityModel.Clients.ActiveDirectory) is an authentication library which enables developers to acquire tokens from Azure AD and ADFS, to be used to access Microsoft APIs or applications registered with Azure Active Directory. ADAL.NET is available on several .NET platforms (Desktop, Universal Windows Platform, Xamarin / Android, Xamarin iOS, Portable Class Libraries, and .NET Core).",
    "Content": "<p>ADAL.NET(<a href=\"https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/\">Microsoft.IdentityModel.Clients.ActiveDirectory</a>)는 개발자가 Azure AD 및 ADFS에서 토큰을 획득하여 microsoft API 또는 Azure Active Directory 등록된 애플리케이션에 액세스할 수 있도록 하는 인증 라이브러리입니다. ADAL.NET 데스크톱, 유니버설 Windows 플랫폼, Xamarin/Android, Xamarin iOS, 이식 가능한 클래스 라이브러리 및 .NET Core를 비롯한 여러 .NET 플랫폼에서 사용할 수 있습니다. 방금 ADAL.NET 3.17.0을 릴리스하여 새로운 기능을 가능하게 하고 유용성, 개인 정보 보호 및 성능 측면에서 향상된 기능을 제공합니다.</p>\n\n<h2>새 기능 사용</h2>\n\n<p>ADAL.Net 3.17.0을 사용하면 다음을 수행할 수 있습니다.</p>\n\n<ul>\n    <li>Azure AD 제한에 관대하게 더 효율적인 애플리케이션을 작성합니다.</li>\n    <li>앱의 최종 사용자가 로그인한 경우에도 ID를 선택하도록 강제 적용합니다.</li>\n    <li>보다 효과적인 조건부 액세스를 처리합니다.</li>\n</ul>\n\n<h3>보다 효율적인 애플리케이션 사용(예: Retry-After)</h3>\n\n<p>ErrorCode <em>&quot;temporarily_unavailable&quot;</em> <em>사용하여 AdalException</em>을 처리, 획득 및 catch하는 샘플 중 일부를 볼 수 있습니다. 너무 많은 요청으로 인해 &ldquo;STS(서비스 토큰 서버)가 너무 많은 경우 다시 시도할 수 있는 경우(응답 필드 다시 시도 후) 시간(초) 또는 날짜에 대한 힌트와 함께 HTTP 오류 429를 반환합니다&rdquo;.</p>\n\n<p>이전에는 ADAL.NET 이 정보를 표시하지 않았습니다. 따라서 오류를 처리하기 위해 하드 코딩된 임의 지연을 기다린 후 임의의 횟수를 다시 시도하는 것이 좋습니다. 콘솔 애플리케이션의 경우 코드는 다음과 같을 수 있습니다.</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n            retry = true;\n            retryCount++;\n            Thread.Sleep(3000);\n        }\n      &hellip;\n    }\n     &hellip;\n} while ((retry == true) &amp;&amp; (retryCount &lt; 2)); \n</pre>\n\n<p>ADAL.NET 3.17.0부터 System.Net.Http.Headers를 표시합니다<em>. HttpResponseHeaders</em>는 <em>AdalServiceException</em>에서 Headers라는 새 속성입니다. 따라서 추가 정보를 활용하여 애플리케이션의 안정성을 향상시킬 수 있습니다. 방금 설명한 경우 RetryAfter 속성( <em>RetryConditionHeaderValue</em> 형식)을 사용하고 재시도 시기를 계산할 수 있습니다.</p>\n\n<p>기밀 클라이언트 <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-authentication-scenarios#application-types-and-scenarios\">애플리케이션</a> 또는 퍼블릭 클라이언트 애플리케이션에 ADAL.Net 사용하는<strong>지에 따라</strong> <em>AdalServiceException</em>을 직접 또는 <em>AdalException의 InnerException</em>으로 catch해야 합니다.</p>\n\n<p>다음 코드 조각은 사례에 따라 진행하는 방법을 보여 줍니다.</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    TimeSpan ?delay;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n\n    // Case of a Confidential client flow \n    // (for instance auth code redemption in a Web App)\n    catch (AdalServiceException serviceException)\n    {\n     if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n        RetryConditionHeaderValue retry= serviceException.Headers.RetryAfter;\n        if (retry.Delta.HasValue)\n              {\n            delay = retry.Delta;\n              }\n        else if (retry.Date.HasValue)\n              {\n            delay = retry.Date.Value.Offset;\n              }\n        }\n\n    }\n    \n    // Case of a client side exception\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n     var serviceEx = ex.InnerException as AdalServiceException;\n    // Same kind of processing as above\n        }\n    &hellip;\n    }\n    &hellip;\n   if (delay.HasValue)\n   {\n    Thread.Sleep((int)delay.Value.TotalSeconds); // sleep or other\nretry = true;\n   }\n\n} while (retry); \n</pre>\n\n<h3>사용자가 계정을 선택하도록 강제 적용</h3>\n\n<p>더 많은 사람들이 여러 개인, 전문 및 조직 ID를 사용하고 있습니다. 애플리케이션에서 사용자가 사용할 ID를 선택하려는 사용 사례가 있을 수 있습니다. 이러한 사용 사례를 사용하도록 설정하기 위해 상호 작용을 지원하는 플랫폼(데스크톱, WinRT, Xamarin iOS 및 Xamarin Android)에 대한 <em>PromptBehavior</em> 열거형에 <em>새 값 SelectAccount</em>를 추가했습니다. 사용하는 경우 이미 로그인한 경우에도 앱&rsquo; 사용자가 계정을 선택하도록 강제하여 캐시 조회를 무시하고 UI를 직접 표시합니다.</p>\n\n<p><em>PromptBehavior</em>를 사용했을 수 있습니다. <em>항상</em> 과거에는 토큰 캐시를 바이패스하고 사용자 인터페이스를 제공합니다. <em>PromptBehavior</em>. <em>SelectAccount</em> 는 사용 가능한 사용자를 타일로 표시하도록 Azure AD에 지시하고 사용자가 다시 로그인하도록 강제하지 않기 때문에 다릅니다(쿠키를 사용할 수 있다고 가정하고 브라우저에서 사용자와 Azure AD 간의 상호 작용을 기억하세요). 타일의 존재는 동작이 라이브러리&rsquo; purview 외부에서 완전히 관리되는 쿠키 수명에 의해 결정되기 때문에 Single Sign-On 환경을 보장하지 않습니다.</p>\n\n<h3>애플리케이션이 조건부 액세스(및 기타 클레임 챌린지)를 처리할 수 있도록 설정</h3>\n\n<p>대부분의 <a href=\"https://github.com/Azure-Samples?utf8=%E2%9C%93&amp;q=azure-active-directory\">샘플</a> 은 간단하게 유지하려고 하지만 엔터프라이즈 지원 애플리케이션을 생성하려면 오류 처리에 좀 더 많은 노력을 기울여야 한다는 것을 알고 있을 것입니다. 이를 위해 ADAL.NET 3.16.0에서는 애플리케이션이 사용자에게 애플리케이션이 추가 리소스에 액세스하는 것을 수락하도록 허용하거나 다단계 인증을 수행하도록 허용해야 하는 경우 Azure AD에서 보낸 클레임 챌린지를 처리할 수 있습니다. ADAL.NET 3.17.0에서는 누락된 클레임을 얻을 수 있도록 <em>AdalClaimChallengeException</em>에 대한 내부 예외로 <em>HttpRequestWrapperException</em>을 API 호출자에게 다시 전달하여 이 기능을 사용하도록 설정했습니다. 그런 다음 이러한 추가 클레임을 새 클레임 멤버가 있는 acquireToken 재정의에 전달할 수 있습니다.</p>\n\n<p>아래 코드 조각은 <a href=\"https://github.com/Azure-Samples/active-directory-dotnet-webapi-onbehalfof-ca/blob/master/TodoListService/Controllers/AccessCaApiController.cs#L88-L98\">active-directory-dotnet-webapi-onbehalfof-ca</a> 샘플에서 추출됩니다. TodoList 서비스(기밀 클라이언트)에서 Azure AD에서 받은 클레임 챌린지와 이 챌린지가 클라이언트에 전파되어 필요한 사용자 상호 작용(예: 2단계 인증)을 가질 수 있도록 하는 방법을 보여 줍니다.</p>\n\n<pre class=\"prettyprint\">\ntry\n{\n    result = await authContext.AcquireTokenAsync(caResourceId, clientCred,\n                                                 userAssertion);\n}\ncatch (AdalClaimChallengeException ex)\n{\n    HttpResponseMessage myMessage = new HttpResponseMessage \n    { StatusCode = HttpStatusCode.Forbidden, ReasonPhrase = INTERACTION_REQUIRED,\n      Content = new StringContent(ex.Claims) };\n    throw new HttpResponseException(myMessage);\n}\ncatch (AdalServiceException ex)\n{\n  &hellip;\n</pre>\n\n<p>클라이언트 쪽(TodoListClient)에서 TodoList 서비스를 호출하고 더 많은 클레임으로 토큰을 다시 요청할 때 이 챌린지를 가져오는 코드는 다음과 같습니다.</p>\n\n<pre class=\"prettyprint\">\n// We successfully got a token.\nhttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, result.AccessToken);\n\n// while calling the API.\nHttpResponseMessage response = await httpClient.GetAsync(todoListBaseAddress \n                                                         + &quot;/api/AccessCaApi&quot;);\n\nif (response.StatusCode == System.Net.HttpStatusCode.Forbidden \n    &amp;&amp; response.ReasonPhrase == INTERACTION_REQUIRED)\n {\n     // We need to re-request the token to account for a Conditional Access Policy\n     String claimsParam = await response.Content.ReadAsStringAsync();\n\n    try\n    {\n     result = await authContext.AcquireTokenAsync(todoListResourceId, clientId,\n                     redirectUri, new PlatformParameters(PromptBehavior.Always), \n                     new UserIdentifier(displayName,\n                                        UserIdentifierType.OptionalDisplayableId),\n                     extraQueryParameters:null, \n                     claims: claimsParam);\n     &hellip;\n</pre>\n\n<p>자세한 내용은 <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-conditional-access-developer\">Azure Active Directory 조건부 액세스에 대한 개발자 지침</a> 및 이 문서에서 연결된 샘플에 설명되어 있습니다.</p>\n\n<h2>유용성 향상</h2>\n\n<h3>이제 ADAL.NET NuGet 패키지에는 각 플랫폼에 대해 하나의 DLL이 포함됩니다.</h3>\n\n<p>ADAL.NET 종속성 주입을 사용하여 다른 플랫폼 특정 어셈블리를 동적으로 로드하는 하나의 공통 어셈블리로 패키징되었습니다. 이로 인해 문제가 발생했습니다(예: #511). 이식 가능한 라이브러리에서 NuGet 패키지를 참조할 때는 기본 어셈블리에서 플랫폼별 어셈블리를 참조해야 했는데, 이는 매우 직관적이지 않았습니다.</p>\n\n<p>ADAL.NET 3.17.0부터 NuGet 패키지에는 이제 각 플랫폼에 대한 단일 DLL이 포함됩니다.</p>\n\n<p>구현 세부 정보에 관심이 있는 경우 GitHub ADAL.NET&rsquo; 소스 코드를 살펴보면 weve&rsquo;가 ADAL.NET&rsquo; 다중 <a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Clients.ActiveDirectory/Microsoft.IdentityModel.Clients.ActiveDirectory.csproj#L11\">대상 프로젝트</a>로 이동된 것을 볼 수 있습니다.</p>\n\n<h3>일부 플랫폼에서는 의미가 없는 API를 숨겨 혼동 제거</h3>\n\n<p><strong>이제 WinRT 앱은 하나의 ClientCredential 생성자만 사용할 수 있습니다.</strong></p>\n\n<p>WinRT 애플리케이션이 일반적으로 퍼블릭 클라이언트 애플리케이션인 경우에도 클라이언트 자격 증명 흐름을 사용하여 사용자가 로그인하지 않은 키오스크 모드 시나리오를 사용하도록 설정할 수도 있습니다. 지금까지 기밀 클라이언트 시나리오에서 사용된 <em>ClientCredential</em> 클래스에는 두 가지 재정의가 있었습니다.</p>\n\n<ul>\n    <li>하나는 애플리케이션 비밀, <em>공용 ClientCredential(string clientId, string clientSecret)입니다.</em></li>\n    <li><em>권한 부여 코드를</em> 사용하거나 사용자 어설션을 전달하는 코드입니다.</li>\n</ul>\n\n<p>나중에 WinRT 애플리케이션에는 의미가 없습니다. &rsquo;이제 데스크톱 애플리케이션에서만 사용할 수 있습니다.</p>\n\n<p><strong>디바이스 프로필 API는 이제 데스크톱, .NET Core 및 UWP 앱에서만 사용할 수 있습니다.</strong></p>\n\n<p>Device Profile API <em>AcquireTokenByDeviceCodeAsync(DeviceCodeResult deviceCodeResult)</em> 는 <em>AcquireDeviceCodeAsync</em> 의 재정의 중 하나를 사용하여 이전에 요청한 디바이스 코드를 사용하여 STS에서 보안 토큰을 획득합니다( <a href=\"https://azure.microsoft.com/en-us/resources/samples/active-directory-dotnet-deviceprofile\">텍스트 전용 디바이스에서 Azure AD로 보호되는 API 호출</a> 참조). <em>AcquireTokenByDeviceCodeAsync</em> 는 텍스트 전용 디바이스가 아닌 Xamarin iOS 및 Xamarin Android에서 더 이상 사용할 수 없습니다. 데스크톱, .NET Core 및 UWP(IoT용) 앱에서만 사용해야 합니다. 이로써 <em>AcquireDeviceCodeAsync</em> 는 Android 및 iOS에서 아직 사용할 수 없기 때문에 더욱 일관됩니다.</p>\n\n<h3>향상된 설명서</h3>\n\n<p>참조 설명서에서 UserPasswordCredential 및 AcquireToken에 대해 혼동되는 여러 문제를 해결했습니다(<a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues/654\">654 참조#</a>). 또한 <em>IAdalLogCallback</em> 인터페이스를 구현하여 로깅을 사용하도록 설정하는 방법 및 외부 브로커(Xamarin iOS/Xamarin Android의 경우)와 상호 작용하는 방법에 대한 지침과 함께 라이브러리&rsquo; readme.md 업데이트했습니다.</p>\n\n<h2>개인 정보 보호 및 성능 향상</h2>\n\n<p>아시다시피 <em>LoggerCallbackHandler</em>에 할당하여 ADAL.NET 로거에서 로깅을 활성화할 수 있습니다. 콜백은 <em>IAdalLogCallback </em>인터페이스를 구현하는 클래스의 인스턴스입니다. 이 작업을 수행하고 자세한 정보 표시를 선택했을 때 ADAL.Net Azure AD에 요청을 보낼 때 두 개의 메시지를 볼 수 있습니다.</p>\n\n<ul>\n    <li><em>&ldquo;전체 URL로 이동 &lsquo;&rsquo;&rdquo;</em></li>\n    <li><em>&ldquo;URL 완료로 이동 &lsquo;&rsquo;&rdquo;</em></li>\n</ul>\n\n<p><em>여기서&lsquo; 전체 URL&rsquo;</em>은 Azure AD로 전송된 전체 URL입니다. 일부 프롬프트 동작과 함께 사용자의 UPN(사용자 계정 이름)과 같은 개인 정보를 포함합니다.</p>\n\n<p>전체 URL을 더 이상 로깅하지 않음으로써 개인 정보를 개선했습니다.</p>\n\n<p>또한 Xamarin iOS 플랫폼과 관련된 메모리 누수 문제를 수정하여 성능을 향상시켰습니다.</p>\n\n<h2>맺음말</h2>\n\n<p>평소처럼 수&rsquo;화는 여러분의 의견을 듣는 것을 좋아합니다. 제발:</p>\n\n<ul>\n    <li>ADAL 태그를 사용하여 <a href=\"https://stackoverflow.com/questions/tagged/adal\">Stack Overflow</a>에 대해&nbsp; 질문합니다.</li>\n    <li>ADAL.Net 오픈 소스 리포지토리의 GitHub <a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues\">문제를</a> 사용하여 버그를 보고하거나 기능을 요청합니다.</li>\n    <li><a href=\"https://feedback.azure.com/forums/169401-azure-active-directory\">사용자 의견 페이지를</a> 사용하여 권장 사항 및/또는 피드백 제공</li>\n</ul>\n"
}